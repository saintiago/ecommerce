/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading wasm modules
/******/ 	var installedWasmModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// object with all compiled WebAssembly.Modules
/******/ 	__webpack_require__.w = {};
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/stock/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../.nvm/versions/node/v10.0.0/lib/node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLm52bS92ZXJzaW9ucy9ub2RlL3YxMC4wLjAvbGliL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcz9jZWQyIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../.nvm/versions/node/v10.0.0/lib/node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./node_modules/amqplib/channel_api.js":
/*!*********************************************!*\
  !*** ./node_modules/amqplib/channel_api.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var raw_connect = __webpack_require__(/*! ./lib/connect */ \"./node_modules/amqplib/lib/connect.js\").connect;\nvar ChannelModel = __webpack_require__(/*! ./lib/channel_model */ \"./node_modules/amqplib/lib/channel_model.js\").ChannelModel;\nvar Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/release/bluebird.js\");\n\nfunction connect(url, connOptions) {\n  return Promise.fromCallback(function(cb) {\n    return raw_connect(url, connOptions, cb);\n  })\n  .then(function(conn) {\n    return new ChannelModel(conn);\n  });\n};\n\nmodule.exports.connect = connect;\nmodule.exports.credentials = __webpack_require__(/*! ./lib/credentials */ \"./node_modules/amqplib/lib/credentials.js\");\nmodule.exports.IllegalOperationError = __webpack_require__(/*! ./lib/error */ \"./node_modules/amqplib/lib/error.js\").IllegalOperationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9jaGFubmVsX2FwaS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2NoYW5uZWxfYXBpLmpzP2NhYjAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJhd19jb25uZWN0ID0gcmVxdWlyZSgnLi9saWIvY29ubmVjdCcpLmNvbm5lY3Q7XG52YXIgQ2hhbm5lbE1vZGVsID0gcmVxdWlyZSgnLi9saWIvY2hhbm5lbF9tb2RlbCcpLkNoYW5uZWxNb2RlbDtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcblxuZnVuY3Rpb24gY29ubmVjdCh1cmwsIGNvbm5PcHRpb25zKSB7XG4gIHJldHVybiBQcm9taXNlLmZyb21DYWxsYmFjayhmdW5jdGlvbihjYikge1xuICAgIHJldHVybiByYXdfY29ubmVjdCh1cmwsIGNvbm5PcHRpb25zLCBjYik7XG4gIH0pXG4gIC50aGVuKGZ1bmN0aW9uKGNvbm4pIHtcbiAgICByZXR1cm4gbmV3IENoYW5uZWxNb2RlbChjb25uKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gY29ubmVjdDtcbm1vZHVsZS5leHBvcnRzLmNyZWRlbnRpYWxzID0gcmVxdWlyZSgnLi9saWIvY3JlZGVudGlhbHMnKTtcbm1vZHVsZS5leHBvcnRzLklsbGVnYWxPcGVyYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vbGliL2Vycm9yJykuSWxsZWdhbE9wZXJhdGlvbkVycm9yO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/amqplib/channel_api.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/api_args.js":
/*!**********************************************!*\
  !*** ./node_modules/amqplib/lib/api_args.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//\n//\n//\n\n\n\n/*\nThe channel (promise) and callback APIs have similar signatures, and\nin particular, both need AMQP fields prepared from the same arguments\nand options. The arguments marshalling is done here. Each of the\nprocedures below takes arguments and options (the latter in an object)\nparticular to the operation it represents, and returns an object with\nfields for handing to the encoder.\n*/\n\n// A number of AMQP methods have a table-typed field called\n// `arguments`, that is intended to carry extension-specific\n// values. RabbitMQ uses this in a number of places; e.g., to specify\n// an 'alternate exchange'.\n//\n// Many of the methods in this API have an `options` argument, from\n// which I take both values that have a default in AMQP (e.g.,\n// autoDelete in QueueDeclare) *and* values that are specific to\n// RabbitMQ (e.g., 'alternate-exchange'), which would normally be\n// supplied in `arguments`. So that extensions I don't support yet can\n// be used, I include `arguments` itself among the options.\n//\n// The upshot of this is that I often need to prepare an `arguments`\n// value that has any values passed in `options.arguments` as well as\n// any I've promoted to being options themselves. Since I don't want\n// to mutate anything passed in, the general pattern is to create a\n// fresh object with the `arguments` value given as its prototype; all\n// fields in the supplied value will be serialised, as well as any I\n// set on the fresh object. What I don't want to do, however, is set a\n// field to undefined by copying possibly missing field values,\n// because that will mask a value in the prototype.\n//\n// NB the `arguments` field already has a default value of `{}`, so\n// there's no need to explicitly default it unless I'm setting values.\nfunction setIfDefined(obj, prop, value) {\n  if (value != undefined) obj[prop] = value;\n}\n\nvar EMPTY_OPTIONS = Object.freeze({});\n\nvar Args = {};\n\nArgs.assertQueue = function(queue, options) {\n  queue = queue || '';\n  options = options || EMPTY_OPTIONS;\n\n  var argt = Object.create(options.arguments || null);\n  setIfDefined(argt, 'x-expires', options.expires);\n  setIfDefined(argt, 'x-message-ttl', options.messageTtl);\n  setIfDefined(argt, 'x-dead-letter-exchange',\n               options.deadLetterExchange);\n  setIfDefined(argt, 'x-dead-letter-routing-key',\n               options.deadLetterRoutingKey);\n  setIfDefined(argt, 'x-max-length', options.maxLength);\n  setIfDefined(argt, 'x-max-priority', options.maxPriority);\n\n  return {\n    queue: queue,\n    exclusive: !!options.exclusive,\n    durable: (options.durable === undefined) ? true : options.durable,\n    autoDelete: !!options.autoDelete,\n    arguments: argt,\n    passive: false,\n    // deprecated but we have to include it\n    ticket: 0,\n    nowait: false\n  };\n};\n\nArgs.checkQueue = function(queue) {\n  return {\n    queue: queue,\n    passive: true, // switch to \"completely different\" mode\n    nowait: false,\n    durable: true, autoDelete: false, exclusive: false, // ignored\n    ticket: 0,\n  };\n};\n\nArgs.deleteQueue = function(queue, options) {\n  options = options || EMPTY_OPTIONS;\n  return {\n    queue: queue,\n    ifUnused: !!options.ifUnused,\n    ifEmpty: !!options.ifEmpty,\n    ticket: 0, nowait: false\n  };\n};\n\nArgs.purgeQueue = function(queue) {\n  return {\n    queue: queue,\n    ticket: 0, nowait: false\n  };\n};\n\nArgs.bindQueue = function(queue, source, pattern, argt) {\n  return {\n    queue: queue,\n    exchange: source,\n    routingKey: pattern,\n    arguments: argt,\n    ticket: 0, nowait: false\n  };\n};\n\nArgs.unbindQueue = function(queue, source, pattern, argt) {\n  return {\n    queue: queue,\n    exchange: source,\n    routingKey: pattern,\n    arguments: argt,\n    ticket: 0, nowait: false\n  };\n};\n\nArgs.assertExchange = function(exchange, type, options) {\n  options = options || EMPTY_OPTIONS;\n  var argt = Object.create(options.arguments || null);\n  setIfDefined(argt, 'alternate-exchange', options.alternateExchange);\n  return {\n    exchange: exchange,\n    ticket: 0,\n    type: type,\n    passive: false,\n    durable: (options.durable === undefined) ? true : options.durable,\n    autoDelete: !!options.autoDelete,\n    internal: !!options.internal,\n    nowait: false,\n    arguments: argt\n  };\n};\n\nArgs.checkExchange = function(exchange) {\n  return {\n    exchange: exchange,\n    passive: true, // switch to 'may as well be another method' mode\n    nowait: false,\n    // ff are ignored\n    durable: true, internal: false,  type: '',  autoDelete: false,\n    ticket: 0\n  };\n};\n\nArgs.deleteExchange = function(exchange, options) {\n  options = options || EMPTY_OPTIONS;\n  return {\n    exchange: exchange,\n    ifUnused: !!options.ifUnused,\n    ticket: 0, nowait: false\n  };\n};\n\nArgs.bindExchange = function(dest, source, pattern, argt) {\n  return {\n    source: source,\n    destination: dest,\n    routingKey: pattern,\n    arguments: argt,\n    ticket: 0, nowait: false\n  };\n};\n\nArgs.unbindExchange = function(dest, source, pattern, argt) {\n  return {\n    source: source,\n    destination: dest,\n    routingKey: pattern,\n    arguments: argt,\n    ticket: 0, nowait: false\n  };\n};\n\n// It's convenient to construct the properties and the method fields\n// at the same time, since in the APIs, values for both can appear in\n// `options`. Since the property or mthod field names don't overlap, I\n// just return one big object that can be used for both purposes, and\n// the encoder will pick out what it wants.\nArgs.publish = function(exchange, routingKey, options) {\n  options = options || EMPTY_OPTIONS;\n\n  // The CC and BCC fields expect an array of \"longstr\", which would\n  // normally be buffer values in JavaScript; however, since a field\n  // array (or table) cannot have shortstr values, the codec will\n  // encode all strings as longstrs anyway.\n  function convertCC(cc) {\n    if (cc === undefined) {\n      return undefined;\n    }\n    else if (Array.isArray(cc)) {\n      return cc.map(String);\n    }\n    else return [String(cc)];\n  }\n\n  var headers = Object.create(options.headers || null);\n  setIfDefined(headers, 'CC', convertCC(options.CC));\n  setIfDefined(headers, 'BCC', convertCC(options.BCC));\n\n  var deliveryMode; // undefined will default to 1 (non-persistent)\n\n  // Previously I overloaded deliveryMode be a boolean meaning\n  // 'persistent or not'; better is to name this option for what it\n  // is, but I need to have backwards compatibility for applications\n  // that either supply a numeric or boolean value.\n  if (options.persistent !== undefined)\n    deliveryMode = (options.persistent) ? 2 : 1;\n  else if (typeof options.deliveryMode === 'number')\n    deliveryMode = options.deliveryMode;\n  else if (options.deliveryMode) // is supplied and truthy\n    deliveryMode = 2;\n\n  var expiration = options.expiration;\n  if (expiration !== undefined) expiration = expiration.toString();\n\n  return {\n    // method fields\n    exchange: exchange,\n    routingKey: routingKey,\n    mandatory: !!options.mandatory,\n    immediate: false, // RabbitMQ doesn't implement this any more\n    ticket: undefined,\n    // properties\n    contentType: options.contentType,\n    contentEncoding: options.contentEncoding,\n    headers: headers,\n    deliveryMode: deliveryMode,\n    priority: options.priority,\n    correlationId: options.correlationId,\n    replyTo: options.replyTo,\n    expiration: expiration,\n    messageId: options.messageId,\n    timestamp: options.timestamp,\n    type: options.type,\n    userId: options.userId,\n    appId: options.appId,\n    clusterId: undefined\n  };\n};\n\nArgs.consume = function(queue, options) {\n  options = options || EMPTY_OPTIONS;\n  var argt = Object.create(options.arguments || null);\n  setIfDefined(argt, 'x-priority', options.priority);\n  return {\n    ticket: 0,\n    queue: queue,\n    consumerTag: options.consumerTag || '',\n    noLocal: !!options.noLocal,\n    noAck: !!options.noAck,\n    exclusive: !!options.exclusive,\n    nowait: false,\n    arguments: argt\n  };\n};\n\nArgs.cancel = function(consumerTag) {\n  return {\n    consumerTag: consumerTag,\n    nowait: false\n  };\n};\n\nArgs.get = function(queue, options) {\n  options = options || EMPTY_OPTIONS;\n  return {\n    ticket: 0,\n    queue: queue,\n    noAck: !!options.noAck\n  };\n};\n\nArgs.ack = function(tag, allUpTo) {\n  return {\n    deliveryTag: tag,\n    multiple: !!allUpTo\n  };\n};\n\nArgs.nack = function(tag, allUpTo, requeue) {\n  return {\n    deliveryTag: tag,\n    multiple: !!allUpTo,\n    requeue: (requeue === undefined) ? true : requeue\n  };\n};\n\nArgs.reject = function(tag, requeue) {\n  return {\n    deliveryTag: tag,\n    requeue: (requeue === undefined) ? true : requeue\n  };\n};\n\nArgs.prefetch = function(count, global) {\n  return {\n    prefetchCount: count || 0,\n    prefetchSize: 0,\n    global: !!global\n  };\n};\n\nArgs.recover = function() {\n  return {requeue: true};\n};\n\nmodule.exports = Object.freeze(Args);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvYXBpX2FyZ3MuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvYXBpX2FyZ3MuanM/ZWFhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG5cbid1c2Ugc3RyaWN0JztcblxuLypcblRoZSBjaGFubmVsIChwcm9taXNlKSBhbmQgY2FsbGJhY2sgQVBJcyBoYXZlIHNpbWlsYXIgc2lnbmF0dXJlcywgYW5kXG5pbiBwYXJ0aWN1bGFyLCBib3RoIG5lZWQgQU1RUCBmaWVsZHMgcHJlcGFyZWQgZnJvbSB0aGUgc2FtZSBhcmd1bWVudHNcbmFuZCBvcHRpb25zLiBUaGUgYXJndW1lbnRzIG1hcnNoYWxsaW5nIGlzIGRvbmUgaGVyZS4gRWFjaCBvZiB0aGVcbnByb2NlZHVyZXMgYmVsb3cgdGFrZXMgYXJndW1lbnRzIGFuZCBvcHRpb25zICh0aGUgbGF0dGVyIGluIGFuIG9iamVjdClcbnBhcnRpY3VsYXIgdG8gdGhlIG9wZXJhdGlvbiBpdCByZXByZXNlbnRzLCBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aFxuZmllbGRzIGZvciBoYW5kaW5nIHRvIHRoZSBlbmNvZGVyLlxuKi9cblxuLy8gQSBudW1iZXIgb2YgQU1RUCBtZXRob2RzIGhhdmUgYSB0YWJsZS10eXBlZCBmaWVsZCBjYWxsZWRcbi8vIGBhcmd1bWVudHNgLCB0aGF0IGlzIGludGVuZGVkIHRvIGNhcnJ5IGV4dGVuc2lvbi1zcGVjaWZpY1xuLy8gdmFsdWVzLiBSYWJiaXRNUSB1c2VzIHRoaXMgaW4gYSBudW1iZXIgb2YgcGxhY2VzOyBlLmcuLCB0byBzcGVjaWZ5XG4vLyBhbiAnYWx0ZXJuYXRlIGV4Y2hhbmdlJy5cbi8vXG4vLyBNYW55IG9mIHRoZSBtZXRob2RzIGluIHRoaXMgQVBJIGhhdmUgYW4gYG9wdGlvbnNgIGFyZ3VtZW50LCBmcm9tXG4vLyB3aGljaCBJIHRha2UgYm90aCB2YWx1ZXMgdGhhdCBoYXZlIGEgZGVmYXVsdCBpbiBBTVFQIChlLmcuLFxuLy8gYXV0b0RlbGV0ZSBpbiBRdWV1ZURlY2xhcmUpICphbmQqIHZhbHVlcyB0aGF0IGFyZSBzcGVjaWZpYyB0b1xuLy8gUmFiYml0TVEgKGUuZy4sICdhbHRlcm5hdGUtZXhjaGFuZ2UnKSwgd2hpY2ggd291bGQgbm9ybWFsbHkgYmVcbi8vIHN1cHBsaWVkIGluIGBhcmd1bWVudHNgLiBTbyB0aGF0IGV4dGVuc2lvbnMgSSBkb24ndCBzdXBwb3J0IHlldCBjYW5cbi8vIGJlIHVzZWQsIEkgaW5jbHVkZSBgYXJndW1lbnRzYCBpdHNlbGYgYW1vbmcgdGhlIG9wdGlvbnMuXG4vL1xuLy8gVGhlIHVwc2hvdCBvZiB0aGlzIGlzIHRoYXQgSSBvZnRlbiBuZWVkIHRvIHByZXBhcmUgYW4gYGFyZ3VtZW50c2Bcbi8vIHZhbHVlIHRoYXQgaGFzIGFueSB2YWx1ZXMgcGFzc2VkIGluIGBvcHRpb25zLmFyZ3VtZW50c2AgYXMgd2VsbCBhc1xuLy8gYW55IEkndmUgcHJvbW90ZWQgdG8gYmVpbmcgb3B0aW9ucyB0aGVtc2VsdmVzLiBTaW5jZSBJIGRvbid0IHdhbnRcbi8vIHRvIG11dGF0ZSBhbnl0aGluZyBwYXNzZWQgaW4sIHRoZSBnZW5lcmFsIHBhdHRlcm4gaXMgdG8gY3JlYXRlIGFcbi8vIGZyZXNoIG9iamVjdCB3aXRoIHRoZSBgYXJndW1lbnRzYCB2YWx1ZSBnaXZlbiBhcyBpdHMgcHJvdG90eXBlOyBhbGxcbi8vIGZpZWxkcyBpbiB0aGUgc3VwcGxpZWQgdmFsdWUgd2lsbCBiZSBzZXJpYWxpc2VkLCBhcyB3ZWxsIGFzIGFueSBJXG4vLyBzZXQgb24gdGhlIGZyZXNoIG9iamVjdC4gV2hhdCBJIGRvbid0IHdhbnQgdG8gZG8sIGhvd2V2ZXIsIGlzIHNldCBhXG4vLyBmaWVsZCB0byB1bmRlZmluZWQgYnkgY29weWluZyBwb3NzaWJseSBtaXNzaW5nIGZpZWxkIHZhbHVlcyxcbi8vIGJlY2F1c2UgdGhhdCB3aWxsIG1hc2sgYSB2YWx1ZSBpbiB0aGUgcHJvdG90eXBlLlxuLy9cbi8vIE5CIHRoZSBgYXJndW1lbnRzYCBmaWVsZCBhbHJlYWR5IGhhcyBhIGRlZmF1bHQgdmFsdWUgb2YgYHt9YCwgc29cbi8vIHRoZXJlJ3Mgbm8gbmVlZCB0byBleHBsaWNpdGx5IGRlZmF1bHQgaXQgdW5sZXNzIEknbSBzZXR0aW5nIHZhbHVlcy5cbmZ1bmN0aW9uIHNldElmRGVmaW5lZChvYmosIHByb3AsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQpIG9ialtwcm9wXSA9IHZhbHVlO1xufVxuXG52YXIgRU1QVFlfT1BUSU9OUyA9IE9iamVjdC5mcmVlemUoe30pO1xuXG52YXIgQXJncyA9IHt9O1xuXG5BcmdzLmFzc2VydFF1ZXVlID0gZnVuY3Rpb24ocXVldWUsIG9wdGlvbnMpIHtcbiAgcXVldWUgPSBxdWV1ZSB8fCAnJztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUztcblxuICB2YXIgYXJndCA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5hcmd1bWVudHMgfHwgbnVsbCk7XG4gIHNldElmRGVmaW5lZChhcmd0LCAneC1leHBpcmVzJywgb3B0aW9ucy5leHBpcmVzKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LW1lc3NhZ2UtdHRsJywgb3B0aW9ucy5tZXNzYWdlVHRsKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LWRlYWQtbGV0dGVyLWV4Y2hhbmdlJyxcbiAgICAgICAgICAgICAgIG9wdGlvbnMuZGVhZExldHRlckV4Y2hhbmdlKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LWRlYWQtbGV0dGVyLXJvdXRpbmcta2V5JyxcbiAgICAgICAgICAgICAgIG9wdGlvbnMuZGVhZExldHRlclJvdXRpbmdLZXkpO1xuICBzZXRJZkRlZmluZWQoYXJndCwgJ3gtbWF4LWxlbmd0aCcsIG9wdGlvbnMubWF4TGVuZ3RoKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LW1heC1wcmlvcml0eScsIG9wdGlvbnMubWF4UHJpb3JpdHkpO1xuXG4gIHJldHVybiB7XG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIGV4Y2x1c2l2ZTogISFvcHRpb25zLmV4Y2x1c2l2ZSxcbiAgICBkdXJhYmxlOiAob3B0aW9ucy5kdXJhYmxlID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG9wdGlvbnMuZHVyYWJsZSxcbiAgICBhdXRvRGVsZXRlOiAhIW9wdGlvbnMuYXV0b0RlbGV0ZSxcbiAgICBhcmd1bWVudHM6IGFyZ3QsXG4gICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgLy8gZGVwcmVjYXRlZCBidXQgd2UgaGF2ZSB0byBpbmNsdWRlIGl0XG4gICAgdGlja2V0OiAwLFxuICAgIG5vd2FpdDogZmFsc2VcbiAgfTtcbn07XG5cbkFyZ3MuY2hlY2tRdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gIHJldHVybiB7XG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIHBhc3NpdmU6IHRydWUsIC8vIHN3aXRjaCB0byBcImNvbXBsZXRlbHkgZGlmZmVyZW50XCIgbW9kZVxuICAgIG5vd2FpdDogZmFsc2UsXG4gICAgZHVyYWJsZTogdHJ1ZSwgYXV0b0RlbGV0ZTogZmFsc2UsIGV4Y2x1c2l2ZTogZmFsc2UsIC8vIGlnbm9yZWRcbiAgICB0aWNrZXQ6IDAsXG4gIH07XG59O1xuXG5BcmdzLmRlbGV0ZVF1ZXVlID0gZnVuY3Rpb24ocXVldWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUztcbiAgcmV0dXJuIHtcbiAgICBxdWV1ZTogcXVldWUsXG4gICAgaWZVbnVzZWQ6ICEhb3B0aW9ucy5pZlVudXNlZCxcbiAgICBpZkVtcHR5OiAhIW9wdGlvbnMuaWZFbXB0eSxcbiAgICB0aWNrZXQ6IDAsIG5vd2FpdDogZmFsc2VcbiAgfTtcbn07XG5cbkFyZ3MucHVyZ2VRdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gIHJldHVybiB7XG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIHRpY2tldDogMCwgbm93YWl0OiBmYWxzZVxuICB9O1xufTtcblxuQXJncy5iaW5kUXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gIHJldHVybiB7XG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIGV4Y2hhbmdlOiBzb3VyY2UsXG4gICAgcm91dGluZ0tleTogcGF0dGVybixcbiAgICBhcmd1bWVudHM6IGFyZ3QsXG4gICAgdGlja2V0OiAwLCBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG5BcmdzLnVuYmluZFF1ZXVlID0gZnVuY3Rpb24ocXVldWUsIHNvdXJjZSwgcGF0dGVybiwgYXJndCkge1xuICByZXR1cm4ge1xuICAgIHF1ZXVlOiBxdWV1ZSxcbiAgICBleGNoYW5nZTogc291cmNlLFxuICAgIHJvdXRpbmdLZXk6IHBhdHRlcm4sXG4gICAgYXJndW1lbnRzOiBhcmd0LFxuICAgIHRpY2tldDogMCwgbm93YWl0OiBmYWxzZVxuICB9O1xufTtcblxuQXJncy5hc3NlcnRFeGNoYW5nZSA9IGZ1bmN0aW9uKGV4Y2hhbmdlLCB0eXBlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IEVNUFRZX09QVElPTlM7XG4gIHZhciBhcmd0ID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zLmFyZ3VtZW50cyB8fCBudWxsKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICdhbHRlcm5hdGUtZXhjaGFuZ2UnLCBvcHRpb25zLmFsdGVybmF0ZUV4Y2hhbmdlKTtcbiAgcmV0dXJuIHtcbiAgICBleGNoYW5nZTogZXhjaGFuZ2UsXG4gICAgdGlja2V0OiAwLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgZHVyYWJsZTogKG9wdGlvbnMuZHVyYWJsZSA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBvcHRpb25zLmR1cmFibGUsXG4gICAgYXV0b0RlbGV0ZTogISFvcHRpb25zLmF1dG9EZWxldGUsXG4gICAgaW50ZXJuYWw6ICEhb3B0aW9ucy5pbnRlcm5hbCxcbiAgICBub3dhaXQ6IGZhbHNlLFxuICAgIGFyZ3VtZW50czogYXJndFxuICB9O1xufTtcblxuQXJncy5jaGVja0V4Y2hhbmdlID0gZnVuY3Rpb24oZXhjaGFuZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBleGNoYW5nZTogZXhjaGFuZ2UsXG4gICAgcGFzc2l2ZTogdHJ1ZSwgLy8gc3dpdGNoIHRvICdtYXkgYXMgd2VsbCBiZSBhbm90aGVyIG1ldGhvZCcgbW9kZVxuICAgIG5vd2FpdDogZmFsc2UsXG4gICAgLy8gZmYgYXJlIGlnbm9yZWRcbiAgICBkdXJhYmxlOiB0cnVlLCBpbnRlcm5hbDogZmFsc2UsICB0eXBlOiAnJywgIGF1dG9EZWxldGU6IGZhbHNlLFxuICAgIHRpY2tldDogMFxuICB9O1xufTtcblxuQXJncy5kZWxldGVFeGNoYW5nZSA9IGZ1bmN0aW9uKGV4Y2hhbmdlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IEVNUFRZX09QVElPTlM7XG4gIHJldHVybiB7XG4gICAgZXhjaGFuZ2U6IGV4Y2hhbmdlLFxuICAgIGlmVW51c2VkOiAhIW9wdGlvbnMuaWZVbnVzZWQsXG4gICAgdGlja2V0OiAwLCBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG5BcmdzLmJpbmRFeGNoYW5nZSA9IGZ1bmN0aW9uKGRlc3QsIHNvdXJjZSwgcGF0dGVybiwgYXJndCkge1xuICByZXR1cm4ge1xuICAgIHNvdXJjZTogc291cmNlLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0LFxuICAgIHJvdXRpbmdLZXk6IHBhdHRlcm4sXG4gICAgYXJndW1lbnRzOiBhcmd0LFxuICAgIHRpY2tldDogMCwgbm93YWl0OiBmYWxzZVxuICB9O1xufTtcblxuQXJncy51bmJpbmRFeGNoYW5nZSA9IGZ1bmN0aW9uKGRlc3QsIHNvdXJjZSwgcGF0dGVybiwgYXJndCkge1xuICByZXR1cm4ge1xuICAgIHNvdXJjZTogc291cmNlLFxuICAgIGRlc3RpbmF0aW9uOiBkZXN0LFxuICAgIHJvdXRpbmdLZXk6IHBhdHRlcm4sXG4gICAgYXJndW1lbnRzOiBhcmd0LFxuICAgIHRpY2tldDogMCwgbm93YWl0OiBmYWxzZVxuICB9O1xufTtcblxuLy8gSXQncyBjb252ZW5pZW50IHRvIGNvbnN0cnVjdCB0aGUgcHJvcGVydGllcyBhbmQgdGhlIG1ldGhvZCBmaWVsZHNcbi8vIGF0IHRoZSBzYW1lIHRpbWUsIHNpbmNlIGluIHRoZSBBUElzLCB2YWx1ZXMgZm9yIGJvdGggY2FuIGFwcGVhciBpblxuLy8gYG9wdGlvbnNgLiBTaW5jZSB0aGUgcHJvcGVydHkgb3IgbXRob2QgZmllbGQgbmFtZXMgZG9uJ3Qgb3ZlcmxhcCwgSVxuLy8ganVzdCByZXR1cm4gb25lIGJpZyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYm90aCBwdXJwb3NlcywgYW5kXG4vLyB0aGUgZW5jb2RlciB3aWxsIHBpY2sgb3V0IHdoYXQgaXQgd2FudHMuXG5BcmdzLnB1Ymxpc2ggPSBmdW5jdGlvbihleGNoYW5nZSwgcm91dGluZ0tleSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBFTVBUWV9PUFRJT05TO1xuXG4gIC8vIFRoZSBDQyBhbmQgQkNDIGZpZWxkcyBleHBlY3QgYW4gYXJyYXkgb2YgXCJsb25nc3RyXCIsIHdoaWNoIHdvdWxkXG4gIC8vIG5vcm1hbGx5IGJlIGJ1ZmZlciB2YWx1ZXMgaW4gSmF2YVNjcmlwdDsgaG93ZXZlciwgc2luY2UgYSBmaWVsZFxuICAvLyBhcnJheSAob3IgdGFibGUpIGNhbm5vdCBoYXZlIHNob3J0c3RyIHZhbHVlcywgdGhlIGNvZGVjIHdpbGxcbiAgLy8gZW5jb2RlIGFsbCBzdHJpbmdzIGFzIGxvbmdzdHJzIGFueXdheS5cbiAgZnVuY3Rpb24gY29udmVydENDKGNjKSB7XG4gICAgaWYgKGNjID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2MpKSB7XG4gICAgICByZXR1cm4gY2MubWFwKFN0cmluZyk7XG4gICAgfVxuICAgIGVsc2UgcmV0dXJuIFtTdHJpbmcoY2MpXTtcbiAgfVxuXG4gIHZhciBoZWFkZXJzID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zLmhlYWRlcnMgfHwgbnVsbCk7XG4gIHNldElmRGVmaW5lZChoZWFkZXJzLCAnQ0MnLCBjb252ZXJ0Q0Mob3B0aW9ucy5DQykpO1xuICBzZXRJZkRlZmluZWQoaGVhZGVycywgJ0JDQycsIGNvbnZlcnRDQyhvcHRpb25zLkJDQykpO1xuXG4gIHZhciBkZWxpdmVyeU1vZGU7IC8vIHVuZGVmaW5lZCB3aWxsIGRlZmF1bHQgdG8gMSAobm9uLXBlcnNpc3RlbnQpXG5cbiAgLy8gUHJldmlvdXNseSBJIG92ZXJsb2FkZWQgZGVsaXZlcnlNb2RlIGJlIGEgYm9vbGVhbiBtZWFuaW5nXG4gIC8vICdwZXJzaXN0ZW50IG9yIG5vdCc7IGJldHRlciBpcyB0byBuYW1lIHRoaXMgb3B0aW9uIGZvciB3aGF0IGl0XG4gIC8vIGlzLCBidXQgSSBuZWVkIHRvIGhhdmUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIGFwcGxpY2F0aW9uc1xuICAvLyB0aGF0IGVpdGhlciBzdXBwbHkgYSBudW1lcmljIG9yIGJvb2xlYW4gdmFsdWUuXG4gIGlmIChvcHRpb25zLnBlcnNpc3RlbnQgIT09IHVuZGVmaW5lZClcbiAgICBkZWxpdmVyeU1vZGUgPSAob3B0aW9ucy5wZXJzaXN0ZW50KSA/IDIgOiAxO1xuICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5kZWxpdmVyeU1vZGUgPT09ICdudW1iZXInKVxuICAgIGRlbGl2ZXJ5TW9kZSA9IG9wdGlvbnMuZGVsaXZlcnlNb2RlO1xuICBlbHNlIGlmIChvcHRpb25zLmRlbGl2ZXJ5TW9kZSkgLy8gaXMgc3VwcGxpZWQgYW5kIHRydXRoeVxuICAgIGRlbGl2ZXJ5TW9kZSA9IDI7XG5cbiAgdmFyIGV4cGlyYXRpb24gPSBvcHRpb25zLmV4cGlyYXRpb247XG4gIGlmIChleHBpcmF0aW9uICE9PSB1bmRlZmluZWQpIGV4cGlyYXRpb24gPSBleHBpcmF0aW9uLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBtZXRob2QgZmllbGRzXG4gICAgZXhjaGFuZ2U6IGV4Y2hhbmdlLFxuICAgIHJvdXRpbmdLZXk6IHJvdXRpbmdLZXksXG4gICAgbWFuZGF0b3J5OiAhIW9wdGlvbnMubWFuZGF0b3J5LFxuICAgIGltbWVkaWF0ZTogZmFsc2UsIC8vIFJhYmJpdE1RIGRvZXNuJ3QgaW1wbGVtZW50IHRoaXMgYW55IG1vcmVcbiAgICB0aWNrZXQ6IHVuZGVmaW5lZCxcbiAgICAvLyBwcm9wZXJ0aWVzXG4gICAgY29udGVudFR5cGU6IG9wdGlvbnMuY29udGVudFR5cGUsXG4gICAgY29udGVudEVuY29kaW5nOiBvcHRpb25zLmNvbnRlbnRFbmNvZGluZyxcbiAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgIGRlbGl2ZXJ5TW9kZTogZGVsaXZlcnlNb2RlLFxuICAgIHByaW9yaXR5OiBvcHRpb25zLnByaW9yaXR5LFxuICAgIGNvcnJlbGF0aW9uSWQ6IG9wdGlvbnMuY29ycmVsYXRpb25JZCxcbiAgICByZXBseVRvOiBvcHRpb25zLnJlcGx5VG8sXG4gICAgZXhwaXJhdGlvbjogZXhwaXJhdGlvbixcbiAgICBtZXNzYWdlSWQ6IG9wdGlvbnMubWVzc2FnZUlkLFxuICAgIHRpbWVzdGFtcDogb3B0aW9ucy50aW1lc3RhbXAsXG4gICAgdHlwZTogb3B0aW9ucy50eXBlLFxuICAgIHVzZXJJZDogb3B0aW9ucy51c2VySWQsXG4gICAgYXBwSWQ6IG9wdGlvbnMuYXBwSWQsXG4gICAgY2x1c3RlcklkOiB1bmRlZmluZWRcbiAgfTtcbn07XG5cbkFyZ3MuY29uc3VtZSA9IGZ1bmN0aW9uKHF1ZXVlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IEVNUFRZX09QVElPTlM7XG4gIHZhciBhcmd0ID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zLmFyZ3VtZW50cyB8fCBudWxsKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LXByaW9yaXR5Jywgb3B0aW9ucy5wcmlvcml0eSk7XG4gIHJldHVybiB7XG4gICAgdGlja2V0OiAwLFxuICAgIHF1ZXVlOiBxdWV1ZSxcbiAgICBjb25zdW1lclRhZzogb3B0aW9ucy5jb25zdW1lclRhZyB8fCAnJyxcbiAgICBub0xvY2FsOiAhIW9wdGlvbnMubm9Mb2NhbCxcbiAgICBub0FjazogISFvcHRpb25zLm5vQWNrLFxuICAgIGV4Y2x1c2l2ZTogISFvcHRpb25zLmV4Y2x1c2l2ZSxcbiAgICBub3dhaXQ6IGZhbHNlLFxuICAgIGFyZ3VtZW50czogYXJndFxuICB9O1xufTtcblxuQXJncy5jYW5jZWwgPSBmdW5jdGlvbihjb25zdW1lclRhZykge1xuICByZXR1cm4ge1xuICAgIGNvbnN1bWVyVGFnOiBjb25zdW1lclRhZyxcbiAgICBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG5BcmdzLmdldCA9IGZ1bmN0aW9uKHF1ZXVlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IEVNUFRZX09QVElPTlM7XG4gIHJldHVybiB7XG4gICAgdGlja2V0OiAwLFxuICAgIHF1ZXVlOiBxdWV1ZSxcbiAgICBub0FjazogISFvcHRpb25zLm5vQWNrXG4gIH07XG59O1xuXG5BcmdzLmFjayA9IGZ1bmN0aW9uKHRhZywgYWxsVXBUbykge1xuICByZXR1cm4ge1xuICAgIGRlbGl2ZXJ5VGFnOiB0YWcsXG4gICAgbXVsdGlwbGU6ICEhYWxsVXBUb1xuICB9O1xufTtcblxuQXJncy5uYWNrID0gZnVuY3Rpb24odGFnLCBhbGxVcFRvLCByZXF1ZXVlKSB7XG4gIHJldHVybiB7XG4gICAgZGVsaXZlcnlUYWc6IHRhZyxcbiAgICBtdWx0aXBsZTogISFhbGxVcFRvLFxuICAgIHJlcXVldWU6IChyZXF1ZXVlID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IHJlcXVldWVcbiAgfTtcbn07XG5cbkFyZ3MucmVqZWN0ID0gZnVuY3Rpb24odGFnLCByZXF1ZXVlKSB7XG4gIHJldHVybiB7XG4gICAgZGVsaXZlcnlUYWc6IHRhZyxcbiAgICByZXF1ZXVlOiAocmVxdWV1ZSA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiByZXF1ZXVlXG4gIH07XG59O1xuXG5BcmdzLnByZWZldGNoID0gZnVuY3Rpb24oY291bnQsIGdsb2JhbCkge1xuICByZXR1cm4ge1xuICAgIHByZWZldGNoQ291bnQ6IGNvdW50IHx8IDAsXG4gICAgcHJlZmV0Y2hTaXplOiAwLFxuICAgIGdsb2JhbDogISFnbG9iYWxcbiAgfTtcbn07XG5cbkFyZ3MucmVjb3ZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge3JlcXVldWU6IHRydWV9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKEFyZ3MpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/api_args.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/bitset.js":
/*!********************************************!*\
  !*** ./node_modules/amqplib/lib/bitset.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//\n//\n//\n\n// A bitset implementation, after that in java.util.  Yes there\n// already exist such things, but none implement next{Clear|Set}Bit or\n// equivalent, and none involved me tooling about for an evening.\n\n\n\nfunction BitSet(size) {\n  if (size) {\n    var numWords = Math.ceil(size / 32);\n    this.words = new Array(numWords);\n  }\n  else {\n    this.words = [];\n  }\n  this.wordsInUse = 0; // = number, not index\n}\n\nvar P = BitSet.prototype;\n\nfunction wordIndex(bitIndex) {\n  return Math.floor(bitIndex / 32);\n}\n\n// Make sure we have at least numWords\nP.ensureSize = function(numWords) {\n  var wordsPresent = this.words.length;\n  if (wordsPresent < numWords) {\n    this.words = this.words.concat(new Array(numWords - wordsPresent));\n  }\n}\n\nP.set = function(bitIndex) {\n  var w = wordIndex(bitIndex);\n  if (w >= this.wordsInUse) {\n    this.ensureSize(w + 1);\n    this.wordsInUse = w + 1;\n  }\n  var bit = 1 << bitIndex;\n  this.words[w] |= bit;\n};\n\nP.clear = function(bitIndex) {\n  var w = wordIndex(bitIndex);\n  if (w >= this.wordsInUse) return;\n  var mask = ~(1 << bitIndex);\n  this.words[w] &= mask;\n};\n\nP.get = function(bitIndex) {\n  var w = wordIndex(bitIndex);\n  if (w >= this.wordsInUse) return false; // >= since index vs size\n  var bit = 1 << bitIndex;\n  return !!(this.words[w] & bit);\n}\n\nfunction trailingZeros(i) {\n  // From Hacker's Delight, via JDK. Probably far less effective here,\n  // since bit ops are not necessarily the quick way to do things in\n  // JS.\n  if (i === 0) return 32;\n  var y, n = 31;\n  y = i << 16; if (y != 0) { n = n -16; i = y; }\n  y = i << 8;  if (y != 0) { n = n - 8; i = y; }\n  y = i << 4;  if (y != 0) { n = n - 4; i = y; }\n  y = i << 2;  if (y != 0) { n = n - 2; i = y; }\n  return n - ((i << 1) >>> 31);\n}\n\n// Give the next bit that's set on or after fromIndex, or -1 if no such\n// bit\nP.nextSetBit = function(fromIndex) {\n  var w = wordIndex(fromIndex);\n  if (w >= this.wordsInUse) return -1;\n\n  // the right-hand side is shifted to only test the bits of the first\n  // word that are > fromIndex\n  var word = this.words[w] & (0xffffffff << fromIndex);\n  while (true) {\n    if (word) return (w * 32) + trailingZeros(word);\n    w++;\n    if (w === this.wordsInUse) return -1;\n    word = this.words[w];\n  }\n};\n\nP.nextClearBit = function(fromIndex) {\n  var w = wordIndex(fromIndex);\n  if (w >= this.wordsInUse) return fromIndex;\n\n  var word = ~(this.words[w]) & (0xffffffff << fromIndex);\n  while (true) {\n    if (word) return (w * 32) + trailingZeros(word);\n    w++;\n    if (w == this.wordsInUse) return w * 32;\n    word = ~(this.words[w]);\n  }\n};\n\nmodule.exports.BitSet = BitSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvYml0c2V0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2JpdHNldC5qcz80YjRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vL1xuLy9cblxuLy8gQSBiaXRzZXQgaW1wbGVtZW50YXRpb24sIGFmdGVyIHRoYXQgaW4gamF2YS51dGlsLiAgWWVzIHRoZXJlXG4vLyBhbHJlYWR5IGV4aXN0IHN1Y2ggdGhpbmdzLCBidXQgbm9uZSBpbXBsZW1lbnQgbmV4dHtDbGVhcnxTZXR9Qml0IG9yXG4vLyBlcXVpdmFsZW50LCBhbmQgbm9uZSBpbnZvbHZlZCBtZSB0b29saW5nIGFib3V0IGZvciBhbiBldmVuaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEJpdFNldChzaXplKSB7XG4gIGlmIChzaXplKSB7XG4gICAgdmFyIG51bVdvcmRzID0gTWF0aC5jZWlsKHNpemUgLyAzMik7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheShudW1Xb3Jkcyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy53b3JkcyA9IFtdO1xuICB9XG4gIHRoaXMud29yZHNJblVzZSA9IDA7IC8vID0gbnVtYmVyLCBub3QgaW5kZXhcbn1cblxudmFyIFAgPSBCaXRTZXQucHJvdG90eXBlO1xuXG5mdW5jdGlvbiB3b3JkSW5kZXgoYml0SW5kZXgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoYml0SW5kZXggLyAzMik7XG59XG5cbi8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IG51bVdvcmRzXG5QLmVuc3VyZVNpemUgPSBmdW5jdGlvbihudW1Xb3Jkcykge1xuICB2YXIgd29yZHNQcmVzZW50ID0gdGhpcy53b3Jkcy5sZW5ndGg7XG4gIGlmICh3b3Jkc1ByZXNlbnQgPCBudW1Xb3Jkcykge1xuICAgIHRoaXMud29yZHMgPSB0aGlzLndvcmRzLmNvbmNhdChuZXcgQXJyYXkobnVtV29yZHMgLSB3b3Jkc1ByZXNlbnQpKTtcbiAgfVxufVxuXG5QLnNldCA9IGZ1bmN0aW9uKGJpdEluZGV4KSB7XG4gIHZhciB3ID0gd29yZEluZGV4KGJpdEluZGV4KTtcbiAgaWYgKHcgPj0gdGhpcy53b3Jkc0luVXNlKSB7XG4gICAgdGhpcy5lbnN1cmVTaXplKHcgKyAxKTtcbiAgICB0aGlzLndvcmRzSW5Vc2UgPSB3ICsgMTtcbiAgfVxuICB2YXIgYml0ID0gMSA8PCBiaXRJbmRleDtcbiAgdGhpcy53b3Jkc1t3XSB8PSBiaXQ7XG59O1xuXG5QLmNsZWFyID0gZnVuY3Rpb24oYml0SW5kZXgpIHtcbiAgdmFyIHcgPSB3b3JkSW5kZXgoYml0SW5kZXgpO1xuICBpZiAodyA+PSB0aGlzLndvcmRzSW5Vc2UpIHJldHVybjtcbiAgdmFyIG1hc2sgPSB+KDEgPDwgYml0SW5kZXgpO1xuICB0aGlzLndvcmRzW3ddICY9IG1hc2s7XG59O1xuXG5QLmdldCA9IGZ1bmN0aW9uKGJpdEluZGV4KSB7XG4gIHZhciB3ID0gd29yZEluZGV4KGJpdEluZGV4KTtcbiAgaWYgKHcgPj0gdGhpcy53b3Jkc0luVXNlKSByZXR1cm4gZmFsc2U7IC8vID49IHNpbmNlIGluZGV4IHZzIHNpemVcbiAgdmFyIGJpdCA9IDEgPDwgYml0SW5kZXg7XG4gIHJldHVybiAhISh0aGlzLndvcmRzW3ddICYgYml0KTtcbn1cblxuZnVuY3Rpb24gdHJhaWxpbmdaZXJvcyhpKSB7XG4gIC8vIEZyb20gSGFja2VyJ3MgRGVsaWdodCwgdmlhIEpESy4gUHJvYmFibHkgZmFyIGxlc3MgZWZmZWN0aXZlIGhlcmUsXG4gIC8vIHNpbmNlIGJpdCBvcHMgYXJlIG5vdCBuZWNlc3NhcmlseSB0aGUgcXVpY2sgd2F5IHRvIGRvIHRoaW5ncyBpblxuICAvLyBKUy5cbiAgaWYgKGkgPT09IDApIHJldHVybiAzMjtcbiAgdmFyIHksIG4gPSAzMTtcbiAgeSA9IGkgPDwgMTY7IGlmICh5ICE9IDApIHsgbiA9IG4gLTE2OyBpID0geTsgfVxuICB5ID0gaSA8PCA4OyAgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDg7IGkgPSB5OyB9XG4gIHkgPSBpIDw8IDQ7ICBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gNDsgaSA9IHk7IH1cbiAgeSA9IGkgPDwgMjsgIGlmICh5ICE9IDApIHsgbiA9IG4gLSAyOyBpID0geTsgfVxuICByZXR1cm4gbiAtICgoaSA8PCAxKSA+Pj4gMzEpO1xufVxuXG4vLyBHaXZlIHRoZSBuZXh0IGJpdCB0aGF0J3Mgc2V0IG9uIG9yIGFmdGVyIGZyb21JbmRleCwgb3IgLTEgaWYgbm8gc3VjaFxuLy8gYml0XG5QLm5leHRTZXRCaXQgPSBmdW5jdGlvbihmcm9tSW5kZXgpIHtcbiAgdmFyIHcgPSB3b3JkSW5kZXgoZnJvbUluZGV4KTtcbiAgaWYgKHcgPj0gdGhpcy53b3Jkc0luVXNlKSByZXR1cm4gLTE7XG5cbiAgLy8gdGhlIHJpZ2h0LWhhbmQgc2lkZSBpcyBzaGlmdGVkIHRvIG9ubHkgdGVzdCB0aGUgYml0cyBvZiB0aGUgZmlyc3RcbiAgLy8gd29yZCB0aGF0IGFyZSA+IGZyb21JbmRleFxuICB2YXIgd29yZCA9IHRoaXMud29yZHNbd10gJiAoMHhmZmZmZmZmZiA8PCBmcm9tSW5kZXgpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICh3b3JkKSByZXR1cm4gKHcgKiAzMikgKyB0cmFpbGluZ1plcm9zKHdvcmQpO1xuICAgIHcrKztcbiAgICBpZiAodyA9PT0gdGhpcy53b3Jkc0luVXNlKSByZXR1cm4gLTE7XG4gICAgd29yZCA9IHRoaXMud29yZHNbd107XG4gIH1cbn07XG5cblAubmV4dENsZWFyQml0ID0gZnVuY3Rpb24oZnJvbUluZGV4KSB7XG4gIHZhciB3ID0gd29yZEluZGV4KGZyb21JbmRleCk7XG4gIGlmICh3ID49IHRoaXMud29yZHNJblVzZSkgcmV0dXJuIGZyb21JbmRleDtcblxuICB2YXIgd29yZCA9IH4odGhpcy53b3Jkc1t3XSkgJiAoMHhmZmZmZmZmZiA8PCBmcm9tSW5kZXgpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICh3b3JkKSByZXR1cm4gKHcgKiAzMikgKyB0cmFpbGluZ1plcm9zKHdvcmQpO1xuICAgIHcrKztcbiAgICBpZiAodyA9PSB0aGlzLndvcmRzSW5Vc2UpIHJldHVybiB3ICogMzI7XG4gICAgd29yZCA9IH4odGhpcy53b3Jkc1t3XSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJpdFNldCA9IEJpdFNldDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/bitset.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/channel.js":
/*!*********************************************!*\
  !*** ./node_modules/amqplib/lib/channel.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//\n//\n//\n\n// Channel machinery.\n\n\n\nvar defs = __webpack_require__(/*! ./defs */ \"./node_modules/amqplib/lib/defs.js\");\nvar closeMsg = __webpack_require__(/*! ./format */ \"./node_modules/amqplib/lib/format.js\").closeMessage;\nvar inspect = __webpack_require__(/*! ./format */ \"./node_modules/amqplib/lib/format.js\").inspect;\nvar methodName = __webpack_require__(/*! ./format */ \"./node_modules/amqplib/lib/format.js\").methodName;\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar inherits = __webpack_require__(/*! util */ \"util\").inherits;\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar fmt = __webpack_require__(/*! util */ \"util\").format;\nvar IllegalOperationError = __webpack_require__(/*! ./error */ \"./node_modules/amqplib/lib/error.js\").IllegalOperationError;\nvar stackCapture = __webpack_require__(/*! ./error */ \"./node_modules/amqplib/lib/error.js\").stackCapture;\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\nfunction Channel(connection) {\n  EventEmitter.call( this );\n  this.connection = connection;\n  // for the presently outstanding RPC\n  this.reply = null;\n  // for the RPCs awaiting action\n  this.pending = [];\n  // for unconfirmed messages\n  this.lwm = 1; // the least, unconfirmed deliveryTag\n  this.unconfirmed = []; // rolling window of delivery callbacks\n  this.on('ack', this.handleConfirm.bind(this, function(cb) {\n    if (cb) cb(null);\n  }));\n  this.on('nack', this.handleConfirm.bind(this, function(cb) {\n    if (cb) cb(new Error('message nacked'));\n  }));\n  // message frame state machine\n  this.handleMessage = acceptDeliveryOrReturn;\n}\ninherits(Channel, EventEmitter);\n\nmodule.exports.Channel = Channel;\nmodule.exports.acceptMessage = acceptMessage;\n\nvar C = Channel.prototype;\n\nC.allocate = function() {\n  this.ch = this.connection.freshChannel(this);\n  return this;\n}\n\n// Incoming frames are either notifications of e.g., message delivery,\n// or replies to something we've sent. In general I deal with the\n// former by emitting an event, and with the latter by keeping a track\n// of what's expecting a reply.\n//\n// The AMQP specification implies that RPCs can't be pipelined; that\n// is, you can have only one outstanding RPC on a channel at a\n// time. Certainly that's what RabbitMQ and its clients assume. For\n// this reason, I buffer RPCs if the channel is already waiting for a\n// reply.\n\n// Just send the damn frame.\nC.sendImmediately = function(method, fields) {\n  return this.connection.sendMethod(this.ch, method, fields);\n};\n\n// Invariant: !this.reply -> pending.length == 0. That is, whenever we\n// clear a reply, we must send another RPC (and thereby fill\n// this.reply) if there is one waiting. The invariant relevant here\n// and in `accept`.\nC.sendOrEnqueue = function(method, fields, reply) {\n  if (!this.reply) { // if no reply waiting, we can go\n    assert(this.pending.length === 0);\n    this.reply = reply;\n    this.sendImmediately(method, fields);\n  }\n  else {\n    this.pending.push({method: method,\n                       fields: fields,\n                       reply: reply});\n  }\n};\n\nC.sendMessage = function(fields, properties, content) {\n  return this.connection.sendMessage(\n    this.ch,\n    defs.BasicPublish, fields,\n    defs.BasicProperties, properties,\n    content);\n};\n\n// Internal, synchronously resolved RPC; the return value is resolved\n// with the whole frame.\nC._rpc = function(method, fields, expect, cb) {\n  var self = this;\n\n  function reply(err, f) {\n    if (err === null) {\n      if (f.id === expect) {\n        return cb(null, f);\n      }\n      else {\n        // We have detected a problem, so it's up to us to close the\n        // channel\n        var expectedName = methodName(expect);\n        var e = new Error(fmt(\"Expected %s; got %s\",\n                              expectedName, inspect(f, false)));\n        self.closeWithError(fmt('Expected %s; got %s',\n                                expectedName, methodName(f.id)),\n                            defs.constants.UNEXPECTED_FRAME, e);\n        return cb(e);\n      }\n    }\n    // An error will be given if, for example, this is waiting to be\n    // sent and the connection closes\n    else if (err instanceof Error) return cb(err);\n    // A close frame will be given if this is the RPC awaiting reply\n    // and the channel is closed by the server\n    else {\n      // otherwise, it's a close frame\n      var closeReason =\n        (err.fields.classId << 16) + err.fields.methodId;\n      var e = (method === closeReason)\n        ? fmt(\"Operation failed: %s; %s\",\n              methodName(method), closeMsg(err))\n        : fmt(\"Channel closed by server: %s\", closeMsg(err));\n      return cb(new Error(e));\n    }\n  }\n\n  this.sendOrEnqueue(method, fields, reply);\n};\n\n// Shutdown protocol. There's three scenarios:\n//\n// 1. The application decides to shut the channel\n// 2. The server decides to shut the channel, possibly because of\n// something the application did\n// 3. The connection is closing, so there won't be any more frames\n// going back and forth.\n//\n// 1 and 2 involve an exchange of method frames (Close and CloseOk),\n// while 3 doesn't; the connection simply says \"shutdown\" to the\n// channel, which then acts as if it's closing, without going through\n// the exchange.\n\nfunction invalidOp(msg, stack) {\n  return function() {\n    throw new IllegalOperationError(msg, stack);\n  };\n}\n\nfunction invalidateSend(ch, msg, stack) {\n  ch.sendImmediately = ch.sendOrEnqueue = ch.sendMessage =\n    invalidOp(msg, stack);\n}\n\n// Move to entirely closed state.\nC.toClosed = function(capturedStack) {\n  this._rejectPending();\n  invalidateSend(this, 'Channel closed', capturedStack);\n  this.accept = invalidOp('Channel closed', capturedStack);\n  this.connection.releaseChannel(this.ch);\n  this.emit('close');\n};\n\n// Stop being able to send and receive methods and content. Used when\n// we close the channel. Invokes the continuation once the server has\n// acknowledged the close, but before the channel is moved to the\n// closed state.\nC.toClosing = function(capturedStack, k) {\n  var send = this.sendImmediately.bind(this);\n  invalidateSend(this, 'Channel closing', capturedStack);\n\n  this.accept = function(f) {\n    if (f.id === defs.ChannelCloseOk) {\n      if (k) k();\n      var s = stackCapture('ChannelCloseOk frame received');\n      this.toClosed(s);\n    }\n    else if (f.id === defs.ChannelClose) {\n      send(defs.ChannelCloseOk, {});\n    }\n    // else ignore frame\n  };\n};\n\nC._rejectPending = function() {\n  function rej(r) { \n    r(new Error(\"Channel ended, no reply will be forthcoming\"));\n  }\n  if (this.reply !== null) rej(this.reply);\n  this.reply = null;\n\n  var discard;\n  while (discard = this.pending.shift()) rej(discard.reply);\n  this.pending = null; // so pushes will break\n};\n\nC.closeBecause = function(reason, code, k) {\n  this.sendImmediately(defs.ChannelClose, {\n    replyText: reason,\n    replyCode: code,\n    methodId:0, classId: 0\n  });\n  var s = stackCapture('closeBecause called: ' + reason);\n  this.toClosing(s, k);\n};\n\n// If we close because there's been an error, we need to distinguish\n// between what we tell the server (`reason`) and what we report as\n// the cause in the client (`error`).\nC.closeWithError = function(reason, code, error) {\n  var self = this;\n  this.closeBecause(reason, code, function() {\n    error.code = code;\n    self.emit('error', error);\n  });\n};\n\n// A trampolining state machine for message frames on a channel. A\n// message arrives in at least two frames: first, a method announcing\n// the message (either a BasicDeliver or BasicGetOk); then, a message\n// header with the message properties; then, zero or more content\n// frames.\n\n// Keep the try/catch localised, in an attempt to avoid disabling\n// optimisation\nC.acceptMessageFrame = function(f) {\n  try {\n    this.handleMessage = this.handleMessage(f);\n  }\n  catch (msg) {\n    if (typeof msg === 'string') {\n      this.closeWithError(msg, defs.constants.UNEXPECTED_FRAME,\n                          new Error(msg));\n    }\n    else if (msg instanceof Error) {\n      this.closeWithError('Error while processing message',\n                          defs.constants.INTERNAL_ERROR, msg);\n    }\n    else {\n      this.closeWithError('Internal error while processing message',\n                          defs.constants.INTERNAL_ERROR,\n                          new Error(msg.toString()));\n    }\n  }\n};\n\n// Kick off a message delivery given a BasicDeliver or BasicReturn\n// frame (BasicGet uses the RPC mechanism)\nfunction acceptDeliveryOrReturn(f) {\n  var event;\n  if (f.id === defs.BasicDeliver) event = 'delivery';\n  else if (f.id === defs.BasicReturn) event = 'return';\n  else throw fmt(\"Expected BasicDeliver or BasicReturn; got %s\",\n                 inspect(f));\n\n  var self = this;\n  var fields = f.fields;\n  return acceptMessage(function(message) {\n    message.fields = fields;\n    self.emit(event, message);\n  });\n}\n\n// Move to the state of waiting for message frames (headers, then\n// one or more content frames)\nfunction acceptMessage(continuation) {\n  var totalSize = 0, remaining = 0;\n  var buffers = null;\n\n  var message = {\n    fields: null,\n    properties: null,\n    content: null\n  };\n\n  return headers;\n\n  // expect a headers frame\n  function headers(f) {\n    if (f.id === defs.BasicProperties) {\n      message.properties = f.fields;\n      totalSize = remaining = f.size;\n      \n      // for zero-length messages, content frames aren't required.\n      if (totalSize === 0) {\n        message.content = Buffer.alloc(0);\n        continuation(message);\n        return acceptDeliveryOrReturn;\n      }\n      else {\n        return content;        \n      }\n    }\n    else {\n      throw \"Expected headers frame after delivery\";\n    }\n  }\n\n  // expect a content frame\n  // %%% TODO cancelled messages (sent as zero-length content frame)\n  function content(f) {\n    if (f.content) {\n      var size = f.content.length;\n      remaining -= size;\n      if (remaining === 0) {\n        if (buffers !== null) {\n          buffers.push(f.content);\n          message.content = Buffer.concat(buffers);\n        }\n        else {\n          message.content = f.content;\n        }\n        continuation(message);\n        return acceptDeliveryOrReturn;\n      }\n      else if (remaining < 0) {\n        throw fmt(\"Too much content sent! Expected %d bytes\",\n                  totalSize);\n      }\n      else {\n        if (buffers !== null)\n          buffers.push(f.content);\n        else\n          buffers = [f.content];\n        return content;\n      }\n    }\n    else throw \"Expected content frame after headers\"\n  }\n}\n\nC.handleConfirm = function(handle, f) {\n  var tag = f.deliveryTag;\n  var multi = f.multiple;\n\n  if (multi) {\n    var confirmed = this.unconfirmed.splice(0, tag - this.lwm + 1);\n    this.lwm = tag + 1;\n    confirmed.forEach(handle);\n  }\n  else {\n    var c;\n    if (tag === this.lwm) {\n      c = this.unconfirmed.shift();\n      this.lwm++;\n      // Advance the LWM and the window to the next non-gap, or\n      // possibly to the end\n      while (this.unconfirmed[0] === null) {\n        this.unconfirmed.shift();\n        this.lwm++;\n      }\n    }\n    else {\n      c = this.unconfirmed[tag - this.lwm];\n      this.unconfirmed[tag - this.lwm] = null;\n    }\n    // Technically, in the single-deliveryTag case, I should report a\n    // protocol breach if it's already been confirmed.\n    handle(c);\n  }\n};\n\nC.pushConfirmCallback = function(cb) {\n  // `null` is used specifically for marking already confirmed slots,\n  // so I coerce `undefined` and `null` to false; functions are never\n  // falsey.\n  this.unconfirmed.push(cb || false);\n};\n\n// Interface for connection to use\n\nC.accept = function(f) {\n\n  switch (f.id) {\n\n    // Message frames\n  case undefined: // content frame!\n  case defs.BasicDeliver:\n  case defs.BasicReturn:\n  case defs.BasicProperties:\n    return this.acceptMessageFrame(f);\n\n    // confirmations, need to do confirm.select first\n  case defs.BasicAck:\n    return this.emit('ack', f.fields);\n  case defs.BasicNack:\n    return this.emit('nack', f.fields);\n  case defs.BasicCancel:\n    // The broker can send this if e.g., the queue is deleted.\n    return this.emit('cancel', f.fields);\n\n  case defs.ChannelClose:\n    // Any remote closure is an error to us. Reject the pending reply\n    // with the close frame, so it can see whether it was that\n    // operation that caused it to close.\n    if (this.reply) {\n      var reply = this.reply; this.reply = null;\n      reply(f);\n    }\n    var emsg = \"Channel closed by server: \" + closeMsg(f);\n    this.sendImmediately(defs.ChannelCloseOk, {});\n\n    var error = new Error(emsg);\n    error.code = f.fields.replyCode;\n    this.emit('error', error);\n\n    var s = stackCapture(emsg);\n    this.toClosed(s);\n    return;\n\n  case defs.BasicFlow:\n    // RabbitMQ doesn't send this, it just blocks the TCP socket\n    return this.closeWithError(\"Flow not implemented\",\n                               defs.constants.NOT_IMPLEMENTED,\n                               new Error('Flow not implemented'));\n\n  default: // assume all other things are replies\n    // Resolving the reply may lead to another RPC; to make sure we\n    // don't hold that up, clear this.reply\n    var reply = this.reply; this.reply = null;\n    // however, maybe there's an RPC waiting to go? If so, that'll\n    // fill this.reply again, restoring the invariant. This does rely\n    // on any response being recv'ed after resolving the promise,\n    // below; hence, I use synchronous defer.\n    if (this.pending.length > 0) {\n      var send = this.pending.shift();\n      this.reply = send.reply;\n      this.sendImmediately(send.method, send.fields);\n    }\n    return reply(null, f);\n  }\n};\n\nC.onBufferDrain = function() {\n  this.emit('drain');\n};\n\n\n// This adds just a bit more stuff useful for the APIs, but not\n// low-level machinery.\nfunction BaseChannel(connection) {\n  Channel.call(this, connection);\n  this.consumers = {};\n}\ninherits(BaseChannel, Channel);\n\nmodule.exports.BaseChannel = BaseChannel;\n\n// Not sure I like the ff, it's going to be changing hidden classes\n// all over the place. On the other hand, whaddya do.\nBaseChannel.prototype.registerConsumer = function(tag, callback) {\n  this.consumers[tag] = callback;\n};\n\nBaseChannel.prototype.unregisterConsumer = function(tag) {\n  delete this.consumers[tag];\n};\n\nBaseChannel.prototype.dispatchMessage = function(fields, message) {\n  var consumerTag = fields.consumerTag;\n  var consumer = this.consumers[consumerTag];\n  if (consumer) {\n    return consumer(message);\n  }\n  else {\n    // %%% Surely a race here\n    throw new Error(\"Unknown consumer: \" + consumerTag);\n  }\n};\n\nBaseChannel.prototype.handleDelivery = function(message) {\n  return this.dispatchMessage(message.fields, message);\n};\n\nBaseChannel.prototype.handleCancel = function(fields) {\n  return this.dispatchMessage(fields, null);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY2hhbm5lbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9jaGFubmVsLmpzP2YzY2EiXSwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vXG4vL1xuXG4vLyBDaGFubmVsIG1hY2hpbmVyeS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmcyA9IHJlcXVpcmUoJy4vZGVmcycpO1xudmFyIGNsb3NlTXNnID0gcmVxdWlyZSgnLi9mb3JtYXQnKS5jbG9zZU1lc3NhZ2U7XG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJy4vZm9ybWF0JykuaW5zcGVjdDtcbnZhciBtZXRob2ROYW1lID0gcmVxdWlyZSgnLi9mb3JtYXQnKS5tZXRob2ROYW1lO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBmbXQgPSByZXF1aXJlKCd1dGlsJykuZm9ybWF0O1xudmFyIElsbGVnYWxPcGVyYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3InKS5JbGxlZ2FsT3BlcmF0aW9uRXJyb3I7XG52YXIgc3RhY2tDYXB0dXJlID0gcmVxdWlyZSgnLi9lcnJvcicpLnN0YWNrQ2FwdHVyZTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuZnVuY3Rpb24gQ2hhbm5lbChjb25uZWN0aW9uKSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKCB0aGlzICk7XG4gIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gIC8vIGZvciB0aGUgcHJlc2VudGx5IG91dHN0YW5kaW5nIFJQQ1xuICB0aGlzLnJlcGx5ID0gbnVsbDtcbiAgLy8gZm9yIHRoZSBSUENzIGF3YWl0aW5nIGFjdGlvblxuICB0aGlzLnBlbmRpbmcgPSBbXTtcbiAgLy8gZm9yIHVuY29uZmlybWVkIG1lc3NhZ2VzXG4gIHRoaXMubHdtID0gMTsgLy8gdGhlIGxlYXN0LCB1bmNvbmZpcm1lZCBkZWxpdmVyeVRhZ1xuICB0aGlzLnVuY29uZmlybWVkID0gW107IC8vIHJvbGxpbmcgd2luZG93IG9mIGRlbGl2ZXJ5IGNhbGxiYWNrc1xuICB0aGlzLm9uKCdhY2snLCB0aGlzLmhhbmRsZUNvbmZpcm0uYmluZCh0aGlzLCBmdW5jdGlvbihjYikge1xuICAgIGlmIChjYikgY2IobnVsbCk7XG4gIH0pKTtcbiAgdGhpcy5vbignbmFjaycsIHRoaXMuaGFuZGxlQ29uZmlybS5iaW5kKHRoaXMsIGZ1bmN0aW9uKGNiKSB7XG4gICAgaWYgKGNiKSBjYihuZXcgRXJyb3IoJ21lc3NhZ2UgbmFja2VkJykpO1xuICB9KSk7XG4gIC8vIG1lc3NhZ2UgZnJhbWUgc3RhdGUgbWFjaGluZVxuICB0aGlzLmhhbmRsZU1lc3NhZ2UgPSBhY2NlcHREZWxpdmVyeU9yUmV0dXJuO1xufVxuaW5oZXJpdHMoQ2hhbm5lbCwgRXZlbnRFbWl0dGVyKTtcblxubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbCA9IENoYW5uZWw7XG5tb2R1bGUuZXhwb3J0cy5hY2NlcHRNZXNzYWdlID0gYWNjZXB0TWVzc2FnZTtcblxudmFyIEMgPSBDaGFubmVsLnByb3RvdHlwZTtcblxuQy5hbGxvY2F0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNoID0gdGhpcy5jb25uZWN0aW9uLmZyZXNoQ2hhbm5lbCh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEluY29taW5nIGZyYW1lcyBhcmUgZWl0aGVyIG5vdGlmaWNhdGlvbnMgb2YgZS5nLiwgbWVzc2FnZSBkZWxpdmVyeSxcbi8vIG9yIHJlcGxpZXMgdG8gc29tZXRoaW5nIHdlJ3ZlIHNlbnQuIEluIGdlbmVyYWwgSSBkZWFsIHdpdGggdGhlXG4vLyBmb3JtZXIgYnkgZW1pdHRpbmcgYW4gZXZlbnQsIGFuZCB3aXRoIHRoZSBsYXR0ZXIgYnkga2VlcGluZyBhIHRyYWNrXG4vLyBvZiB3aGF0J3MgZXhwZWN0aW5nIGEgcmVwbHkuXG4vL1xuLy8gVGhlIEFNUVAgc3BlY2lmaWNhdGlvbiBpbXBsaWVzIHRoYXQgUlBDcyBjYW4ndCBiZSBwaXBlbGluZWQ7IHRoYXRcbi8vIGlzLCB5b3UgY2FuIGhhdmUgb25seSBvbmUgb3V0c3RhbmRpbmcgUlBDIG9uIGEgY2hhbm5lbCBhdCBhXG4vLyB0aW1lLiBDZXJ0YWlubHkgdGhhdCdzIHdoYXQgUmFiYml0TVEgYW5kIGl0cyBjbGllbnRzIGFzc3VtZS4gRm9yXG4vLyB0aGlzIHJlYXNvbiwgSSBidWZmZXIgUlBDcyBpZiB0aGUgY2hhbm5lbCBpcyBhbHJlYWR5IHdhaXRpbmcgZm9yIGFcbi8vIHJlcGx5LlxuXG4vLyBKdXN0IHNlbmQgdGhlIGRhbW4gZnJhbWUuXG5DLnNlbmRJbW1lZGlhdGVseSA9IGZ1bmN0aW9uKG1ldGhvZCwgZmllbGRzKSB7XG4gIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZE1ldGhvZCh0aGlzLmNoLCBtZXRob2QsIGZpZWxkcyk7XG59O1xuXG4vLyBJbnZhcmlhbnQ6ICF0aGlzLnJlcGx5IC0+IHBlbmRpbmcubGVuZ3RoID09IDAuIFRoYXQgaXMsIHdoZW5ldmVyIHdlXG4vLyBjbGVhciBhIHJlcGx5LCB3ZSBtdXN0IHNlbmQgYW5vdGhlciBSUEMgKGFuZCB0aGVyZWJ5IGZpbGxcbi8vIHRoaXMucmVwbHkpIGlmIHRoZXJlIGlzIG9uZSB3YWl0aW5nLiBUaGUgaW52YXJpYW50IHJlbGV2YW50IGhlcmVcbi8vIGFuZCBpbiBgYWNjZXB0YC5cbkMuc2VuZE9yRW5xdWV1ZSA9IGZ1bmN0aW9uKG1ldGhvZCwgZmllbGRzLCByZXBseSkge1xuICBpZiAoIXRoaXMucmVwbHkpIHsgLy8gaWYgbm8gcmVwbHkgd2FpdGluZywgd2UgY2FuIGdvXG4gICAgYXNzZXJ0KHRoaXMucGVuZGluZy5sZW5ndGggPT09IDApO1xuICAgIHRoaXMucmVwbHkgPSByZXBseTtcbiAgICB0aGlzLnNlbmRJbW1lZGlhdGVseShtZXRob2QsIGZpZWxkcyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5wZW5kaW5nLnB1c2goe21ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IGZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgcmVwbHk6IHJlcGx5fSk7XG4gIH1cbn07XG5cbkMuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbihmaWVsZHMsIHByb3BlcnRpZXMsIGNvbnRlbnQpIHtcbiAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kTWVzc2FnZShcbiAgICB0aGlzLmNoLFxuICAgIGRlZnMuQmFzaWNQdWJsaXNoLCBmaWVsZHMsXG4gICAgZGVmcy5CYXNpY1Byb3BlcnRpZXMsIHByb3BlcnRpZXMsXG4gICAgY29udGVudCk7XG59O1xuXG4vLyBJbnRlcm5hbCwgc3luY2hyb25vdXNseSByZXNvbHZlZCBSUEM7IHRoZSByZXR1cm4gdmFsdWUgaXMgcmVzb2x2ZWRcbi8vIHdpdGggdGhlIHdob2xlIGZyYW1lLlxuQy5fcnBjID0gZnVuY3Rpb24obWV0aG9kLCBmaWVsZHMsIGV4cGVjdCwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIHJlcGx5KGVyciwgZikge1xuICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgIGlmIChmLmlkID09PSBleHBlY3QpIHtcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIGYpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFdlIGhhdmUgZGV0ZWN0ZWQgYSBwcm9ibGVtLCBzbyBpdCdzIHVwIHRvIHVzIHRvIGNsb3NlIHRoZVxuICAgICAgICAvLyBjaGFubmVsXG4gICAgICAgIHZhciBleHBlY3RlZE5hbWUgPSBtZXRob2ROYW1lKGV4cGVjdCk7XG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKGZtdChcIkV4cGVjdGVkICVzOyBnb3QgJXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkTmFtZSwgaW5zcGVjdChmLCBmYWxzZSkpKTtcbiAgICAgICAgc2VsZi5jbG9zZVdpdGhFcnJvcihmbXQoJ0V4cGVjdGVkICVzOyBnb3QgJXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZE5hbWUsIG1ldGhvZE5hbWUoZi5pZCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMuY29uc3RhbnRzLlVORVhQRUNURURfRlJBTUUsIGUpO1xuICAgICAgICByZXR1cm4gY2IoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFuIGVycm9yIHdpbGwgYmUgZ2l2ZW4gaWYsIGZvciBleGFtcGxlLCB0aGlzIGlzIHdhaXRpbmcgdG8gYmVcbiAgICAvLyBzZW50IGFuZCB0aGUgY29ubmVjdGlvbiBjbG9zZXNcbiAgICBlbHNlIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIGNiKGVycik7XG4gICAgLy8gQSBjbG9zZSBmcmFtZSB3aWxsIGJlIGdpdmVuIGlmIHRoaXMgaXMgdGhlIFJQQyBhd2FpdGluZyByZXBseVxuICAgIC8vIGFuZCB0aGUgY2hhbm5lbCBpcyBjbG9zZWQgYnkgdGhlIHNlcnZlclxuICAgIGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlLCBpdCdzIGEgY2xvc2UgZnJhbWVcbiAgICAgIHZhciBjbG9zZVJlYXNvbiA9XG4gICAgICAgIChlcnIuZmllbGRzLmNsYXNzSWQgPDwgMTYpICsgZXJyLmZpZWxkcy5tZXRob2RJZDtcbiAgICAgIHZhciBlID0gKG1ldGhvZCA9PT0gY2xvc2VSZWFzb24pXG4gICAgICAgID8gZm10KFwiT3BlcmF0aW9uIGZhaWxlZDogJXM7ICVzXCIsXG4gICAgICAgICAgICAgIG1ldGhvZE5hbWUobWV0aG9kKSwgY2xvc2VNc2coZXJyKSlcbiAgICAgICAgOiBmbXQoXCJDaGFubmVsIGNsb3NlZCBieSBzZXJ2ZXI6ICVzXCIsIGNsb3NlTXNnKGVycikpO1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihlKSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zZW5kT3JFbnF1ZXVlKG1ldGhvZCwgZmllbGRzLCByZXBseSk7XG59O1xuXG4vLyBTaHV0ZG93biBwcm90b2NvbC4gVGhlcmUncyB0aHJlZSBzY2VuYXJpb3M6XG4vL1xuLy8gMS4gVGhlIGFwcGxpY2F0aW9uIGRlY2lkZXMgdG8gc2h1dCB0aGUgY2hhbm5lbFxuLy8gMi4gVGhlIHNlcnZlciBkZWNpZGVzIHRvIHNodXQgdGhlIGNoYW5uZWwsIHBvc3NpYmx5IGJlY2F1c2Ugb2Zcbi8vIHNvbWV0aGluZyB0aGUgYXBwbGljYXRpb24gZGlkXG4vLyAzLiBUaGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nLCBzbyB0aGVyZSB3b24ndCBiZSBhbnkgbW9yZSBmcmFtZXNcbi8vIGdvaW5nIGJhY2sgYW5kIGZvcnRoLlxuLy9cbi8vIDEgYW5kIDIgaW52b2x2ZSBhbiBleGNoYW5nZSBvZiBtZXRob2QgZnJhbWVzIChDbG9zZSBhbmQgQ2xvc2VPayksXG4vLyB3aGlsZSAzIGRvZXNuJ3Q7IHRoZSBjb25uZWN0aW9uIHNpbXBseSBzYXlzIFwic2h1dGRvd25cIiB0byB0aGVcbi8vIGNoYW5uZWwsIHdoaWNoIHRoZW4gYWN0cyBhcyBpZiBpdCdzIGNsb3NpbmcsIHdpdGhvdXQgZ29pbmcgdGhyb3VnaFxuLy8gdGhlIGV4Y2hhbmdlLlxuXG5mdW5jdGlvbiBpbnZhbGlkT3AobXNnLCBzdGFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IElsbGVnYWxPcGVyYXRpb25FcnJvcihtc2csIHN0YWNrKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZVNlbmQoY2gsIG1zZywgc3RhY2spIHtcbiAgY2guc2VuZEltbWVkaWF0ZWx5ID0gY2guc2VuZE9yRW5xdWV1ZSA9IGNoLnNlbmRNZXNzYWdlID1cbiAgICBpbnZhbGlkT3AobXNnLCBzdGFjayk7XG59XG5cbi8vIE1vdmUgdG8gZW50aXJlbHkgY2xvc2VkIHN0YXRlLlxuQy50b0Nsb3NlZCA9IGZ1bmN0aW9uKGNhcHR1cmVkU3RhY2spIHtcbiAgdGhpcy5fcmVqZWN0UGVuZGluZygpO1xuICBpbnZhbGlkYXRlU2VuZCh0aGlzLCAnQ2hhbm5lbCBjbG9zZWQnLCBjYXB0dXJlZFN0YWNrKTtcbiAgdGhpcy5hY2NlcHQgPSBpbnZhbGlkT3AoJ0NoYW5uZWwgY2xvc2VkJywgY2FwdHVyZWRTdGFjayk7XG4gIHRoaXMuY29ubmVjdGlvbi5yZWxlYXNlQ2hhbm5lbCh0aGlzLmNoKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuLy8gU3RvcCBiZWluZyBhYmxlIHRvIHNlbmQgYW5kIHJlY2VpdmUgbWV0aG9kcyBhbmQgY29udGVudC4gVXNlZCB3aGVuXG4vLyB3ZSBjbG9zZSB0aGUgY2hhbm5lbC4gSW52b2tlcyB0aGUgY29udGludWF0aW9uIG9uY2UgdGhlIHNlcnZlciBoYXNcbi8vIGFja25vd2xlZGdlZCB0aGUgY2xvc2UsIGJ1dCBiZWZvcmUgdGhlIGNoYW5uZWwgaXMgbW92ZWQgdG8gdGhlXG4vLyBjbG9zZWQgc3RhdGUuXG5DLnRvQ2xvc2luZyA9IGZ1bmN0aW9uKGNhcHR1cmVkU3RhY2ssIGspIHtcbiAgdmFyIHNlbmQgPSB0aGlzLnNlbmRJbW1lZGlhdGVseS5iaW5kKHRoaXMpO1xuICBpbnZhbGlkYXRlU2VuZCh0aGlzLCAnQ2hhbm5lbCBjbG9zaW5nJywgY2FwdHVyZWRTdGFjayk7XG5cbiAgdGhpcy5hY2NlcHQgPSBmdW5jdGlvbihmKSB7XG4gICAgaWYgKGYuaWQgPT09IGRlZnMuQ2hhbm5lbENsb3NlT2spIHtcbiAgICAgIGlmIChrKSBrKCk7XG4gICAgICB2YXIgcyA9IHN0YWNrQ2FwdHVyZSgnQ2hhbm5lbENsb3NlT2sgZnJhbWUgcmVjZWl2ZWQnKTtcbiAgICAgIHRoaXMudG9DbG9zZWQocyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGYuaWQgPT09IGRlZnMuQ2hhbm5lbENsb3NlKSB7XG4gICAgICBzZW5kKGRlZnMuQ2hhbm5lbENsb3NlT2ssIHt9KTtcbiAgICB9XG4gICAgLy8gZWxzZSBpZ25vcmUgZnJhbWVcbiAgfTtcbn07XG5cbkMuX3JlamVjdFBlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gcmVqKHIpIHsgXG4gICAgcihuZXcgRXJyb3IoXCJDaGFubmVsIGVuZGVkLCBubyByZXBseSB3aWxsIGJlIGZvcnRoY29taW5nXCIpKTtcbiAgfVxuICBpZiAodGhpcy5yZXBseSAhPT0gbnVsbCkgcmVqKHRoaXMucmVwbHkpO1xuICB0aGlzLnJlcGx5ID0gbnVsbDtcblxuICB2YXIgZGlzY2FyZDtcbiAgd2hpbGUgKGRpc2NhcmQgPSB0aGlzLnBlbmRpbmcuc2hpZnQoKSkgcmVqKGRpc2NhcmQucmVwbHkpO1xuICB0aGlzLnBlbmRpbmcgPSBudWxsOyAvLyBzbyBwdXNoZXMgd2lsbCBicmVha1xufTtcblxuQy5jbG9zZUJlY2F1c2UgPSBmdW5jdGlvbihyZWFzb24sIGNvZGUsIGspIHtcbiAgdGhpcy5zZW5kSW1tZWRpYXRlbHkoZGVmcy5DaGFubmVsQ2xvc2UsIHtcbiAgICByZXBseVRleHQ6IHJlYXNvbixcbiAgICByZXBseUNvZGU6IGNvZGUsXG4gICAgbWV0aG9kSWQ6MCwgY2xhc3NJZDogMFxuICB9KTtcbiAgdmFyIHMgPSBzdGFja0NhcHR1cmUoJ2Nsb3NlQmVjYXVzZSBjYWxsZWQ6ICcgKyByZWFzb24pO1xuICB0aGlzLnRvQ2xvc2luZyhzLCBrKTtcbn07XG5cbi8vIElmIHdlIGNsb3NlIGJlY2F1c2UgdGhlcmUncyBiZWVuIGFuIGVycm9yLCB3ZSBuZWVkIHRvIGRpc3Rpbmd1aXNoXG4vLyBiZXR3ZWVuIHdoYXQgd2UgdGVsbCB0aGUgc2VydmVyIChgcmVhc29uYCkgYW5kIHdoYXQgd2UgcmVwb3J0IGFzXG4vLyB0aGUgY2F1c2UgaW4gdGhlIGNsaWVudCAoYGVycm9yYCkuXG5DLmNsb3NlV2l0aEVycm9yID0gZnVuY3Rpb24ocmVhc29uLCBjb2RlLCBlcnJvcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuY2xvc2VCZWNhdXNlKHJlYXNvbiwgY29kZSwgZnVuY3Rpb24oKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgfSk7XG59O1xuXG4vLyBBIHRyYW1wb2xpbmluZyBzdGF0ZSBtYWNoaW5lIGZvciBtZXNzYWdlIGZyYW1lcyBvbiBhIGNoYW5uZWwuIEFcbi8vIG1lc3NhZ2UgYXJyaXZlcyBpbiBhdCBsZWFzdCB0d28gZnJhbWVzOiBmaXJzdCwgYSBtZXRob2QgYW5ub3VuY2luZ1xuLy8gdGhlIG1lc3NhZ2UgKGVpdGhlciBhIEJhc2ljRGVsaXZlciBvciBCYXNpY0dldE9rKTsgdGhlbiwgYSBtZXNzYWdlXG4vLyBoZWFkZXIgd2l0aCB0aGUgbWVzc2FnZSBwcm9wZXJ0aWVzOyB0aGVuLCB6ZXJvIG9yIG1vcmUgY29udGVudFxuLy8gZnJhbWVzLlxuXG4vLyBLZWVwIHRoZSB0cnkvY2F0Y2ggbG9jYWxpc2VkLCBpbiBhbiBhdHRlbXB0IHRvIGF2b2lkIGRpc2FibGluZ1xuLy8gb3B0aW1pc2F0aW9uXG5DLmFjY2VwdE1lc3NhZ2VGcmFtZSA9IGZ1bmN0aW9uKGYpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmhhbmRsZU1lc3NhZ2UgPSB0aGlzLmhhbmRsZU1lc3NhZ2UoZik7XG4gIH1cbiAgY2F0Y2ggKG1zZykge1xuICAgIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5jbG9zZVdpdGhFcnJvcihtc2csIGRlZnMuY29uc3RhbnRzLlVORVhQRUNURURfRlJBTUUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcihtc2cpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobXNnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IoJ0Vycm9yIHdoaWxlIHByb2Nlc3NpbmcgbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMuY29uc3RhbnRzLklOVEVSTkFMX0VSUk9SLCBtc2cpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IoJ0ludGVybmFsIGVycm9yIHdoaWxlIHByb2Nlc3NpbmcgbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMuY29uc3RhbnRzLklOVEVSTkFMX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IobXNnLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEtpY2sgb2ZmIGEgbWVzc2FnZSBkZWxpdmVyeSBnaXZlbiBhIEJhc2ljRGVsaXZlciBvciBCYXNpY1JldHVyblxuLy8gZnJhbWUgKEJhc2ljR2V0IHVzZXMgdGhlIFJQQyBtZWNoYW5pc20pXG5mdW5jdGlvbiBhY2NlcHREZWxpdmVyeU9yUmV0dXJuKGYpIHtcbiAgdmFyIGV2ZW50O1xuICBpZiAoZi5pZCA9PT0gZGVmcy5CYXNpY0RlbGl2ZXIpIGV2ZW50ID0gJ2RlbGl2ZXJ5JztcbiAgZWxzZSBpZiAoZi5pZCA9PT0gZGVmcy5CYXNpY1JldHVybikgZXZlbnQgPSAncmV0dXJuJztcbiAgZWxzZSB0aHJvdyBmbXQoXCJFeHBlY3RlZCBCYXNpY0RlbGl2ZXIgb3IgQmFzaWNSZXR1cm47IGdvdCAlc1wiLFxuICAgICAgICAgICAgICAgICBpbnNwZWN0KGYpKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBmaWVsZHMgPSBmLmZpZWxkcztcbiAgcmV0dXJuIGFjY2VwdE1lc3NhZ2UoZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIG1lc3NhZ2UuZmllbGRzID0gZmllbGRzO1xuICAgIHNlbGYuZW1pdChldmVudCwgbWVzc2FnZSk7XG4gIH0pO1xufVxuXG4vLyBNb3ZlIHRvIHRoZSBzdGF0ZSBvZiB3YWl0aW5nIGZvciBtZXNzYWdlIGZyYW1lcyAoaGVhZGVycywgdGhlblxuLy8gb25lIG9yIG1vcmUgY29udGVudCBmcmFtZXMpXG5mdW5jdGlvbiBhY2NlcHRNZXNzYWdlKGNvbnRpbnVhdGlvbikge1xuICB2YXIgdG90YWxTaXplID0gMCwgcmVtYWluaW5nID0gMDtcbiAgdmFyIGJ1ZmZlcnMgPSBudWxsO1xuXG4gIHZhciBtZXNzYWdlID0ge1xuICAgIGZpZWxkczogbnVsbCxcbiAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgIGNvbnRlbnQ6IG51bGxcbiAgfTtcblxuICByZXR1cm4gaGVhZGVycztcblxuICAvLyBleHBlY3QgYSBoZWFkZXJzIGZyYW1lXG4gIGZ1bmN0aW9uIGhlYWRlcnMoZikge1xuICAgIGlmIChmLmlkID09PSBkZWZzLkJhc2ljUHJvcGVydGllcykge1xuICAgICAgbWVzc2FnZS5wcm9wZXJ0aWVzID0gZi5maWVsZHM7XG4gICAgICB0b3RhbFNpemUgPSByZW1haW5pbmcgPSBmLnNpemU7XG4gICAgICBcbiAgICAgIC8vIGZvciB6ZXJvLWxlbmd0aCBtZXNzYWdlcywgY29udGVudCBmcmFtZXMgYXJlbid0IHJlcXVpcmVkLlxuICAgICAgaWYgKHRvdGFsU2l6ZSA9PT0gMCkge1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnQgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIGNvbnRpbnVhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGFjY2VwdERlbGl2ZXJ5T3JSZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7ICAgICAgICBcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBcIkV4cGVjdGVkIGhlYWRlcnMgZnJhbWUgYWZ0ZXIgZGVsaXZlcnlcIjtcbiAgICB9XG4gIH1cblxuICAvLyBleHBlY3QgYSBjb250ZW50IGZyYW1lXG4gIC8vICUlJSBUT0RPIGNhbmNlbGxlZCBtZXNzYWdlcyAoc2VudCBhcyB6ZXJvLWxlbmd0aCBjb250ZW50IGZyYW1lKVxuICBmdW5jdGlvbiBjb250ZW50KGYpIHtcbiAgICBpZiAoZi5jb250ZW50KSB7XG4gICAgICB2YXIgc2l6ZSA9IGYuY29udGVudC5sZW5ndGg7XG4gICAgICByZW1haW5pbmcgLT0gc2l6ZTtcbiAgICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgaWYgKGJ1ZmZlcnMgIT09IG51bGwpIHtcbiAgICAgICAgICBidWZmZXJzLnB1c2goZi5jb250ZW50KTtcbiAgICAgICAgICBtZXNzYWdlLmNvbnRlbnQgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2UuY29udGVudCA9IGYuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51YXRpb24obWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBhY2NlcHREZWxpdmVyeU9yUmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocmVtYWluaW5nIDwgMCkge1xuICAgICAgICB0aHJvdyBmbXQoXCJUb28gbXVjaCBjb250ZW50IHNlbnQhIEV4cGVjdGVkICVkIGJ5dGVzXCIsXG4gICAgICAgICAgICAgICAgICB0b3RhbFNpemUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChidWZmZXJzICE9PSBudWxsKVxuICAgICAgICAgIGJ1ZmZlcnMucHVzaChmLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmZmVycyA9IFtmLmNvbnRlbnRdO1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB0aHJvdyBcIkV4cGVjdGVkIGNvbnRlbnQgZnJhbWUgYWZ0ZXIgaGVhZGVyc1wiXG4gIH1cbn1cblxuQy5oYW5kbGVDb25maXJtID0gZnVuY3Rpb24oaGFuZGxlLCBmKSB7XG4gIHZhciB0YWcgPSBmLmRlbGl2ZXJ5VGFnO1xuICB2YXIgbXVsdGkgPSBmLm11bHRpcGxlO1xuXG4gIGlmIChtdWx0aSkge1xuICAgIHZhciBjb25maXJtZWQgPSB0aGlzLnVuY29uZmlybWVkLnNwbGljZSgwLCB0YWcgLSB0aGlzLmx3bSArIDEpO1xuICAgIHRoaXMubHdtID0gdGFnICsgMTtcbiAgICBjb25maXJtZWQuZm9yRWFjaChoYW5kbGUpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBjO1xuICAgIGlmICh0YWcgPT09IHRoaXMubHdtKSB7XG4gICAgICBjID0gdGhpcy51bmNvbmZpcm1lZC5zaGlmdCgpO1xuICAgICAgdGhpcy5sd20rKztcbiAgICAgIC8vIEFkdmFuY2UgdGhlIExXTSBhbmQgdGhlIHdpbmRvdyB0byB0aGUgbmV4dCBub24tZ2FwLCBvclxuICAgICAgLy8gcG9zc2libHkgdG8gdGhlIGVuZFxuICAgICAgd2hpbGUgKHRoaXMudW5jb25maXJtZWRbMF0gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy51bmNvbmZpcm1lZC5zaGlmdCgpO1xuICAgICAgICB0aGlzLmx3bSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGMgPSB0aGlzLnVuY29uZmlybWVkW3RhZyAtIHRoaXMubHdtXTtcbiAgICAgIHRoaXMudW5jb25maXJtZWRbdGFnIC0gdGhpcy5sd21dID0gbnVsbDtcbiAgICB9XG4gICAgLy8gVGVjaG5pY2FsbHksIGluIHRoZSBzaW5nbGUtZGVsaXZlcnlUYWcgY2FzZSwgSSBzaG91bGQgcmVwb3J0IGFcbiAgICAvLyBwcm90b2NvbCBicmVhY2ggaWYgaXQncyBhbHJlYWR5IGJlZW4gY29uZmlybWVkLlxuICAgIGhhbmRsZShjKTtcbiAgfVxufTtcblxuQy5wdXNoQ29uZmlybUNhbGxiYWNrID0gZnVuY3Rpb24oY2IpIHtcbiAgLy8gYG51bGxgIGlzIHVzZWQgc3BlY2lmaWNhbGx5IGZvciBtYXJraW5nIGFscmVhZHkgY29uZmlybWVkIHNsb3RzLFxuICAvLyBzbyBJIGNvZXJjZSBgdW5kZWZpbmVkYCBhbmQgYG51bGxgIHRvIGZhbHNlOyBmdW5jdGlvbnMgYXJlIG5ldmVyXG4gIC8vIGZhbHNleS5cbiAgdGhpcy51bmNvbmZpcm1lZC5wdXNoKGNiIHx8IGZhbHNlKTtcbn07XG5cbi8vIEludGVyZmFjZSBmb3IgY29ubmVjdGlvbiB0byB1c2VcblxuQy5hY2NlcHQgPSBmdW5jdGlvbihmKSB7XG5cbiAgc3dpdGNoIChmLmlkKSB7XG5cbiAgICAvLyBNZXNzYWdlIGZyYW1lc1xuICBjYXNlIHVuZGVmaW5lZDogLy8gY29udGVudCBmcmFtZSFcbiAgY2FzZSBkZWZzLkJhc2ljRGVsaXZlcjpcbiAgY2FzZSBkZWZzLkJhc2ljUmV0dXJuOlxuICBjYXNlIGRlZnMuQmFzaWNQcm9wZXJ0aWVzOlxuICAgIHJldHVybiB0aGlzLmFjY2VwdE1lc3NhZ2VGcmFtZShmKTtcblxuICAgIC8vIGNvbmZpcm1hdGlvbnMsIG5lZWQgdG8gZG8gY29uZmlybS5zZWxlY3QgZmlyc3RcbiAgY2FzZSBkZWZzLkJhc2ljQWNrOlxuICAgIHJldHVybiB0aGlzLmVtaXQoJ2FjaycsIGYuZmllbGRzKTtcbiAgY2FzZSBkZWZzLkJhc2ljTmFjazpcbiAgICByZXR1cm4gdGhpcy5lbWl0KCduYWNrJywgZi5maWVsZHMpO1xuICBjYXNlIGRlZnMuQmFzaWNDYW5jZWw6XG4gICAgLy8gVGhlIGJyb2tlciBjYW4gc2VuZCB0aGlzIGlmIGUuZy4sIHRoZSBxdWV1ZSBpcyBkZWxldGVkLlxuICAgIHJldHVybiB0aGlzLmVtaXQoJ2NhbmNlbCcsIGYuZmllbGRzKTtcblxuICBjYXNlIGRlZnMuQ2hhbm5lbENsb3NlOlxuICAgIC8vIEFueSByZW1vdGUgY2xvc3VyZSBpcyBhbiBlcnJvciB0byB1cy4gUmVqZWN0IHRoZSBwZW5kaW5nIHJlcGx5XG4gICAgLy8gd2l0aCB0aGUgY2xvc2UgZnJhbWUsIHNvIGl0IGNhbiBzZWUgd2hldGhlciBpdCB3YXMgdGhhdFxuICAgIC8vIG9wZXJhdGlvbiB0aGF0IGNhdXNlZCBpdCB0byBjbG9zZS5cbiAgICBpZiAodGhpcy5yZXBseSkge1xuICAgICAgdmFyIHJlcGx5ID0gdGhpcy5yZXBseTsgdGhpcy5yZXBseSA9IG51bGw7XG4gICAgICByZXBseShmKTtcbiAgICB9XG4gICAgdmFyIGVtc2cgPSBcIkNoYW5uZWwgY2xvc2VkIGJ5IHNlcnZlcjogXCIgKyBjbG9zZU1zZyhmKTtcbiAgICB0aGlzLnNlbmRJbW1lZGlhdGVseShkZWZzLkNoYW5uZWxDbG9zZU9rLCB7fSk7XG5cbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZW1zZyk7XG4gICAgZXJyb3IuY29kZSA9IGYuZmllbGRzLnJlcGx5Q29kZTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXG4gICAgdmFyIHMgPSBzdGFja0NhcHR1cmUoZW1zZyk7XG4gICAgdGhpcy50b0Nsb3NlZChzKTtcbiAgICByZXR1cm47XG5cbiAgY2FzZSBkZWZzLkJhc2ljRmxvdzpcbiAgICAvLyBSYWJiaXRNUSBkb2Vzbid0IHNlbmQgdGhpcywgaXQganVzdCBibG9ja3MgdGhlIFRDUCBzb2NrZXRcbiAgICByZXR1cm4gdGhpcy5jbG9zZVdpdGhFcnJvcihcIkZsb3cgbm90IGltcGxlbWVudGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmcy5jb25zdGFudHMuTk9UX0lNUExFTUVOVEVELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcignRmxvdyBub3QgaW1wbGVtZW50ZWQnKSk7XG5cbiAgZGVmYXVsdDogLy8gYXNzdW1lIGFsbCBvdGhlciB0aGluZ3MgYXJlIHJlcGxpZXNcbiAgICAvLyBSZXNvbHZpbmcgdGhlIHJlcGx5IG1heSBsZWFkIHRvIGFub3RoZXIgUlBDOyB0byBtYWtlIHN1cmUgd2VcbiAgICAvLyBkb24ndCBob2xkIHRoYXQgdXAsIGNsZWFyIHRoaXMucmVwbHlcbiAgICB2YXIgcmVwbHkgPSB0aGlzLnJlcGx5OyB0aGlzLnJlcGx5ID0gbnVsbDtcbiAgICAvLyBob3dldmVyLCBtYXliZSB0aGVyZSdzIGFuIFJQQyB3YWl0aW5nIHRvIGdvPyBJZiBzbywgdGhhdCdsbFxuICAgIC8vIGZpbGwgdGhpcy5yZXBseSBhZ2FpbiwgcmVzdG9yaW5nIHRoZSBpbnZhcmlhbnQuIFRoaXMgZG9lcyByZWx5XG4gICAgLy8gb24gYW55IHJlc3BvbnNlIGJlaW5nIHJlY3YnZWQgYWZ0ZXIgcmVzb2x2aW5nIHRoZSBwcm9taXNlLFxuICAgIC8vIGJlbG93OyBoZW5jZSwgSSB1c2Ugc3luY2hyb25vdXMgZGVmZXIuXG4gICAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgc2VuZCA9IHRoaXMucGVuZGluZy5zaGlmdCgpO1xuICAgICAgdGhpcy5yZXBseSA9IHNlbmQucmVwbHk7XG4gICAgICB0aGlzLnNlbmRJbW1lZGlhdGVseShzZW5kLm1ldGhvZCwgc2VuZC5maWVsZHMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbHkobnVsbCwgZik7XG4gIH1cbn07XG5cbkMub25CdWZmZXJEcmFpbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2RyYWluJyk7XG59O1xuXG5cbi8vIFRoaXMgYWRkcyBqdXN0IGEgYml0IG1vcmUgc3R1ZmYgdXNlZnVsIGZvciB0aGUgQVBJcywgYnV0IG5vdFxuLy8gbG93LWxldmVsIG1hY2hpbmVyeS5cbmZ1bmN0aW9uIEJhc2VDaGFubmVsKGNvbm5lY3Rpb24pIHtcbiAgQ2hhbm5lbC5jYWxsKHRoaXMsIGNvbm5lY3Rpb24pO1xuICB0aGlzLmNvbnN1bWVycyA9IHt9O1xufVxuaW5oZXJpdHMoQmFzZUNoYW5uZWwsIENoYW5uZWwpO1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNlQ2hhbm5lbCA9IEJhc2VDaGFubmVsO1xuXG4vLyBOb3Qgc3VyZSBJIGxpa2UgdGhlIGZmLCBpdCdzIGdvaW5nIHRvIGJlIGNoYW5naW5nIGhpZGRlbiBjbGFzc2VzXG4vLyBhbGwgb3ZlciB0aGUgcGxhY2UuIE9uIHRoZSBvdGhlciBoYW5kLCB3aGFkZHlhIGRvLlxuQmFzZUNoYW5uZWwucHJvdG90eXBlLnJlZ2lzdGVyQ29uc3VtZXIgPSBmdW5jdGlvbih0YWcsIGNhbGxiYWNrKSB7XG4gIHRoaXMuY29uc3VtZXJzW3RhZ10gPSBjYWxsYmFjaztcbn07XG5cbkJhc2VDaGFubmVsLnByb3RvdHlwZS51bnJlZ2lzdGVyQ29uc3VtZXIgPSBmdW5jdGlvbih0YWcpIHtcbiAgZGVsZXRlIHRoaXMuY29uc3VtZXJzW3RhZ107XG59O1xuXG5CYXNlQ2hhbm5lbC5wcm90b3R5cGUuZGlzcGF0Y2hNZXNzYWdlID0gZnVuY3Rpb24oZmllbGRzLCBtZXNzYWdlKSB7XG4gIHZhciBjb25zdW1lclRhZyA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgdmFyIGNvbnN1bWVyID0gdGhpcy5jb25zdW1lcnNbY29uc3VtZXJUYWddO1xuICBpZiAoY29uc3VtZXIpIHtcbiAgICByZXR1cm4gY29uc3VtZXIobWVzc2FnZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gJSUlIFN1cmVseSBhIHJhY2UgaGVyZVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29uc3VtZXI6IFwiICsgY29uc3VtZXJUYWcpO1xuICB9XG59O1xuXG5CYXNlQ2hhbm5lbC5wcm90b3R5cGUuaGFuZGxlRGVsaXZlcnkgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIHJldHVybiB0aGlzLmRpc3BhdGNoTWVzc2FnZShtZXNzYWdlLmZpZWxkcywgbWVzc2FnZSk7XG59O1xuXG5CYXNlQ2hhbm5lbC5wcm90b3R5cGUuaGFuZGxlQ2FuY2VsID0gZnVuY3Rpb24oZmllbGRzKSB7XG4gIHJldHVybiB0aGlzLmRpc3BhdGNoTWVzc2FnZShmaWVsZHMsIG51bGwpO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/channel.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/channel_model.js":
/*!***************************************************!*\
  !*** ./node_modules/amqplib/lib/channel_model.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//\n//\n//\n\n\n\nvar defs = __webpack_require__(/*! ./defs */ \"./node_modules/amqplib/lib/defs.js\");\nvar Promise = __webpack_require__(/*! bluebird */ \"./node_modules/bluebird/js/release/bluebird.js\");\nvar inherits = __webpack_require__(/*! util */ \"util\").inherits;\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar BaseChannel = __webpack_require__(/*! ./channel */ \"./node_modules/amqplib/lib/channel.js\").BaseChannel;\nvar acceptMessage = __webpack_require__(/*! ./channel */ \"./node_modules/amqplib/lib/channel.js\").acceptMessage;\nvar Args = __webpack_require__(/*! ./api_args */ \"./node_modules/amqplib/lib/api_args.js\");\n\nfunction ChannelModel(connection) {\n  if (!(this instanceof ChannelModel))\n    return new ChannelModel(connection);\n  EventEmitter.call( this );\n  this.connection = connection;\n  var self = this;\n  ['error', 'close', 'blocked', 'unblocked'].forEach(function(ev) {\n    connection.on(ev, self.emit.bind(self, ev));\n  });\n}\ninherits(ChannelModel, EventEmitter);\n\nmodule.exports.ChannelModel = ChannelModel;\n\nvar CM = ChannelModel.prototype;\n\nCM.close = function() {\n  return Promise.fromCallback(this.connection.close.bind(this.connection));\n};\n\n// Channels\n\nfunction Channel(connection) {\n  BaseChannel.call(this, connection);\n  this.on('delivery', this.handleDelivery.bind(this));\n  this.on('cancel', this.handleCancel.bind(this));\n}\ninherits(Channel, BaseChannel);\n\nmodule.exports.Channel = Channel;\n\nCM.createChannel = function() {\n  var c = new Channel(this.connection);\n  return c.open().then(function(openOk) { return c; });\n};\n\nvar C = Channel.prototype;\n\n// An RPC that returns a 'proper' promise, which resolves to just the\n// response's fields; this is intended to be suitable for implementing\n// API procedures.\nC.rpc = function(method, fields, expect) {\n  var self = this;\n  return Promise.fromCallback(function(cb) {\n    return self._rpc(method, fields, expect, cb);\n  })\n  .then(function(f) {\n    return f.fields;\n  });\n};\n\n// Do the remarkably simple channel open handshake\nC.open = function() {\n  return Promise.try(this.allocate.bind(this)).then(\n    function(ch) {\n      return ch.rpc(defs.ChannelOpen, {outOfBand: \"\"},\n                    defs.ChannelOpenOk);\n    });\n};\n\nC.close = function() {\n  var self = this;\n  return Promise.fromCallback(function(cb) {\n    return self.closeBecause(\"Goodbye\", defs.constants.REPLY_SUCCESS,\n                    cb);\n  });\n};\n\n// === Public API, declaring queues and stuff ===\n\nC.assertQueue = function(queue, options) {\n  return this.rpc(defs.QueueDeclare,\n                  Args.assertQueue(queue, options),\n                  defs.QueueDeclareOk);\n};\n\nC.checkQueue = function(queue) {\n  return this.rpc(defs.QueueDeclare,\n                  Args.checkQueue(queue),\n                  defs.QueueDeclareOk);\n};\n\nC.deleteQueue = function(queue, options) {\n  return this.rpc(defs.QueueDelete,\n                  Args.deleteQueue(queue, options),\n                  defs.QueueDeleteOk);\n};\n\nC.purgeQueue = function(queue) {\n  return this.rpc(defs.QueuePurge,\n                  Args.purgeQueue(queue),\n                  defs.QueuePurgeOk);\n};\n\nC.bindQueue = function(queue, source, pattern, argt) {\n  return this.rpc(defs.QueueBind,\n                  Args.bindQueue(queue, source, pattern, argt),\n                  defs.QueueBindOk);\n};\n\nC.unbindQueue = function(queue, source, pattern, argt) {\n  return this.rpc(defs.QueueUnbind,\n                  Args.unbindQueue(queue, source, pattern, argt),\n                  defs.QueueUnbindOk);\n};\n\nC.assertExchange = function(exchange, type, options) {\n  // The server reply is an empty set of fields, but it's convenient\n  // to have the exchange name handed to the continuation.\n  return this.rpc(defs.ExchangeDeclare,\n                  Args.assertExchange(exchange, type, options),\n                  defs.ExchangeDeclareOk)\n    .then(function(_ok) { return { exchange: exchange }; });\n};\n\nC.checkExchange = function(exchange) {\n  return this.rpc(defs.ExchangeDeclare,\n                  Args.checkExchange(exchange),\n                  defs.ExchangeDeclareOk);\n};\n\nC.deleteExchange = function(name, options) {\n  return this.rpc(defs.ExchangeDelete,\n                  Args.deleteExchange(name, options),\n                  defs.ExchangeDeleteOk);\n};\n\nC.bindExchange = function(dest, source, pattern, argt) {\n  return this.rpc(defs.ExchangeBind,\n                  Args.bindExchange(dest, source, pattern, argt),\n                  defs.ExchangeBindOk);\n};\n\nC.unbindExchange = function(dest, source, pattern, argt) {\n  return this.rpc(defs.ExchangeUnbind,\n                  Args.unbindExchange(dest, source, pattern, argt),\n                  defs.ExchangeUnbindOk);\n};\n\n// Working with messages\n\nC.publish = function(exchange, routingKey, content, options) {\n  var fieldsAndProps = Args.publish(exchange, routingKey, options);\n  return this.sendMessage(fieldsAndProps, fieldsAndProps, content);\n};\n\nC.sendToQueue = function(queue, content, options) {\n  return this.publish('', queue, content, options);\n};\n\nC.consume = function(queue, callback, options) {\n  var self = this;\n  // NB we want the callback to be run synchronously, so that we've\n  // registered the consumerTag before any messages can arrive.\n  var fields = Args.consume(queue, options);\n  return Promise.fromCallback(function(cb) {\n    self._rpc(defs.BasicConsume, fields, defs.BasicConsumeOk, cb);\n  })\n  .then(function(ok) {\n    self.registerConsumer(ok.fields.consumerTag, callback);\n    return ok.fields;\n  });\n};\n\nC.cancel = function(consumerTag) {\n  var self = this;\n  return Promise.fromCallback(function(cb) {\n    self._rpc(defs.BasicCancel, Args.cancel(consumerTag),\n          defs.BasicCancelOk,\n          cb);\n  })\n  .then(function(ok) {\n    self.unregisterConsumer(consumerTag);\n    return ok.fields;\n  });\n};\n\nC.get = function(queue, options) {\n  var self = this;\n  var fields = Args.get(queue, options);\n  return Promise.fromCallback(function(cb) {\n    return self.sendOrEnqueue(defs.BasicGet, fields, cb);\n  })\n  .then(function(f) {\n    if (f.id === defs.BasicGetEmpty) {\n      return false;\n    }\n    else if (f.id === defs.BasicGetOk) {\n      var fields = f.fields;\n      return new Promise(function(resolve) {\n        self.handleMessage = acceptMessage(function(m) {\n          m.fields = fields;\n          resolve(m);\n        });\n      });\n    }\n    else {\n      throw new Error(\"Unexpected response to BasicGet: \" +\n                             inspect(f));\n    }\n  })\n};\n\nC.ack = function(message, allUpTo) {\n  this.sendImmediately(\n    defs.BasicAck,\n    Args.ack(message.fields.deliveryTag, allUpTo));\n};\n\nC.ackAll = function() {\n  this.sendImmediately(defs.BasicAck, Args.ack(0, true));\n};\n\nC.nack = function(message, allUpTo, requeue) {\n  this.sendImmediately(\n    defs.BasicNack,\n    Args.nack(message.fields.deliveryTag, allUpTo, requeue));\n};\n\nC.nackAll = function(requeue) {\n  this.sendImmediately(defs.BasicNack,\n                       Args.nack(0, true, requeue));\n};\n\n// `Basic.Nack` is not available in older RabbitMQ versions (or in the\n// AMQP specification), so you have to use the one-at-a-time\n// `Basic.Reject`. This is otherwise synonymous with\n// `#nack(message, false, requeue)`.\nC.reject = function(message, requeue) {\n  this.sendImmediately(\n    defs.BasicReject,\n    Args.reject(message.fields.deliveryTag, requeue));\n};\n\n// There are more options in AMQP than exposed here; RabbitMQ only\n// implements prefetch based on message count, and only for individual\n// channels or consumers. RabbitMQ v3.3.0 and after treat prefetch\n// (without `global` set) as per-consumer (for consumers following),\n// and prefetch with `global` set as per-channel.\nC.prefetch = C.qos = function(count, global) {\n  return this.rpc(defs.BasicQos,\n                  Args.prefetch(count, global),\n                  defs.BasicQosOk);\n};\n\nC.recover = function() {\n  return this.rpc(defs.BasicRecover,\n                  Args.recover(),\n                  defs.BasicRecoverOk);\n};\n\n// Confirm channel. This is a channel with confirms 'switched on',\n// meaning sent messages will provoke a responding 'ack' or 'nack'\n// from the server. The upshot of this is that `publish` and\n// `sendToQueue` both take a callback, which will be called either\n// with `null` as its argument to signify 'ack', or an exception as\n// its argument to signify 'nack'.\n\nfunction ConfirmChannel(connection) {\n  Channel.call(this, connection);\n}\ninherits(ConfirmChannel, Channel);\n\nmodule.exports.ConfirmChannel = ConfirmChannel;\n\nCM.createConfirmChannel = function() {\n  var c = new ConfirmChannel(this.connection);\n  return c.open()\n    .then(function(openOk) {\n      return c.rpc(defs.ConfirmSelect, {nowait: false},\n                   defs.ConfirmSelectOk)\n    })\n    .then(function() { return c; });\n};\n\nvar CC = ConfirmChannel.prototype;\n\nCC.publish = function(exchange, routingKey, content, options, cb) {\n  this.pushConfirmCallback(cb);\n  return C.publish.call(this, exchange, routingKey, content, options);\n};\n\nCC.sendToQueue = function(queue, content, options, cb) {\n  return this.publish('', queue, content, options, cb);\n};\n\nCC.waitForConfirms = function() {\n  var awaiting = [];\n  var unconfirmed = this.unconfirmed;\n  unconfirmed.forEach(function(val, index) {\n    if (val === null); // already confirmed\n    else {\n      var confirmed = new Promise(function(resolve, reject) {\n        unconfirmed[index] = function(err) {\n          if (val) val(err);\n          if (err === null) resolve();\n          else reject(err);\n        };\n      });\n      awaiting.push(confirmed);\n    }\n  });\n  return Promise.all(awaiting);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY2hhbm5lbF9tb2RlbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9jaGFubmVsX21vZGVsLmpzPzZiYTkiXSwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vXG4vL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZzID0gcmVxdWlyZSgnLi9kZWZzJyk7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIEJhc2VDaGFubmVsID0gcmVxdWlyZSgnLi9jaGFubmVsJykuQmFzZUNoYW5uZWw7XG52YXIgYWNjZXB0TWVzc2FnZSA9IHJlcXVpcmUoJy4vY2hhbm5lbCcpLmFjY2VwdE1lc3NhZ2U7XG52YXIgQXJncyA9IHJlcXVpcmUoJy4vYXBpX2FyZ3MnKTtcblxuZnVuY3Rpb24gQ2hhbm5lbE1vZGVsKGNvbm5lY3Rpb24pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENoYW5uZWxNb2RlbCkpXG4gICAgcmV0dXJuIG5ldyBDaGFubmVsTW9kZWwoY29ubmVjdGlvbik7XG4gIEV2ZW50RW1pdHRlci5jYWxsKCB0aGlzICk7XG4gIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gIHZhciBzZWxmID0gdGhpcztcbiAgWydlcnJvcicsICdjbG9zZScsICdibG9ja2VkJywgJ3VuYmxvY2tlZCddLmZvckVhY2goZnVuY3Rpb24oZXYpIHtcbiAgICBjb25uZWN0aW9uLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcbn1cbmluaGVyaXRzKENoYW5uZWxNb2RlbCwgRXZlbnRFbWl0dGVyKTtcblxubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbE1vZGVsID0gQ2hhbm5lbE1vZGVsO1xuXG52YXIgQ00gPSBDaGFubmVsTW9kZWwucHJvdG90eXBlO1xuXG5DTS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gUHJvbWlzZS5mcm9tQ2FsbGJhY2sodGhpcy5jb25uZWN0aW9uLmNsb3NlLmJpbmQodGhpcy5jb25uZWN0aW9uKSk7XG59O1xuXG4vLyBDaGFubmVsc1xuXG5mdW5jdGlvbiBDaGFubmVsKGNvbm5lY3Rpb24pIHtcbiAgQmFzZUNoYW5uZWwuY2FsbCh0aGlzLCBjb25uZWN0aW9uKTtcbiAgdGhpcy5vbignZGVsaXZlcnknLCB0aGlzLmhhbmRsZURlbGl2ZXJ5LmJpbmQodGhpcykpO1xuICB0aGlzLm9uKCdjYW5jZWwnLCB0aGlzLmhhbmRsZUNhbmNlbC5iaW5kKHRoaXMpKTtcbn1cbmluaGVyaXRzKENoYW5uZWwsIEJhc2VDaGFubmVsKTtcblxubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbCA9IENoYW5uZWw7XG5cbkNNLmNyZWF0ZUNoYW5uZWwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGMgPSBuZXcgQ2hhbm5lbCh0aGlzLmNvbm5lY3Rpb24pO1xuICByZXR1cm4gYy5vcGVuKCkudGhlbihmdW5jdGlvbihvcGVuT2spIHsgcmV0dXJuIGM7IH0pO1xufTtcblxudmFyIEMgPSBDaGFubmVsLnByb3RvdHlwZTtcblxuLy8gQW4gUlBDIHRoYXQgcmV0dXJucyBhICdwcm9wZXInIHByb21pc2UsIHdoaWNoIHJlc29sdmVzIHRvIGp1c3QgdGhlXG4vLyByZXNwb25zZSdzIGZpZWxkczsgdGhpcyBpcyBpbnRlbmRlZCB0byBiZSBzdWl0YWJsZSBmb3IgaW1wbGVtZW50aW5nXG4vLyBBUEkgcHJvY2VkdXJlcy5cbkMucnBjID0gZnVuY3Rpb24obWV0aG9kLCBmaWVsZHMsIGV4cGVjdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBQcm9taXNlLmZyb21DYWxsYmFjayhmdW5jdGlvbihjYikge1xuICAgIHJldHVybiBzZWxmLl9ycGMobWV0aG9kLCBmaWVsZHMsIGV4cGVjdCwgY2IpO1xuICB9KVxuICAudGhlbihmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIGYuZmllbGRzO1xuICB9KTtcbn07XG5cbi8vIERvIHRoZSByZW1hcmthYmx5IHNpbXBsZSBjaGFubmVsIG9wZW4gaGFuZHNoYWtlXG5DLm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFByb21pc2UudHJ5KHRoaXMuYWxsb2NhdGUuYmluZCh0aGlzKSkudGhlbihcbiAgICBmdW5jdGlvbihjaCkge1xuICAgICAgcmV0dXJuIGNoLnJwYyhkZWZzLkNoYW5uZWxPcGVuLCB7b3V0T2ZCYW5kOiBcIlwifSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5DaGFubmVsT3Blbk9rKTtcbiAgICB9KTtcbn07XG5cbkMuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gUHJvbWlzZS5mcm9tQ2FsbGJhY2soZnVuY3Rpb24oY2IpIHtcbiAgICByZXR1cm4gc2VsZi5jbG9zZUJlY2F1c2UoXCJHb29kYnllXCIsIGRlZnMuY29uc3RhbnRzLlJFUExZX1NVQ0NFU1MsXG4gICAgICAgICAgICAgICAgICAgIGNiKTtcbiAgfSk7XG59O1xuXG4vLyA9PT0gUHVibGljIEFQSSwgZGVjbGFyaW5nIHF1ZXVlcyBhbmQgc3R1ZmYgPT09XG5cbkMuYXNzZXJ0UXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5ycGMoZGVmcy5RdWV1ZURlY2xhcmUsXG4gICAgICAgICAgICAgICAgICBBcmdzLmFzc2VydFF1ZXVlKHF1ZXVlLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgIGRlZnMuUXVldWVEZWNsYXJlT2spO1xufTtcblxuQy5jaGVja1F1ZXVlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgcmV0dXJuIHRoaXMucnBjKGRlZnMuUXVldWVEZWNsYXJlLFxuICAgICAgICAgICAgICAgICAgQXJncy5jaGVja1F1ZXVlKHF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgIGRlZnMuUXVldWVEZWNsYXJlT2spO1xufTtcblxuQy5kZWxldGVRdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLnJwYyhkZWZzLlF1ZXVlRGVsZXRlLFxuICAgICAgICAgICAgICAgICAgQXJncy5kZWxldGVRdWV1ZShxdWV1ZSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICBkZWZzLlF1ZXVlRGVsZXRlT2spO1xufTtcblxuQy5wdXJnZVF1ZXVlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgcmV0dXJuIHRoaXMucnBjKGRlZnMuUXVldWVQdXJnZSxcbiAgICAgICAgICAgICAgICAgIEFyZ3MucHVyZ2VRdWV1ZShxdWV1ZSksXG4gICAgICAgICAgICAgICAgICBkZWZzLlF1ZXVlUHVyZ2VPayk7XG59O1xuXG5DLmJpbmRRdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QpIHtcbiAgcmV0dXJuIHRoaXMucnBjKGRlZnMuUXVldWVCaW5kLFxuICAgICAgICAgICAgICAgICAgQXJncy5iaW5kUXVldWUocXVldWUsIHNvdXJjZSwgcGF0dGVybiwgYXJndCksXG4gICAgICAgICAgICAgICAgICBkZWZzLlF1ZXVlQmluZE9rKTtcbn07XG5cbkMudW5iaW5kUXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gIHJldHVybiB0aGlzLnJwYyhkZWZzLlF1ZXVlVW5iaW5kLFxuICAgICAgICAgICAgICAgICAgQXJncy51bmJpbmRRdWV1ZShxdWV1ZSwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSxcbiAgICAgICAgICAgICAgICAgIGRlZnMuUXVldWVVbmJpbmRPayk7XG59O1xuXG5DLmFzc2VydEV4Y2hhbmdlID0gZnVuY3Rpb24oZXhjaGFuZ2UsIHR5cGUsIG9wdGlvbnMpIHtcbiAgLy8gVGhlIHNlcnZlciByZXBseSBpcyBhbiBlbXB0eSBzZXQgb2YgZmllbGRzLCBidXQgaXQncyBjb252ZW5pZW50XG4gIC8vIHRvIGhhdmUgdGhlIGV4Y2hhbmdlIG5hbWUgaGFuZGVkIHRvIHRoZSBjb250aW51YXRpb24uXG4gIHJldHVybiB0aGlzLnJwYyhkZWZzLkV4Y2hhbmdlRGVjbGFyZSxcbiAgICAgICAgICAgICAgICAgIEFyZ3MuYXNzZXJ0RXhjaGFuZ2UoZXhjaGFuZ2UsIHR5cGUsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgZGVmcy5FeGNoYW5nZURlY2xhcmVPaylcbiAgICAudGhlbihmdW5jdGlvbihfb2spIHsgcmV0dXJuIHsgZXhjaGFuZ2U6IGV4Y2hhbmdlIH07IH0pO1xufTtcblxuQy5jaGVja0V4Y2hhbmdlID0gZnVuY3Rpb24oZXhjaGFuZ2UpIHtcbiAgcmV0dXJuIHRoaXMucnBjKGRlZnMuRXhjaGFuZ2VEZWNsYXJlLFxuICAgICAgICAgICAgICAgICAgQXJncy5jaGVja0V4Y2hhbmdlKGV4Y2hhbmdlKSxcbiAgICAgICAgICAgICAgICAgIGRlZnMuRXhjaGFuZ2VEZWNsYXJlT2spO1xufTtcblxuQy5kZWxldGVFeGNoYW5nZSA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMucnBjKGRlZnMuRXhjaGFuZ2VEZWxldGUsXG4gICAgICAgICAgICAgICAgICBBcmdzLmRlbGV0ZUV4Y2hhbmdlKG5hbWUsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgZGVmcy5FeGNoYW5nZURlbGV0ZU9rKTtcbn07XG5cbkMuYmluZEV4Y2hhbmdlID0gZnVuY3Rpb24oZGVzdCwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gIHJldHVybiB0aGlzLnJwYyhkZWZzLkV4Y2hhbmdlQmluZCxcbiAgICAgICAgICAgICAgICAgIEFyZ3MuYmluZEV4Y2hhbmdlKGRlc3QsIHNvdXJjZSwgcGF0dGVybiwgYXJndCksXG4gICAgICAgICAgICAgICAgICBkZWZzLkV4Y2hhbmdlQmluZE9rKTtcbn07XG5cbkMudW5iaW5kRXhjaGFuZ2UgPSBmdW5jdGlvbihkZXN0LCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QpIHtcbiAgcmV0dXJuIHRoaXMucnBjKGRlZnMuRXhjaGFuZ2VVbmJpbmQsXG4gICAgICAgICAgICAgICAgICBBcmdzLnVuYmluZEV4Y2hhbmdlKGRlc3QsIHNvdXJjZSwgcGF0dGVybiwgYXJndCksXG4gICAgICAgICAgICAgICAgICBkZWZzLkV4Y2hhbmdlVW5iaW5kT2spO1xufTtcblxuLy8gV29ya2luZyB3aXRoIG1lc3NhZ2VzXG5cbkMucHVibGlzaCA9IGZ1bmN0aW9uKGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjb250ZW50LCBvcHRpb25zKSB7XG4gIHZhciBmaWVsZHNBbmRQcm9wcyA9IEFyZ3MucHVibGlzaChleGNoYW5nZSwgcm91dGluZ0tleSwgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlKGZpZWxkc0FuZFByb3BzLCBmaWVsZHNBbmRQcm9wcywgY29udGVudCk7XG59O1xuXG5DLnNlbmRUb1F1ZXVlID0gZnVuY3Rpb24ocXVldWUsIGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMucHVibGlzaCgnJywgcXVldWUsIGNvbnRlbnQsIG9wdGlvbnMpO1xufTtcblxuQy5jb25zdW1lID0gZnVuY3Rpb24ocXVldWUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgLy8gTkIgd2Ugd2FudCB0aGUgY2FsbGJhY2sgdG8gYmUgcnVuIHN5bmNocm9ub3VzbHksIHNvIHRoYXQgd2UndmVcbiAgLy8gcmVnaXN0ZXJlZCB0aGUgY29uc3VtZXJUYWcgYmVmb3JlIGFueSBtZXNzYWdlcyBjYW4gYXJyaXZlLlxuICB2YXIgZmllbGRzID0gQXJncy5jb25zdW1lKHF1ZXVlLCBvcHRpb25zKTtcbiAgcmV0dXJuIFByb21pc2UuZnJvbUNhbGxiYWNrKGZ1bmN0aW9uKGNiKSB7XG4gICAgc2VsZi5fcnBjKGRlZnMuQmFzaWNDb25zdW1lLCBmaWVsZHMsIGRlZnMuQmFzaWNDb25zdW1lT2ssIGNiKTtcbiAgfSlcbiAgLnRoZW4oZnVuY3Rpb24ob2spIHtcbiAgICBzZWxmLnJlZ2lzdGVyQ29uc3VtZXIob2suZmllbGRzLmNvbnN1bWVyVGFnLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIG9rLmZpZWxkcztcbiAgfSk7XG59O1xuXG5DLmNhbmNlbCA9IGZ1bmN0aW9uKGNvbnN1bWVyVGFnKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIFByb21pc2UuZnJvbUNhbGxiYWNrKGZ1bmN0aW9uKGNiKSB7XG4gICAgc2VsZi5fcnBjKGRlZnMuQmFzaWNDYW5jZWwsIEFyZ3MuY2FuY2VsKGNvbnN1bWVyVGFnKSxcbiAgICAgICAgICBkZWZzLkJhc2ljQ2FuY2VsT2ssXG4gICAgICAgICAgY2IpO1xuICB9KVxuICAudGhlbihmdW5jdGlvbihvaykge1xuICAgIHNlbGYudW5yZWdpc3RlckNvbnN1bWVyKGNvbnN1bWVyVGFnKTtcbiAgICByZXR1cm4gb2suZmllbGRzO1xuICB9KTtcbn07XG5cbkMuZ2V0ID0gZnVuY3Rpb24ocXVldWUsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZmllbGRzID0gQXJncy5nZXQocXVldWUsIG9wdGlvbnMpO1xuICByZXR1cm4gUHJvbWlzZS5mcm9tQ2FsbGJhY2soZnVuY3Rpb24oY2IpIHtcbiAgICByZXR1cm4gc2VsZi5zZW5kT3JFbnF1ZXVlKGRlZnMuQmFzaWNHZXQsIGZpZWxkcywgY2IpO1xuICB9KVxuICAudGhlbihmdW5jdGlvbihmKSB7XG4gICAgaWYgKGYuaWQgPT09IGRlZnMuQmFzaWNHZXRFbXB0eSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkJhc2ljR2V0T2spIHtcbiAgICAgIHZhciBmaWVsZHMgPSBmLmZpZWxkcztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlTWVzc2FnZSA9IGFjY2VwdE1lc3NhZ2UoZnVuY3Rpb24obSkge1xuICAgICAgICAgIG0uZmllbGRzID0gZmllbGRzO1xuICAgICAgICAgIHJlc29sdmUobSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCByZXNwb25zZSB0byBCYXNpY0dldDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNwZWN0KGYpKTtcbiAgICB9XG4gIH0pXG59O1xuXG5DLmFjayA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGFsbFVwVG8pIHtcbiAgdGhpcy5zZW5kSW1tZWRpYXRlbHkoXG4gICAgZGVmcy5CYXNpY0FjayxcbiAgICBBcmdzLmFjayhtZXNzYWdlLmZpZWxkcy5kZWxpdmVyeVRhZywgYWxsVXBUbykpO1xufTtcblxuQy5hY2tBbGwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zZW5kSW1tZWRpYXRlbHkoZGVmcy5CYXNpY0FjaywgQXJncy5hY2soMCwgdHJ1ZSkpO1xufTtcblxuQy5uYWNrID0gZnVuY3Rpb24obWVzc2FnZSwgYWxsVXBUbywgcmVxdWV1ZSkge1xuICB0aGlzLnNlbmRJbW1lZGlhdGVseShcbiAgICBkZWZzLkJhc2ljTmFjayxcbiAgICBBcmdzLm5hY2sobWVzc2FnZS5maWVsZHMuZGVsaXZlcnlUYWcsIGFsbFVwVG8sIHJlcXVldWUpKTtcbn07XG5cbkMubmFja0FsbCA9IGZ1bmN0aW9uKHJlcXVldWUpIHtcbiAgdGhpcy5zZW5kSW1tZWRpYXRlbHkoZGVmcy5CYXNpY05hY2ssXG4gICAgICAgICAgICAgICAgICAgICAgIEFyZ3MubmFjaygwLCB0cnVlLCByZXF1ZXVlKSk7XG59O1xuXG4vLyBgQmFzaWMuTmFja2AgaXMgbm90IGF2YWlsYWJsZSBpbiBvbGRlciBSYWJiaXRNUSB2ZXJzaW9ucyAob3IgaW4gdGhlXG4vLyBBTVFQIHNwZWNpZmljYXRpb24pLCBzbyB5b3UgaGF2ZSB0byB1c2UgdGhlIG9uZS1hdC1hLXRpbWVcbi8vIGBCYXNpYy5SZWplY3RgLiBUaGlzIGlzIG90aGVyd2lzZSBzeW5vbnltb3VzIHdpdGhcbi8vIGAjbmFjayhtZXNzYWdlLCBmYWxzZSwgcmVxdWV1ZSlgLlxuQy5yZWplY3QgPSBmdW5jdGlvbihtZXNzYWdlLCByZXF1ZXVlKSB7XG4gIHRoaXMuc2VuZEltbWVkaWF0ZWx5KFxuICAgIGRlZnMuQmFzaWNSZWplY3QsXG4gICAgQXJncy5yZWplY3QobWVzc2FnZS5maWVsZHMuZGVsaXZlcnlUYWcsIHJlcXVldWUpKTtcbn07XG5cbi8vIFRoZXJlIGFyZSBtb3JlIG9wdGlvbnMgaW4gQU1RUCB0aGFuIGV4cG9zZWQgaGVyZTsgUmFiYml0TVEgb25seVxuLy8gaW1wbGVtZW50cyBwcmVmZXRjaCBiYXNlZCBvbiBtZXNzYWdlIGNvdW50LCBhbmQgb25seSBmb3IgaW5kaXZpZHVhbFxuLy8gY2hhbm5lbHMgb3IgY29uc3VtZXJzLiBSYWJiaXRNUSB2My4zLjAgYW5kIGFmdGVyIHRyZWF0IHByZWZldGNoXG4vLyAod2l0aG91dCBgZ2xvYmFsYCBzZXQpIGFzIHBlci1jb25zdW1lciAoZm9yIGNvbnN1bWVycyBmb2xsb3dpbmcpLFxuLy8gYW5kIHByZWZldGNoIHdpdGggYGdsb2JhbGAgc2V0IGFzIHBlci1jaGFubmVsLlxuQy5wcmVmZXRjaCA9IEMucW9zID0gZnVuY3Rpb24oY291bnQsIGdsb2JhbCkge1xuICByZXR1cm4gdGhpcy5ycGMoZGVmcy5CYXNpY1FvcyxcbiAgICAgICAgICAgICAgICAgIEFyZ3MucHJlZmV0Y2goY291bnQsIGdsb2JhbCksXG4gICAgICAgICAgICAgICAgICBkZWZzLkJhc2ljUW9zT2spO1xufTtcblxuQy5yZWNvdmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJwYyhkZWZzLkJhc2ljUmVjb3ZlcixcbiAgICAgICAgICAgICAgICAgIEFyZ3MucmVjb3ZlcigpLFxuICAgICAgICAgICAgICAgICAgZGVmcy5CYXNpY1JlY292ZXJPayk7XG59O1xuXG4vLyBDb25maXJtIGNoYW5uZWwuIFRoaXMgaXMgYSBjaGFubmVsIHdpdGggY29uZmlybXMgJ3N3aXRjaGVkIG9uJyxcbi8vIG1lYW5pbmcgc2VudCBtZXNzYWdlcyB3aWxsIHByb3Zva2UgYSByZXNwb25kaW5nICdhY2snIG9yICduYWNrJ1xuLy8gZnJvbSB0aGUgc2VydmVyLiBUaGUgdXBzaG90IG9mIHRoaXMgaXMgdGhhdCBgcHVibGlzaGAgYW5kXG4vLyBgc2VuZFRvUXVldWVgIGJvdGggdGFrZSBhIGNhbGxiYWNrLCB3aGljaCB3aWxsIGJlIGNhbGxlZCBlaXRoZXJcbi8vIHdpdGggYG51bGxgIGFzIGl0cyBhcmd1bWVudCB0byBzaWduaWZ5ICdhY2snLCBvciBhbiBleGNlcHRpb24gYXNcbi8vIGl0cyBhcmd1bWVudCB0byBzaWduaWZ5ICduYWNrJy5cblxuZnVuY3Rpb24gQ29uZmlybUNoYW5uZWwoY29ubmVjdGlvbikge1xuICBDaGFubmVsLmNhbGwodGhpcywgY29ubmVjdGlvbik7XG59XG5pbmhlcml0cyhDb25maXJtQ2hhbm5lbCwgQ2hhbm5lbCk7XG5cbm1vZHVsZS5leHBvcnRzLkNvbmZpcm1DaGFubmVsID0gQ29uZmlybUNoYW5uZWw7XG5cbkNNLmNyZWF0ZUNvbmZpcm1DaGFubmVsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjID0gbmV3IENvbmZpcm1DaGFubmVsKHRoaXMuY29ubmVjdGlvbik7XG4gIHJldHVybiBjLm9wZW4oKVxuICAgIC50aGVuKGZ1bmN0aW9uKG9wZW5Paykge1xuICAgICAgcmV0dXJuIGMucnBjKGRlZnMuQ29uZmlybVNlbGVjdCwge25vd2FpdDogZmFsc2V9LFxuICAgICAgICAgICAgICAgICAgIGRlZnMuQ29uZmlybVNlbGVjdE9rKVxuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiBjOyB9KTtcbn07XG5cbnZhciBDQyA9IENvbmZpcm1DaGFubmVsLnByb3RvdHlwZTtcblxuQ0MucHVibGlzaCA9IGZ1bmN0aW9uKGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjb250ZW50LCBvcHRpb25zLCBjYikge1xuICB0aGlzLnB1c2hDb25maXJtQ2FsbGJhY2soY2IpO1xuICByZXR1cm4gQy5wdWJsaXNoLmNhbGwodGhpcywgZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNvbnRlbnQsIG9wdGlvbnMpO1xufTtcblxuQ0Muc2VuZFRvUXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgY29udGVudCwgb3B0aW9ucywgY2IpIHtcbiAgcmV0dXJuIHRoaXMucHVibGlzaCgnJywgcXVldWUsIGNvbnRlbnQsIG9wdGlvbnMsIGNiKTtcbn07XG5cbkNDLndhaXRGb3JDb25maXJtcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXdhaXRpbmcgPSBbXTtcbiAgdmFyIHVuY29uZmlybWVkID0gdGhpcy51bmNvbmZpcm1lZDtcbiAgdW5jb25maXJtZWQuZm9yRWFjaChmdW5jdGlvbih2YWwsIGluZGV4KSB7XG4gICAgaWYgKHZhbCA9PT0gbnVsbCk7IC8vIGFscmVhZHkgY29uZmlybWVkXG4gICAgZWxzZSB7XG4gICAgICB2YXIgY29uZmlybWVkID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHVuY29uZmlybWVkW2luZGV4XSA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGlmICh2YWwpIHZhbChlcnIpO1xuICAgICAgICAgIGlmIChlcnIgPT09IG51bGwpIHJlc29sdmUoKTtcbiAgICAgICAgICBlbHNlIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBhd2FpdGluZy5wdXNoKGNvbmZpcm1lZCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKGF3YWl0aW5nKTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/channel_model.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/codec.js":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/lib/codec.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//\n//\n//\n\n/*\n\nThe AMQP 0-9-1 is a mess when it comes to the types that can be\nencoded on the wire.\n\nThere are four encoding schemes, and three overlapping sets of types:\nframes, methods, (field-)tables, and properties.\n\nEach *frame type* has a set layout in which values of given types are\nconcatenated along with sections of \"raw binary\" data.\n\nIn frames there are `shortstr`s, that is length-prefixed strings of\nUTF8 chars, 8 bit unsigned integers (called `octet`), unsigned 16 bit\nintegers (called `short` or `short-uint`), unsigned 32 bit integers\n(called `long` or `long-uint`), unsigned 64 bit integers (called\n`longlong` or `longlong-uint`), and flags (called `bit`).\n\nMethods are encoded as a frame giving a method ID and a sequence of\narguments of known types. The encoded method argument values are\nconcatenated (with some fun complications around \"packing\" consecutive\nbit values into bytes).\n\nAlong with the types given in frames, method arguments may be long\nbyte strings (`longstr`, not required to be UTF8) or 64 bit unsigned\nintegers to be interpreted as timestamps (yeah I don't know why\neither), or arbitrary sets of key-value pairs (called `field-table`).\n\nInside a field table the keys are `shortstr` and the values are\nprefixed with a byte tag giving the type. The types are any of the\nabove except for bits (which are replaced by byte-wide `bool`), along\nwith a NULL value `void`, a special fixed-precision number encoding\n(`decimal`), IEEE754 `float`s and `double`s, signed integers,\n`field-array` (a sequence of tagged values), and nested field-tables.\n\nRabbitMQ and QPid use a subset of the field-table types, and different\nvalue tags, established before the AMQP 0-9-1 specification was\npublished. So far as I know, no-one uses the types and tags as\npublished. http://www.rabbitmq.com/amqp-0-9-1-errata.html gives the\nlist of field-table types.\n\nLastly, there are (sets of) properties, only one of which is given in\nAMQP 0-9-1: `BasicProperties`. These are almost the same as methods,\nexcept that they appear in content header frames, which include a\ncontent size, and they carry a set of flags indicating which\nproperties are present. This scheme can save ones of bytes per message\n(messages which take a minimum of three frames each to send).\n\n*/\n\n\n\nvar ints = __webpack_require__(/*! buffer-more-ints */ \"./node_modules/buffer-more-ints/buffer-more-ints.js\");\n\n// JavaScript uses only doubles so what I'm testing for is whether\n// it's *better* to encode a number as a float or double. This really\n// just amounts to testing whether there's a fractional part to the\n// number, except that see below. NB I don't use bitwise operations to\n// do this 'efficiently' -- it would mask the number to 32 bits.\n//\n// At 2^50, doubles don't have sufficient precision to distinguish\n// between floating point and integer numbers (`Math.pow(2, 50) + 0.1\n// === Math.pow(2, 50)` (and, above 2^53, doubles cannot represent all\n// integers (`Math.pow(2, 53) + 1 === Math.pow(2, 53)`)). Hence\n// anything with a magnitude at or above 2^50 may as well be encoded\n// as a 64-bit integer. Except that only signed integers are supported\n// by RabbitMQ, so anything above 2^63 - 1 must be a double.\nfunction isFloatingPoint(n) {\n    return n >= 0x8000000000000000 ||\n        (Math.abs(n) < 0x4000000000000\n         && Math.floor(n) !== n);\n}\n\nfunction encodeTable(buffer, val, offset) {\n    var start = offset;\n    offset += 4; // leave room for the table length\n    for (var key in val) {\n        if (val[key] !== undefined) {\n          var len = Buffer.byteLength(key);\n          buffer.writeUInt8(len, offset); offset++;\n          buffer.write(key, offset, 'utf8'); offset += len;\n          offset += encodeFieldValue(buffer, val[key], offset);\n        }\n    }\n    var size = offset - start;\n    buffer.writeUInt32BE(size - 4, start);\n    return size;\n}\n\nfunction encodeArray(buffer, val, offset) {\n    var start = offset;\n    offset += 4;\n    for (var i=0, num=val.length; i < num; i++) {\n        offset += encodeFieldValue(buffer, val[i], offset);\n    }\n    var size = offset - start;\n    buffer.writeUInt32BE(size - 4, start);\n    return size;\n}\n\nfunction encodeFieldValue(buffer, value, offset) {\n    var start = offset;\n    var type = typeof value, val = value;\n    // A trapdoor for specifying a type, e.g., timestamp\n    if (value && type === 'object' && value.hasOwnProperty('!')) {\n        val = value.value;\n        type = value['!'];\n    }\n\n    // If it's a JS number, we'll have to guess what type to encode it\n    // as.\n    if (type == 'number') {\n        // Making assumptions about the kind of number (floating point\n        // v integer, signed, unsigned, size) desired is dangerous in\n        // general; however, in practice RabbitMQ uses only\n        // longstrings and unsigned integers in its arguments, and\n        // other clients generally conflate number types anyway. So\n        // the only distinction we care about is floating point vs\n        // integers, preferring integers since those can be promoted\n        // if necessary. If floating point is required, we may as well\n        // use double precision.\n        if (isFloatingPoint(val)) {\n            type = 'double';\n        }\n        else { // only signed values are used in tables by\n               // RabbitMQ. It *used* to (< v3.3.0) treat the byte 'b'\n               // type as unsigned, but most clients (and the spec)\n               // think it's signed, and now RabbitMQ does too.\n            if (val < 128 && val >= -128) {\n                type = 'byte';\n            }\n            else if (val >= -0x8000 && val < 0x8000) {\n                type = 'short'\n            }\n            else if (val >= -0x80000000 && val < 0x80000000) {\n                type = 'int';\n            }\n            else {\n                type = 'long';\n            }\n        }\n    }\n\n    function tag(t) { buffer.write(t, offset); offset++; }\n\n    switch (type) {\n    case 'string': // no shortstr in field tables\n        var len = Buffer.byteLength(val, 'utf8');\n        tag('S');\n        buffer.writeUInt32BE(len, offset); offset += 4;\n        buffer.write(val, offset, 'utf8'); offset += len;\n        break;\n    case 'object':\n        if (val === null) {\n            tag('V');\n        }\n        else if (Array.isArray(val)) {\n            tag('A');\n            offset += encodeArray(buffer, val, offset);\n        }\n        else if (Buffer.isBuffer(val)) {\n            tag('x');\n            buffer.writeUInt32BE(val.length, offset); offset += 4;\n            val.copy(buffer, offset); offset += val.length;\n        }\n        else {\n            tag('F');\n            offset += encodeTable(buffer, val, offset);\n        }\n        break;\n    case 'boolean':\n        tag('t');\n        buffer.writeUInt8((val) ? 1 : 0, offset); offset++;\n        break;\n    // These are the types that are either guessed above, or\n    // explicitly given using the {'!': type} notation.\n    case 'double':\n    case 'float64':\n        tag('d');\n        buffer.writeDoubleBE(val, offset);\n        offset += 8;\n        break;\n    case 'byte':\n    case 'int8':\n        tag('b');\n        buffer.writeInt8(val, offset); offset++;\n        break;\n    case 'short':\n    case 'int16':\n        tag('s');\n        buffer.writeInt16BE(val, offset); offset += 2;\n        break;\n    case 'int':\n    case 'int32':\n        tag('I');\n        buffer.writeInt32BE(val, offset); offset += 4;\n        break;\n    case 'long':\n    case 'int64':\n        tag('l');\n        ints.writeInt64BE(buffer, val, offset); offset += 8;\n        break;\n\n    // Now for exotic types, those can _only_ be denoted by using\n    // `{'!': type, value: val}\n    case 'timestamp':\n        tag('T');\n        ints.writeUInt64BE(buffer, val, offset); offset += 8;\n        break;\n    case 'float':\n        tag('f');\n        buffer.writeFloatBE(val, offset); offset += 4;\n        break;\n    case 'decimal':\n        tag('D');\n        if (val.hasOwnProperty('places') && val.hasOwnProperty('digits')\n            && val.places >= 0 && val.places < 256) {\n            buffer[offset] = val.places; offset++;\n            buffer.writeUInt32BE(val.digits, offset); offset += 4;\n        }\n        else throw new TypeError(\n            \"Decimal value must be {'places': 0..255, 'digits': uint32}, \" +\n                \"got \" + JSON.stringify(val));\n        break;\n    default:\n        throw new TypeError('Unknown type to encode: ' + type);\n    }\n    return offset - start;\n}\n\n// Assume we're given a slice of the buffer that contains just the\n// fields.\nfunction decodeFields(slice) {\n    var fields = {}, offset = 0, size = slice.length;\n    var len, key, val;\n\n    function decodeFieldValue() {\n        var tag = String.fromCharCode(slice[offset]); offset++;\n        switch (tag) {\n        case 'b':\n            val = slice.readInt8(offset); offset++;\n            break;\n        case 'S':\n            len = slice.readUInt32BE(offset); offset += 4;\n            val = slice.toString('utf8', offset, offset + len);\n            offset += len;\n            break;\n        case 'I':\n            val = slice.readInt32BE(offset); offset += 4;\n            break;\n        case 'D': // only positive decimals, apparently.\n            var places = slice[offset]; offset++;\n            var digits = slice.readUInt32BE(offset); offset += 4;\n            val = {'!': 'decimal', value: {places: places, digits: digits}};\n            break;\n        case 'T':\n            val = ints.readUInt64BE(slice, offset); offset += 8;\n            val = {'!': 'timestamp', value: val};\n            break;\n        case 'F':\n            len = slice.readUInt32BE(offset); offset += 4;\n            val = decodeFields(slice.slice(offset, offset + len));\n            offset += len;\n            break;\n        case 'A':\n            len = slice.readUInt32BE(offset); offset += 4;\n            decodeArray(offset + len);\n            // NB decodeArray will itself update offset and val\n            break;\n        case 'd':\n            val = slice.readDoubleBE(offset); offset += 8;\n            break;\n        case 'f':\n            val = slice.readFloatBE(offset); offset += 4;\n            break;\n        case 'l':\n            val = ints.readInt64BE(slice, offset); offset += 8;\n            break;\n        case 's':\n            val = slice.readInt16BE(offset); offset += 2;\n            break;\n        case 't':\n            val = slice[offset] != 0; offset++;\n            break;\n        case 'V':\n            val = null;\n            break;\n        case 'x':\n            len = slice.readUInt32BE(offset); offset += 4;\n            val = slice.slice(offset, offset + len);\n            offset += len;\n            break;\n        default:\n            throw new TypeError('Unexpected type tag \"' + tag +'\"');\n        }\n    }\n\n    function decodeArray(until) {\n        var vals = [];\n        while (offset < until) {\n            decodeFieldValue();\n            vals.push(val);\n        }\n        val = vals;\n    }\n\n    while (offset < size) {\n        len = slice.readUInt8(offset); offset++;\n        key = slice.toString('utf8', offset, offset + len);\n        offset += len;\n        decodeFieldValue();\n        fields[key] = val;\n    }\n    return fields;\n}\n\nmodule.exports.encodeTable = encodeTable;\nmodule.exports.decodeFields = decodeFields;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY29kZWMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY29kZWMuanM/YmVlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG5cbi8qXG5cblRoZSBBTVFQIDAtOS0xIGlzIGEgbWVzcyB3aGVuIGl0IGNvbWVzIHRvIHRoZSB0eXBlcyB0aGF0IGNhbiBiZVxuZW5jb2RlZCBvbiB0aGUgd2lyZS5cblxuVGhlcmUgYXJlIGZvdXIgZW5jb2Rpbmcgc2NoZW1lcywgYW5kIHRocmVlIG92ZXJsYXBwaW5nIHNldHMgb2YgdHlwZXM6XG5mcmFtZXMsIG1ldGhvZHMsIChmaWVsZC0pdGFibGVzLCBhbmQgcHJvcGVydGllcy5cblxuRWFjaCAqZnJhbWUgdHlwZSogaGFzIGEgc2V0IGxheW91dCBpbiB3aGljaCB2YWx1ZXMgb2YgZ2l2ZW4gdHlwZXMgYXJlXG5jb25jYXRlbmF0ZWQgYWxvbmcgd2l0aCBzZWN0aW9ucyBvZiBcInJhdyBiaW5hcnlcIiBkYXRhLlxuXG5JbiBmcmFtZXMgdGhlcmUgYXJlIGBzaG9ydHN0cmBzLCB0aGF0IGlzIGxlbmd0aC1wcmVmaXhlZCBzdHJpbmdzIG9mXG5VVEY4IGNoYXJzLCA4IGJpdCB1bnNpZ25lZCBpbnRlZ2VycyAoY2FsbGVkIGBvY3RldGApLCB1bnNpZ25lZCAxNiBiaXRcbmludGVnZXJzIChjYWxsZWQgYHNob3J0YCBvciBgc2hvcnQtdWludGApLCB1bnNpZ25lZCAzMiBiaXQgaW50ZWdlcnNcbihjYWxsZWQgYGxvbmdgIG9yIGBsb25nLXVpbnRgKSwgdW5zaWduZWQgNjQgYml0IGludGVnZXJzIChjYWxsZWRcbmBsb25nbG9uZ2Agb3IgYGxvbmdsb25nLXVpbnRgKSwgYW5kIGZsYWdzIChjYWxsZWQgYGJpdGApLlxuXG5NZXRob2RzIGFyZSBlbmNvZGVkIGFzIGEgZnJhbWUgZ2l2aW5nIGEgbWV0aG9kIElEIGFuZCBhIHNlcXVlbmNlIG9mXG5hcmd1bWVudHMgb2Yga25vd24gdHlwZXMuIFRoZSBlbmNvZGVkIG1ldGhvZCBhcmd1bWVudCB2YWx1ZXMgYXJlXG5jb25jYXRlbmF0ZWQgKHdpdGggc29tZSBmdW4gY29tcGxpY2F0aW9ucyBhcm91bmQgXCJwYWNraW5nXCIgY29uc2VjdXRpdmVcbmJpdCB2YWx1ZXMgaW50byBieXRlcykuXG5cbkFsb25nIHdpdGggdGhlIHR5cGVzIGdpdmVuIGluIGZyYW1lcywgbWV0aG9kIGFyZ3VtZW50cyBtYXkgYmUgbG9uZ1xuYnl0ZSBzdHJpbmdzIChgbG9uZ3N0cmAsIG5vdCByZXF1aXJlZCB0byBiZSBVVEY4KSBvciA2NCBiaXQgdW5zaWduZWRcbmludGVnZXJzIHRvIGJlIGludGVycHJldGVkIGFzIHRpbWVzdGFtcHMgKHllYWggSSBkb24ndCBrbm93IHdoeVxuZWl0aGVyKSwgb3IgYXJiaXRyYXJ5IHNldHMgb2Yga2V5LXZhbHVlIHBhaXJzIChjYWxsZWQgYGZpZWxkLXRhYmxlYCkuXG5cbkluc2lkZSBhIGZpZWxkIHRhYmxlIHRoZSBrZXlzIGFyZSBgc2hvcnRzdHJgIGFuZCB0aGUgdmFsdWVzIGFyZVxucHJlZml4ZWQgd2l0aCBhIGJ5dGUgdGFnIGdpdmluZyB0aGUgdHlwZS4gVGhlIHR5cGVzIGFyZSBhbnkgb2YgdGhlXG5hYm92ZSBleGNlcHQgZm9yIGJpdHMgKHdoaWNoIGFyZSByZXBsYWNlZCBieSBieXRlLXdpZGUgYGJvb2xgKSwgYWxvbmdcbndpdGggYSBOVUxMIHZhbHVlIGB2b2lkYCwgYSBzcGVjaWFsIGZpeGVkLXByZWNpc2lvbiBudW1iZXIgZW5jb2RpbmdcbihgZGVjaW1hbGApLCBJRUVFNzU0IGBmbG9hdGBzIGFuZCBgZG91YmxlYHMsIHNpZ25lZCBpbnRlZ2VycyxcbmBmaWVsZC1hcnJheWAgKGEgc2VxdWVuY2Ugb2YgdGFnZ2VkIHZhbHVlcyksIGFuZCBuZXN0ZWQgZmllbGQtdGFibGVzLlxuXG5SYWJiaXRNUSBhbmQgUVBpZCB1c2UgYSBzdWJzZXQgb2YgdGhlIGZpZWxkLXRhYmxlIHR5cGVzLCBhbmQgZGlmZmVyZW50XG52YWx1ZSB0YWdzLCBlc3RhYmxpc2hlZCBiZWZvcmUgdGhlIEFNUVAgMC05LTEgc3BlY2lmaWNhdGlvbiB3YXNcbnB1Ymxpc2hlZC4gU28gZmFyIGFzIEkga25vdywgbm8tb25lIHVzZXMgdGhlIHR5cGVzIGFuZCB0YWdzIGFzXG5wdWJsaXNoZWQuIGh0dHA6Ly93d3cucmFiYml0bXEuY29tL2FtcXAtMC05LTEtZXJyYXRhLmh0bWwgZ2l2ZXMgdGhlXG5saXN0IG9mIGZpZWxkLXRhYmxlIHR5cGVzLlxuXG5MYXN0bHksIHRoZXJlIGFyZSAoc2V0cyBvZikgcHJvcGVydGllcywgb25seSBvbmUgb2Ygd2hpY2ggaXMgZ2l2ZW4gaW5cbkFNUVAgMC05LTE6IGBCYXNpY1Byb3BlcnRpZXNgLiBUaGVzZSBhcmUgYWxtb3N0IHRoZSBzYW1lIGFzIG1ldGhvZHMsXG5leGNlcHQgdGhhdCB0aGV5IGFwcGVhciBpbiBjb250ZW50IGhlYWRlciBmcmFtZXMsIHdoaWNoIGluY2x1ZGUgYVxuY29udGVudCBzaXplLCBhbmQgdGhleSBjYXJyeSBhIHNldCBvZiBmbGFncyBpbmRpY2F0aW5nIHdoaWNoXG5wcm9wZXJ0aWVzIGFyZSBwcmVzZW50LiBUaGlzIHNjaGVtZSBjYW4gc2F2ZSBvbmVzIG9mIGJ5dGVzIHBlciBtZXNzYWdlXG4obWVzc2FnZXMgd2hpY2ggdGFrZSBhIG1pbmltdW0gb2YgdGhyZWUgZnJhbWVzIGVhY2ggdG8gc2VuZCkuXG5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludHMgPSByZXF1aXJlKCdidWZmZXItbW9yZS1pbnRzJyk7XG5cbi8vIEphdmFTY3JpcHQgdXNlcyBvbmx5IGRvdWJsZXMgc28gd2hhdCBJJ20gdGVzdGluZyBmb3IgaXMgd2hldGhlclxuLy8gaXQncyAqYmV0dGVyKiB0byBlbmNvZGUgYSBudW1iZXIgYXMgYSBmbG9hdCBvciBkb3VibGUuIFRoaXMgcmVhbGx5XG4vLyBqdXN0IGFtb3VudHMgdG8gdGVzdGluZyB3aGV0aGVyIHRoZXJlJ3MgYSBmcmFjdGlvbmFsIHBhcnQgdG8gdGhlXG4vLyBudW1iZXIsIGV4Y2VwdCB0aGF0IHNlZSBiZWxvdy4gTkIgSSBkb24ndCB1c2UgYml0d2lzZSBvcGVyYXRpb25zIHRvXG4vLyBkbyB0aGlzICdlZmZpY2llbnRseScgLS0gaXQgd291bGQgbWFzayB0aGUgbnVtYmVyIHRvIDMyIGJpdHMuXG4vL1xuLy8gQXQgMl41MCwgZG91YmxlcyBkb24ndCBoYXZlIHN1ZmZpY2llbnQgcHJlY2lzaW9uIHRvIGRpc3Rpbmd1aXNoXG4vLyBiZXR3ZWVuIGZsb2F0aW5nIHBvaW50IGFuZCBpbnRlZ2VyIG51bWJlcnMgKGBNYXRoLnBvdygyLCA1MCkgKyAwLjFcbi8vID09PSBNYXRoLnBvdygyLCA1MClgIChhbmQsIGFib3ZlIDJeNTMsIGRvdWJsZXMgY2Fubm90IHJlcHJlc2VudCBhbGxcbi8vIGludGVnZXJzIChgTWF0aC5wb3coMiwgNTMpICsgMSA9PT0gTWF0aC5wb3coMiwgNTMpYCkpLiBIZW5jZVxuLy8gYW55dGhpbmcgd2l0aCBhIG1hZ25pdHVkZSBhdCBvciBhYm92ZSAyXjUwIG1heSBhcyB3ZWxsIGJlIGVuY29kZWRcbi8vIGFzIGEgNjQtYml0IGludGVnZXIuIEV4Y2VwdCB0aGF0IG9ubHkgc2lnbmVkIGludGVnZXJzIGFyZSBzdXBwb3J0ZWRcbi8vIGJ5IFJhYmJpdE1RLCBzbyBhbnl0aGluZyBhYm92ZSAyXjYzIC0gMSBtdXN0IGJlIGEgZG91YmxlLlxuZnVuY3Rpb24gaXNGbG9hdGluZ1BvaW50KG4pIHtcbiAgICByZXR1cm4gbiA+PSAweDgwMDAwMDAwMDAwMDAwMDAgfHxcbiAgICAgICAgKE1hdGguYWJzKG4pIDwgMHg0MDAwMDAwMDAwMDAwXG4gICAgICAgICAmJiBNYXRoLmZsb29yKG4pICE9PSBuKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlVGFibGUoYnVmZmVyLCB2YWwsIG9mZnNldCkge1xuICAgIHZhciBzdGFydCA9IG9mZnNldDtcbiAgICBvZmZzZXQgKz0gNDsgLy8gbGVhdmUgcm9vbSBmb3IgdGhlIHRhYmxlIGxlbmd0aFxuICAgIGZvciAodmFyIGtleSBpbiB2YWwpIHtcbiAgICAgICAgaWYgKHZhbFtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoa2V5KTtcbiAgICAgICAgICBidWZmZXIud3JpdGVVSW50OChsZW4sIG9mZnNldCk7IG9mZnNldCsrO1xuICAgICAgICAgIGJ1ZmZlci53cml0ZShrZXksIG9mZnNldCwgJ3V0ZjgnKTsgb2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgICBvZmZzZXQgKz0gZW5jb2RlRmllbGRWYWx1ZShidWZmZXIsIHZhbFtrZXldLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzaXplID0gb2Zmc2V0IC0gc3RhcnQ7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUoc2l6ZSAtIDQsIHN0YXJ0KTtcbiAgICByZXR1cm4gc2l6ZTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXkoYnVmZmVyLCB2YWwsIG9mZnNldCkge1xuICAgIHZhciBzdGFydCA9IG9mZnNldDtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBmb3IgKHZhciBpPTAsIG51bT12YWwubGVuZ3RoOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgb2Zmc2V0ICs9IGVuY29kZUZpZWxkVmFsdWUoYnVmZmVyLCB2YWxbaV0sIG9mZnNldCk7XG4gICAgfVxuICAgIHZhciBzaXplID0gb2Zmc2V0IC0gc3RhcnQ7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUoc2l6ZSAtIDQsIHN0YXJ0KTtcbiAgICByZXR1cm4gc2l6ZTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlRmllbGRWYWx1ZShidWZmZXIsIHZhbHVlLCBvZmZzZXQpIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsIHZhbCA9IHZhbHVlO1xuICAgIC8vIEEgdHJhcGRvb3IgZm9yIHNwZWNpZnlpbmcgYSB0eXBlLCBlLmcuLCB0aW1lc3RhbXBcbiAgICBpZiAodmFsdWUgJiYgdHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoJyEnKSkge1xuICAgICAgICB2YWwgPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgdHlwZSA9IHZhbHVlWychJ107XG4gICAgfVxuXG4gICAgLy8gSWYgaXQncyBhIEpTIG51bWJlciwgd2UnbGwgaGF2ZSB0byBndWVzcyB3aGF0IHR5cGUgdG8gZW5jb2RlIGl0XG4gICAgLy8gYXMuXG4gICAgaWYgKHR5cGUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gTWFraW5nIGFzc3VtcHRpb25zIGFib3V0IHRoZSBraW5kIG9mIG51bWJlciAoZmxvYXRpbmcgcG9pbnRcbiAgICAgICAgLy8gdiBpbnRlZ2VyLCBzaWduZWQsIHVuc2lnbmVkLCBzaXplKSBkZXNpcmVkIGlzIGRhbmdlcm91cyBpblxuICAgICAgICAvLyBnZW5lcmFsOyBob3dldmVyLCBpbiBwcmFjdGljZSBSYWJiaXRNUSB1c2VzIG9ubHlcbiAgICAgICAgLy8gbG9uZ3N0cmluZ3MgYW5kIHVuc2lnbmVkIGludGVnZXJzIGluIGl0cyBhcmd1bWVudHMsIGFuZFxuICAgICAgICAvLyBvdGhlciBjbGllbnRzIGdlbmVyYWxseSBjb25mbGF0ZSBudW1iZXIgdHlwZXMgYW55d2F5LiBTb1xuICAgICAgICAvLyB0aGUgb25seSBkaXN0aW5jdGlvbiB3ZSBjYXJlIGFib3V0IGlzIGZsb2F0aW5nIHBvaW50IHZzXG4gICAgICAgIC8vIGludGVnZXJzLCBwcmVmZXJyaW5nIGludGVnZXJzIHNpbmNlIHRob3NlIGNhbiBiZSBwcm9tb3RlZFxuICAgICAgICAvLyBpZiBuZWNlc3NhcnkuIElmIGZsb2F0aW5nIHBvaW50IGlzIHJlcXVpcmVkLCB3ZSBtYXkgYXMgd2VsbFxuICAgICAgICAvLyB1c2UgZG91YmxlIHByZWNpc2lvbi5cbiAgICAgICAgaWYgKGlzRmxvYXRpbmdQb2ludCh2YWwpKSB7XG4gICAgICAgICAgICB0eXBlID0gJ2RvdWJsZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG9ubHkgc2lnbmVkIHZhbHVlcyBhcmUgdXNlZCBpbiB0YWJsZXMgYnlcbiAgICAgICAgICAgICAgIC8vIFJhYmJpdE1RLiBJdCAqdXNlZCogdG8gKDwgdjMuMy4wKSB0cmVhdCB0aGUgYnl0ZSAnYidcbiAgICAgICAgICAgICAgIC8vIHR5cGUgYXMgdW5zaWduZWQsIGJ1dCBtb3N0IGNsaWVudHMgKGFuZCB0aGUgc3BlYylcbiAgICAgICAgICAgICAgIC8vIHRoaW5rIGl0J3Mgc2lnbmVkLCBhbmQgbm93IFJhYmJpdE1RIGRvZXMgdG9vLlxuICAgICAgICAgICAgaWYgKHZhbCA8IDEyOCAmJiB2YWwgPj0gLTEyOCkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnYnl0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPj0gLTB4ODAwMCAmJiB2YWwgPCAweDgwMDApIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3Nob3J0J1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID49IC0weDgwMDAwMDAwICYmIHZhbCA8IDB4ODAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2ludCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2xvbmcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGFnKHQpIHsgYnVmZmVyLndyaXRlKHQsIG9mZnNldCk7IG9mZnNldCsrOyB9XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdzdHJpbmcnOiAvLyBubyBzaG9ydHN0ciBpbiBmaWVsZCB0YWJsZXNcbiAgICAgICAgdmFyIGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgJ3V0ZjgnKTtcbiAgICAgICAgdGFnKCdTJyk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGxlbiwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgJ3V0ZjgnKTsgb2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGFnKCdWJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICB0YWcoJ0EnKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBlbmNvZGVBcnJheShidWZmZXIsIHZhbCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgICAgICAgICAgdGFnKCd4Jyk7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwubGVuZ3RoLCBvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIHZhbC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTsgb2Zmc2V0ICs9IHZhbC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YWcoJ0YnKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBlbmNvZGVUYWJsZShidWZmZXIsIHZhbCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgdGFnKCd0Jyk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KCh2YWwpID8gMSA6IDAsIG9mZnNldCk7IG9mZnNldCsrO1xuICAgICAgICBicmVhaztcbiAgICAvLyBUaGVzZSBhcmUgdGhlIHR5cGVzIHRoYXQgYXJlIGVpdGhlciBndWVzc2VkIGFib3ZlLCBvclxuICAgIC8vIGV4cGxpY2l0bHkgZ2l2ZW4gdXNpbmcgdGhlIHsnISc6IHR5cGV9IG5vdGF0aW9uLlxuICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHRhZygnZCcpO1xuICAgICAgICBidWZmZXIud3JpdGVEb3VibGVCRSh2YWwsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdieXRlJzpcbiAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgdGFnKCdiJyk7XG4gICAgICAgIGJ1ZmZlci53cml0ZUludDgodmFsLCBvZmZzZXQpOyBvZmZzZXQrKztcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2hvcnQnOlxuICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgdGFnKCdzJyk7XG4gICAgICAgIGJ1ZmZlci53cml0ZUludDE2QkUodmFsLCBvZmZzZXQpOyBvZmZzZXQgKz0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW50JzpcbiAgICBjYXNlICdpbnQzMic6XG4gICAgICAgIHRhZygnSScpO1xuICAgICAgICBidWZmZXIud3JpdGVJbnQzMkJFKHZhbCwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xvbmcnOlxuICAgIGNhc2UgJ2ludDY0JzpcbiAgICAgICAgdGFnKCdsJyk7XG4gICAgICAgIGludHMud3JpdGVJbnQ2NEJFKGJ1ZmZlciwgdmFsLCBvZmZzZXQpOyBvZmZzZXQgKz0gODtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAvLyBOb3cgZm9yIGV4b3RpYyB0eXBlcywgdGhvc2UgY2FuIF9vbmx5XyBiZSBkZW5vdGVkIGJ5IHVzaW5nXG4gICAgLy8gYHsnISc6IHR5cGUsIHZhbHVlOiB2YWx9XG4gICAgY2FzZSAndGltZXN0YW1wJzpcbiAgICAgICAgdGFnKCdUJyk7XG4gICAgICAgIGludHMud3JpdGVVSW50NjRCRShidWZmZXIsIHZhbCwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDg7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgdGFnKCdmJyk7XG4gICAgICAgIGJ1ZmZlci53cml0ZUZsb2F0QkUodmFsLCBvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGVjaW1hbCc6XG4gICAgICAgIHRhZygnRCcpO1xuICAgICAgICBpZiAodmFsLmhhc093blByb3BlcnR5KCdwbGFjZXMnKSAmJiB2YWwuaGFzT3duUHJvcGVydHkoJ2RpZ2l0cycpXG4gICAgICAgICAgICAmJiB2YWwucGxhY2VzID49IDAgJiYgdmFsLnBsYWNlcyA8IDI1Nikge1xuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSB2YWwucGxhY2VzOyBvZmZzZXQrKztcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbC5kaWdpdHMsIG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIFwiRGVjaW1hbCB2YWx1ZSBtdXN0IGJlIHsncGxhY2VzJzogMC4uMjU1LCAnZGlnaXRzJzogdWludDMyfSwgXCIgK1xuICAgICAgICAgICAgICAgIFwiZ290IFwiICsgSlNPTi5zdHJpbmdpZnkodmFsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gdHlwZSB0byBlbmNvZGU6ICcgKyB0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xufVxuXG4vLyBBc3N1bWUgd2UncmUgZ2l2ZW4gYSBzbGljZSBvZiB0aGUgYnVmZmVyIHRoYXQgY29udGFpbnMganVzdCB0aGVcbi8vIGZpZWxkcy5cbmZ1bmN0aW9uIGRlY29kZUZpZWxkcyhzbGljZSkge1xuICAgIHZhciBmaWVsZHMgPSB7fSwgb2Zmc2V0ID0gMCwgc2l6ZSA9IHNsaWNlLmxlbmd0aDtcbiAgICB2YXIgbGVuLCBrZXksIHZhbDtcblxuICAgIGZ1bmN0aW9uIGRlY29kZUZpZWxkVmFsdWUoKSB7XG4gICAgICAgIHZhciB0YWcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHNsaWNlW29mZnNldF0pOyBvZmZzZXQrKztcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICB2YWwgPSBzbGljZS5yZWFkSW50OChvZmZzZXQpOyBvZmZzZXQrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIGxlbiA9IHNsaWNlLnJlYWRVSW50MzJCRShvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIHZhbCA9IHNsaWNlLnRvU3RyaW5nKCd1dGY4Jywgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdJJzpcbiAgICAgICAgICAgIHZhbCA9IHNsaWNlLnJlYWRJbnQzMkJFKG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0QnOiAvLyBvbmx5IHBvc2l0aXZlIGRlY2ltYWxzLCBhcHBhcmVudGx5LlxuICAgICAgICAgICAgdmFyIHBsYWNlcyA9IHNsaWNlW29mZnNldF07IG9mZnNldCsrO1xuICAgICAgICAgICAgdmFyIGRpZ2l0cyA9IHNsaWNlLnJlYWRVSW50MzJCRShvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIHZhbCA9IHsnISc6ICdkZWNpbWFsJywgdmFsdWU6IHtwbGFjZXM6IHBsYWNlcywgZGlnaXRzOiBkaWdpdHN9fTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKHNsaWNlLCBvZmZzZXQpOyBvZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHZhbCA9IHsnISc6ICd0aW1lc3RhbXAnLCB2YWx1ZTogdmFsfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdGJzpcbiAgICAgICAgICAgIGxlbiA9IHNsaWNlLnJlYWRVSW50MzJCRShvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIHZhbCA9IGRlY29kZUZpZWxkcyhzbGljZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIGxlbiA9IHNsaWNlLnJlYWRVSW50MzJCRShvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIGRlY29kZUFycmF5KG9mZnNldCArIGxlbik7XG4gICAgICAgICAgICAvLyBOQiBkZWNvZGVBcnJheSB3aWxsIGl0c2VsZiB1cGRhdGUgb2Zmc2V0IGFuZCB2YWxcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgIHZhbCA9IHNsaWNlLnJlYWREb3VibGVCRShvZmZzZXQpOyBvZmZzZXQgKz0gODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIHZhbCA9IHNsaWNlLnJlYWRGbG9hdEJFKG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgdmFsID0gaW50cy5yZWFkSW50NjRCRShzbGljZSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICB2YWwgPSBzbGljZS5yZWFkSW50MTZCRShvZmZzZXQpOyBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHZhbCA9IHNsaWNlW29mZnNldF0gIT0gMDsgb2Zmc2V0Kys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgbGVuID0gc2xpY2UucmVhZFVJbnQzMkJFKG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICAgICAgdmFsID0gc2xpY2Uuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCB0eXBlIHRhZyBcIicgKyB0YWcgKydcIicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlQXJyYXkodW50aWwpIHtcbiAgICAgICAgdmFyIHZhbHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IHVudGlsKSB7XG4gICAgICAgICAgICBkZWNvZGVGaWVsZFZhbHVlKCk7XG4gICAgICAgICAgICB2YWxzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgICAgICB2YWwgPSB2YWxzO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmZzZXQgPCBzaXplKSB7XG4gICAgICAgIGxlbiA9IHNsaWNlLnJlYWRVSW50OChvZmZzZXQpOyBvZmZzZXQrKztcbiAgICAgICAga2V5ID0gc2xpY2UudG9TdHJpbmcoJ3V0ZjgnLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgICAgIG9mZnNldCArPSBsZW47XG4gICAgICAgIGRlY29kZUZpZWxkVmFsdWUoKTtcbiAgICAgICAgZmllbGRzW2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG59XG5cbm1vZHVsZS5leHBvcnRzLmVuY29kZVRhYmxlID0gZW5jb2RlVGFibGU7XG5tb2R1bGUuZXhwb3J0cy5kZWNvZGVGaWVsZHMgPSBkZWNvZGVGaWVsZHM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/codec.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/connect.js":
/*!*********************************************!*\
  !*** ./node_modules/amqplib/lib/connect.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//\n//\n//\n\n// General-purpose API for glueing everything together.\n\n\n\nvar URL = __webpack_require__(/*! url */ \"url\");\nvar QS = __webpack_require__(/*! querystring */ \"querystring\");\nvar Connection = __webpack_require__(/*! ./connection */ \"./node_modules/amqplib/lib/connection.js\").Connection;\nvar fmt = __webpack_require__(/*! util */ \"util\").format;\nvar credentials = __webpack_require__(/*! ./credentials */ \"./node_modules/amqplib/lib/credentials.js\");\n\nfunction copyInto(obj, target) {\n  var keys = Object.keys(obj);\n  var i = keys.length;\n  while (i--) {\n    var k = keys[i];\n    target[k] = obj[k];\n  }\n  return target;\n}\n\n// Adapted from util._extend, which is too fringe to use.\nfunction clone(obj) {\n  return copyInto(obj, {});\n}\n\nvar CLIENT_PROPERTIES = {\n  \"product\": \"amqplib\",\n  \"version\": __webpack_require__(/*! ../package.json */ \"./node_modules/amqplib/package.json\").version,\n  \"platform\": fmt('Node.JS %s', process.version),\n  \"information\": \"http://squaremo.github.io/amqp.node\",\n  \"capabilities\": {\n    \"publisher_confirms\": true,\n    \"exchange_exchange_bindings\": true,\n    \"basic.nack\": true,\n    \"consumer_cancel_notify\": true,\n    \"connection.blocked\": true,\n    \"authentication_failure_close\": true\n  }\n};\n\n// Construct the main frames used in the opening handshake\nfunction openFrames(vhost, query, credentials, extraClientProperties) {\n  if (!vhost)\n    vhost = '/';\n  else\n    vhost = QS.unescape(vhost);\n\n  var query = query || {};\n\n  function intOrDefault(val, def) {\n    return (val === undefined) ? def : parseInt(val);\n  }\n\n  var clientProperties = Object.create(CLIENT_PROPERTIES);\n\n  return {\n    // start-ok\n    'clientProperties': copyInto(extraClientProperties, clientProperties),\n    'mechanism': credentials.mechanism,\n    'response': credentials.response(),\n    'locale': query.locale || 'en_US',\n\n    // tune-ok\n    'channelMax': intOrDefault(query.channelMax, 0),\n    'frameMax': intOrDefault(query.frameMax, 0x1000),\n    'heartbeat': intOrDefault(query.heartbeat, 0),\n\n    // open\n    'virtualHost': vhost,\n    'capabilities': '',\n    'insist': 0\n  };\n}\n\n// Decide on credentials based on what we're supplied. Note that in a\n// parsed URL, the auth part is already URL-decoded, so e.g., '%3a' in\n// the URL is already decoded to ':'. This is a bit unhelpful, as it\n// means we can't tell whether a colon is a separator, or part of the\n// username. Assume no colons in usernames.\nfunction credentialsFromUrl(parts) {\n  var user = 'guest', passwd = 'guest';\n  if (parts.auth) {\n    var colon = parts.auth.indexOf(':')\n    if (colon == -1) {\n      user = parts.auth;\n      passwd = '';\n    } else {\n      user = parts.auth.substring(0, colon);\n      passwd = parts.auth.substring(colon+1);\n    }\n  }\n  return credentials.plain(user, passwd);\n}\n\nfunction connect(url, socketOptions, openCallback) {\n  // tls.connect uses `util._extend()` on the options given it, which\n  // copies only properties mentioned in `Object.keys()`, when\n  // processing the options. So I have to make copies too, rather\n  // than using `Object.create()`.\n  var sockopts = clone(socketOptions || {});\n  url = url || 'amqp://localhost';\n\n  var noDelay = !!sockopts.noDelay;\n  var timeout = sockopts.timeout;\n  var keepAlive = !!sockopts.keepAlive;\n  // 0 is default for node\n  var keepAliveDelay = sockopts.keepAliveDelay || 0;\n\n  var extraClientProperties = sockopts.clientProperties || {};\n\n  var protocol, fields;\n  if (typeof url === 'object') {\n    protocol = (url.protocol || 'amqp') + ':';\n    sockopts.host = url.hostname;\n    sockopts.port = url.port || ((protocol === 'amqp:') ? 5672 : 5671);\n\n    var user, pass;\n    // Only default if both are missing, to have the same behaviour as\n    // the stringly URL.\n    if (url.username == undefined && url.password == undefined) {\n      user = 'guest'; pass = 'guest';\n    } else {\n      user = url.username || '';\n      pass = url.password || '';\n    }\n\n    var config = {\n      locale: url.locale,\n      channelMax: url.channelMax,\n      frameMax: url.frameMax,\n      heartbeat: url.heartbeat,\n    };\n\n    fields = openFrames(url.vhost, config, sockopts.credentials || credentials.plain(user, pass), extraClientProperties);\n  } else {\n    var parts = URL.parse(url, true); // yes, parse the query string\n    protocol = parts.protocol;\n    sockopts.host = parts.hostname;\n    sockopts.port = parseInt(parts.port) || ((protocol === 'amqp:') ? 5672 : 5671);\n    var vhost = parts.pathname ? parts.pathname.substr(1) : null;\n    fields = openFrames(vhost, parts.query, sockopts.credentials || credentialsFromUrl(parts), extraClientProperties);\n  }\n\n  var sockok = false;\n  var sock;\n\n  function onConnect() {\n    sockok = true;\n    sock.setNoDelay(noDelay);\n    if (keepAlive) sock.setKeepAlive(keepAlive, keepAliveDelay);\n\n    var c = new Connection(sock);\n    c.open(fields, function(err, ok) {\n      // disable timeout once the connection is open, we don't want\n      // it fouling things\n      if (timeout) sock.setTimeout(0);\n      if (err === null) {\n        openCallback(null, c);\n      }\n      else openCallback(err);\n    });\n  }\n\n  if (protocol === 'amqp:') {\n    sock = __webpack_require__(/*! net */ \"net\").connect(sockopts, onConnect);\n  }\n  else if (protocol === 'amqps:') {\n    sock = __webpack_require__(/*! tls */ \"tls\").connect(sockopts, onConnect);\n  }\n  else {\n    throw new Error(\"Expected amqp: or amqps: as the protocol; got \" + protocol);\n  }\n\n  if (timeout) {\n    sock.setTimeout(timeout, function() {\n      sock.end();\n      sock.destroy();\n      openCallback(new Error('connect ETIMEDOUT'));\n    });\n  }\n\n  sock.once('error', function(err) {\n    if (!sockok) openCallback(err);\n  });\n\n}\n\nmodule.exports.connect = connect;\nmodule.exports.credentialsFromUrl = credentialsFromUrl;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY29ubmVjdC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9jb25uZWN0LmpzPzRkNGEiXSwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vXG4vL1xuXG4vLyBHZW5lcmFsLXB1cnBvc2UgQVBJIGZvciBnbHVlaW5nIGV2ZXJ5dGhpbmcgdG9nZXRoZXIuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIFFTID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbnZhciBDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJykuQ29ubmVjdGlvbjtcbnZhciBmbXQgPSByZXF1aXJlKCd1dGlsJykuZm9ybWF0O1xudmFyIGNyZWRlbnRpYWxzID0gcmVxdWlyZSgnLi9jcmVkZW50aWFscycpO1xuXG5mdW5jdGlvbiBjb3B5SW50byhvYmosIHRhcmdldCkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgayA9IGtleXNbaV07XG4gICAgdGFyZ2V0W2tdID0gb2JqW2tdO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSB1dGlsLl9leHRlbmQsIHdoaWNoIGlzIHRvbyBmcmluZ2UgdG8gdXNlLlxuZnVuY3Rpb24gY2xvbmUob2JqKSB7XG4gIHJldHVybiBjb3B5SW50byhvYmosIHt9KTtcbn1cblxudmFyIENMSUVOVF9QUk9QRVJUSUVTID0ge1xuICBcInByb2R1Y3RcIjogXCJhbXFwbGliXCIsXG4gIFwidmVyc2lvblwiOiByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uLFxuICBcInBsYXRmb3JtXCI6IGZtdCgnTm9kZS5KUyAlcycsIHByb2Nlc3MudmVyc2lvbiksXG4gIFwiaW5mb3JtYXRpb25cIjogXCJodHRwOi8vc3F1YXJlbW8uZ2l0aHViLmlvL2FtcXAubm9kZVwiLFxuICBcImNhcGFiaWxpdGllc1wiOiB7XG4gICAgXCJwdWJsaXNoZXJfY29uZmlybXNcIjogdHJ1ZSxcbiAgICBcImV4Y2hhbmdlX2V4Y2hhbmdlX2JpbmRpbmdzXCI6IHRydWUsXG4gICAgXCJiYXNpYy5uYWNrXCI6IHRydWUsXG4gICAgXCJjb25zdW1lcl9jYW5jZWxfbm90aWZ5XCI6IHRydWUsXG4gICAgXCJjb25uZWN0aW9uLmJsb2NrZWRcIjogdHJ1ZSxcbiAgICBcImF1dGhlbnRpY2F0aW9uX2ZhaWx1cmVfY2xvc2VcIjogdHJ1ZVxuICB9XG59O1xuXG4vLyBDb25zdHJ1Y3QgdGhlIG1haW4gZnJhbWVzIHVzZWQgaW4gdGhlIG9wZW5pbmcgaGFuZHNoYWtlXG5mdW5jdGlvbiBvcGVuRnJhbWVzKHZob3N0LCBxdWVyeSwgY3JlZGVudGlhbHMsIGV4dHJhQ2xpZW50UHJvcGVydGllcykge1xuICBpZiAoIXZob3N0KVxuICAgIHZob3N0ID0gJy8nO1xuICBlbHNlXG4gICAgdmhvc3QgPSBRUy51bmVzY2FwZSh2aG9zdCk7XG5cbiAgdmFyIHF1ZXJ5ID0gcXVlcnkgfHwge307XG5cbiAgZnVuY3Rpb24gaW50T3JEZWZhdWx0KHZhbCwgZGVmKSB7XG4gICAgcmV0dXJuICh2YWwgPT09IHVuZGVmaW5lZCkgPyBkZWYgOiBwYXJzZUludCh2YWwpO1xuICB9XG5cbiAgdmFyIGNsaWVudFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKENMSUVOVF9QUk9QRVJUSUVTKTtcblxuICByZXR1cm4ge1xuICAgIC8vIHN0YXJ0LW9rXG4gICAgJ2NsaWVudFByb3BlcnRpZXMnOiBjb3B5SW50byhleHRyYUNsaWVudFByb3BlcnRpZXMsIGNsaWVudFByb3BlcnRpZXMpLFxuICAgICdtZWNoYW5pc20nOiBjcmVkZW50aWFscy5tZWNoYW5pc20sXG4gICAgJ3Jlc3BvbnNlJzogY3JlZGVudGlhbHMucmVzcG9uc2UoKSxcbiAgICAnbG9jYWxlJzogcXVlcnkubG9jYWxlIHx8ICdlbl9VUycsXG5cbiAgICAvLyB0dW5lLW9rXG4gICAgJ2NoYW5uZWxNYXgnOiBpbnRPckRlZmF1bHQocXVlcnkuY2hhbm5lbE1heCwgMCksXG4gICAgJ2ZyYW1lTWF4JzogaW50T3JEZWZhdWx0KHF1ZXJ5LmZyYW1lTWF4LCAweDEwMDApLFxuICAgICdoZWFydGJlYXQnOiBpbnRPckRlZmF1bHQocXVlcnkuaGVhcnRiZWF0LCAwKSxcblxuICAgIC8vIG9wZW5cbiAgICAndmlydHVhbEhvc3QnOiB2aG9zdCxcbiAgICAnY2FwYWJpbGl0aWVzJzogJycsXG4gICAgJ2luc2lzdCc6IDBcbiAgfTtcbn1cblxuLy8gRGVjaWRlIG9uIGNyZWRlbnRpYWxzIGJhc2VkIG9uIHdoYXQgd2UncmUgc3VwcGxpZWQuIE5vdGUgdGhhdCBpbiBhXG4vLyBwYXJzZWQgVVJMLCB0aGUgYXV0aCBwYXJ0IGlzIGFscmVhZHkgVVJMLWRlY29kZWQsIHNvIGUuZy4sICclM2EnIGluXG4vLyB0aGUgVVJMIGlzIGFscmVhZHkgZGVjb2RlZCB0byAnOicuIFRoaXMgaXMgYSBiaXQgdW5oZWxwZnVsLCBhcyBpdFxuLy8gbWVhbnMgd2UgY2FuJ3QgdGVsbCB3aGV0aGVyIGEgY29sb24gaXMgYSBzZXBhcmF0b3IsIG9yIHBhcnQgb2YgdGhlXG4vLyB1c2VybmFtZS4gQXNzdW1lIG5vIGNvbG9ucyBpbiB1c2VybmFtZXMuXG5mdW5jdGlvbiBjcmVkZW50aWFsc0Zyb21VcmwocGFydHMpIHtcbiAgdmFyIHVzZXIgPSAnZ3Vlc3QnLCBwYXNzd2QgPSAnZ3Vlc3QnO1xuICBpZiAocGFydHMuYXV0aCkge1xuICAgIHZhciBjb2xvbiA9IHBhcnRzLmF1dGguaW5kZXhPZignOicpXG4gICAgaWYgKGNvbG9uID09IC0xKSB7XG4gICAgICB1c2VyID0gcGFydHMuYXV0aDtcbiAgICAgIHBhc3N3ZCA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB1c2VyID0gcGFydHMuYXV0aC5zdWJzdHJpbmcoMCwgY29sb24pO1xuICAgICAgcGFzc3dkID0gcGFydHMuYXV0aC5zdWJzdHJpbmcoY29sb24rMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVkZW50aWFscy5wbGFpbih1c2VyLCBwYXNzd2QpO1xufVxuXG5mdW5jdGlvbiBjb25uZWN0KHVybCwgc29ja2V0T3B0aW9ucywgb3BlbkNhbGxiYWNrKSB7XG4gIC8vIHRscy5jb25uZWN0IHVzZXMgYHV0aWwuX2V4dGVuZCgpYCBvbiB0aGUgb3B0aW9ucyBnaXZlbiBpdCwgd2hpY2hcbiAgLy8gY29waWVzIG9ubHkgcHJvcGVydGllcyBtZW50aW9uZWQgaW4gYE9iamVjdC5rZXlzKClgLCB3aGVuXG4gIC8vIHByb2Nlc3NpbmcgdGhlIG9wdGlvbnMuIFNvIEkgaGF2ZSB0byBtYWtlIGNvcGllcyB0b28sIHJhdGhlclxuICAvLyB0aGFuIHVzaW5nIGBPYmplY3QuY3JlYXRlKClgLlxuICB2YXIgc29ja29wdHMgPSBjbG9uZShzb2NrZXRPcHRpb25zIHx8IHt9KTtcbiAgdXJsID0gdXJsIHx8ICdhbXFwOi8vbG9jYWxob3N0JztcblxuICB2YXIgbm9EZWxheSA9ICEhc29ja29wdHMubm9EZWxheTtcbiAgdmFyIHRpbWVvdXQgPSBzb2Nrb3B0cy50aW1lb3V0O1xuICB2YXIga2VlcEFsaXZlID0gISFzb2Nrb3B0cy5rZWVwQWxpdmU7XG4gIC8vIDAgaXMgZGVmYXVsdCBmb3Igbm9kZVxuICB2YXIga2VlcEFsaXZlRGVsYXkgPSBzb2Nrb3B0cy5rZWVwQWxpdmVEZWxheSB8fCAwO1xuXG4gIHZhciBleHRyYUNsaWVudFByb3BlcnRpZXMgPSBzb2Nrb3B0cy5jbGllbnRQcm9wZXJ0aWVzIHx8IHt9O1xuXG4gIHZhciBwcm90b2NvbCwgZmllbGRzO1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ29iamVjdCcpIHtcbiAgICBwcm90b2NvbCA9ICh1cmwucHJvdG9jb2wgfHwgJ2FtcXAnKSArICc6JztcbiAgICBzb2Nrb3B0cy5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHNvY2tvcHRzLnBvcnQgPSB1cmwucG9ydCB8fCAoKHByb3RvY29sID09PSAnYW1xcDonKSA/IDU2NzIgOiA1NjcxKTtcblxuICAgIHZhciB1c2VyLCBwYXNzO1xuICAgIC8vIE9ubHkgZGVmYXVsdCBpZiBib3RoIGFyZSBtaXNzaW5nLCB0byBoYXZlIHRoZSBzYW1lIGJlaGF2aW91ciBhc1xuICAgIC8vIHRoZSBzdHJpbmdseSBVUkwuXG4gICAgaWYgKHVybC51c2VybmFtZSA9PSB1bmRlZmluZWQgJiYgdXJsLnBhc3N3b3JkID09IHVuZGVmaW5lZCkge1xuICAgICAgdXNlciA9ICdndWVzdCc7IHBhc3MgPSAnZ3Vlc3QnO1xuICAgIH0gZWxzZSB7XG4gICAgICB1c2VyID0gdXJsLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgcGFzcyA9IHVybC5wYXNzd29yZCB8fCAnJztcbiAgICB9XG5cbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgbG9jYWxlOiB1cmwubG9jYWxlLFxuICAgICAgY2hhbm5lbE1heDogdXJsLmNoYW5uZWxNYXgsXG4gICAgICBmcmFtZU1heDogdXJsLmZyYW1lTWF4LFxuICAgICAgaGVhcnRiZWF0OiB1cmwuaGVhcnRiZWF0LFxuICAgIH07XG5cbiAgICBmaWVsZHMgPSBvcGVuRnJhbWVzKHVybC52aG9zdCwgY29uZmlnLCBzb2Nrb3B0cy5jcmVkZW50aWFscyB8fCBjcmVkZW50aWFscy5wbGFpbih1c2VyLCBwYXNzKSwgZXh0cmFDbGllbnRQcm9wZXJ0aWVzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBVUkwucGFyc2UodXJsLCB0cnVlKTsgLy8geWVzLCBwYXJzZSB0aGUgcXVlcnkgc3RyaW5nXG4gICAgcHJvdG9jb2wgPSBwYXJ0cy5wcm90b2NvbDtcbiAgICBzb2Nrb3B0cy5ob3N0ID0gcGFydHMuaG9zdG5hbWU7XG4gICAgc29ja29wdHMucG9ydCA9IHBhcnNlSW50KHBhcnRzLnBvcnQpIHx8ICgocHJvdG9jb2wgPT09ICdhbXFwOicpID8gNTY3MiA6IDU2NzEpO1xuICAgIHZhciB2aG9zdCA9IHBhcnRzLnBhdGhuYW1lID8gcGFydHMucGF0aG5hbWUuc3Vic3RyKDEpIDogbnVsbDtcbiAgICBmaWVsZHMgPSBvcGVuRnJhbWVzKHZob3N0LCBwYXJ0cy5xdWVyeSwgc29ja29wdHMuY3JlZGVudGlhbHMgfHwgY3JlZGVudGlhbHNGcm9tVXJsKHBhcnRzKSwgZXh0cmFDbGllbnRQcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIHZhciBzb2Nrb2sgPSBmYWxzZTtcbiAgdmFyIHNvY2s7XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0KCkge1xuICAgIHNvY2tvayA9IHRydWU7XG4gICAgc29jay5zZXROb0RlbGF5KG5vRGVsYXkpO1xuICAgIGlmIChrZWVwQWxpdmUpIHNvY2suc2V0S2VlcEFsaXZlKGtlZXBBbGl2ZSwga2VlcEFsaXZlRGVsYXkpO1xuXG4gICAgdmFyIGMgPSBuZXcgQ29ubmVjdGlvbihzb2NrKTtcbiAgICBjLm9wZW4oZmllbGRzLCBmdW5jdGlvbihlcnIsIG9rKSB7XG4gICAgICAvLyBkaXNhYmxlIHRpbWVvdXQgb25jZSB0aGUgY29ubmVjdGlvbiBpcyBvcGVuLCB3ZSBkb24ndCB3YW50XG4gICAgICAvLyBpdCBmb3VsaW5nIHRoaW5nc1xuICAgICAgaWYgKHRpbWVvdXQpIHNvY2suc2V0VGltZW91dCgwKTtcbiAgICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgICAgb3BlbkNhbGxiYWNrKG51bGwsIGMpO1xuICAgICAgfVxuICAgICAgZWxzZSBvcGVuQ2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwcm90b2NvbCA9PT0gJ2FtcXA6Jykge1xuICAgIHNvY2sgPSByZXF1aXJlKCduZXQnKS5jb25uZWN0KHNvY2tvcHRzLCBvbkNvbm5lY3QpO1xuICB9XG4gIGVsc2UgaWYgKHByb3RvY29sID09PSAnYW1xcHM6Jykge1xuICAgIHNvY2sgPSByZXF1aXJlKCd0bHMnKS5jb25uZWN0KHNvY2tvcHRzLCBvbkNvbm5lY3QpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGFtcXA6IG9yIGFtcXBzOiBhcyB0aGUgcHJvdG9jb2w7IGdvdCBcIiArIHByb3RvY29sKTtcbiAgfVxuXG4gIGlmICh0aW1lb3V0KSB7XG4gICAgc29jay5zZXRUaW1lb3V0KHRpbWVvdXQsIGZ1bmN0aW9uKCkge1xuICAgICAgc29jay5lbmQoKTtcbiAgICAgIHNvY2suZGVzdHJveSgpO1xuICAgICAgb3BlbkNhbGxiYWNrKG5ldyBFcnJvcignY29ubmVjdCBFVElNRURPVVQnKSk7XG4gICAgfSk7XG4gIH1cblxuICBzb2NrLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKCFzb2Nrb2spIG9wZW5DYWxsYmFjayhlcnIpO1xuICB9KTtcblxufVxuXG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gY29ubmVjdDtcbm1vZHVsZS5leHBvcnRzLmNyZWRlbnRpYWxzRnJvbVVybCA9IGNyZWRlbnRpYWxzRnJvbVVybDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/connect.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/connection.js":
/*!************************************************!*\
  !*** ./node_modules/amqplib/lib/connection.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//\n//\n//\n\n\n\nvar defs = __webpack_require__(/*! ./defs */ \"./node_modules/amqplib/lib/defs.js\");\nvar constants = defs.constants;\nvar frame = __webpack_require__(/*! ./frame */ \"./node_modules/amqplib/lib/frame.js\");\nvar HEARTBEAT = frame.HEARTBEAT;\nvar Mux = __webpack_require__(/*! ./mux */ \"./node_modules/amqplib/lib/mux.js\").Mux;\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar Duplex =\n  __webpack_require__(/*! stream */ \"stream\").Duplex ||\n  __webpack_require__(/*! readable-stream/duplex */ \"./node_modules/readable-stream/duplex.js\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar Heart = __webpack_require__(/*! ./heartbeat */ \"./node_modules/amqplib/lib/heartbeat.js\").Heart;\n\nvar methodName = __webpack_require__(/*! ./format */ \"./node_modules/amqplib/lib/format.js\").methodName;\nvar closeMsg = __webpack_require__(/*! ./format */ \"./node_modules/amqplib/lib/format.js\").closeMessage;\nvar inspect = __webpack_require__(/*! ./format */ \"./node_modules/amqplib/lib/format.js\").inspect;\n\nvar BitSet = __webpack_require__(/*! ./bitset */ \"./node_modules/amqplib/lib/bitset.js\").BitSet;\nvar inherits = __webpack_require__(/*! util */ \"util\").inherits;\nvar fmt = __webpack_require__(/*! util */ \"util\").format;\nvar PassThrough = __webpack_require__(/*! stream */ \"stream\").PassThrough ||\n  __webpack_require__(/*! readable-stream/passthrough */ \"./node_modules/readable-stream/passthrough.js\");\nvar IllegalOperationError = __webpack_require__(/*! ./error */ \"./node_modules/amqplib/lib/error.js\").IllegalOperationError;\nvar stackCapture = __webpack_require__(/*! ./error */ \"./node_modules/amqplib/lib/error.js\").stackCapture;\n\n// High-water mark for channel write buffers, in 'objects' (which are\n// encoded frames as buffers).\nvar DEFAULT_WRITE_HWM = 1024;\n// If all the frames of a message (method, properties, content) total\n// to less than this, copy them into a single buffer and write it all\n// at once. Note that this is less than the minimum frame size: if it\n// was greater, we might have to fragment the content.\nvar SINGLE_CHUNK_THRESHOLD = 2048;\n\nfunction Connection(underlying) {\n  EventEmitter.call( this );\n  var stream = this.stream = wrapStream(underlying);\n  this.muxer = new Mux(stream);\n\n  // frames\n  this.rest = Buffer.alloc(0);\n  this.frameMax = constants.FRAME_MIN_SIZE;\n  this.sentSinceLastCheck = false;\n  this.recvSinceLastCheck = false;\n\n  this.expectSocketClose = false;\n  this.freeChannels = new BitSet();\n  this.channels = [{channel: {accept: channel0(this)},\n                    buffer: underlying}];\n}\ninherits(Connection, EventEmitter);\n\nvar C = Connection.prototype;\n\n// Usual frame accept mode\nfunction mainAccept(frame) {\n  var rec = this.channels[frame.channel];\n  if (rec) { return rec.channel.accept(frame); }\n  // NB CHANNEL_ERROR may not be right, but I don't know what is ..\n  else\n    this.closeWithError(\n      fmt('Frame on unknown channel %d', frame.channel),\n      constants.CHANNEL_ERROR,\n      new Error(fmt(\"Frame on unknown channel: %s\",\n                    inspect(frame, false))));\n}\n\n// Handle anything that comes through on channel 0, that's the\n// connection control channel. This is only used once mainAccept is\n// installed as the frame handler, after the opening handshake.\nfunction channel0(connection) {\n  return function(f) {\n    // Once we get a 'close', we know 1. we'll get no more frames, and\n    // 2. anything we send except close, or close-ok, will be\n    // ignored. If we already sent 'close', this won't be invoked since\n    // we're already in closing mode; if we didn't well we're not going\n    // to send it now are we.\n    if (f === HEARTBEAT); // ignore; it's already counted as activity\n                          // on the socket, which is its purpose\n    else if (f.id === defs.ConnectionClose) {\n      // Oh. OK. I guess we're done here then.\n      connection.sendMethod(0, defs.ConnectionCloseOk, {});\n      var emsg = fmt('Connection closed: %s', closeMsg(f));\n      var s = stackCapture(emsg);\n      var e = new Error(emsg);\n      e.code = f.fields.replyCode;\n      if (isFatalError(e)) {\n        connection.emit('error', e);\n      }\n      connection.toClosed(s, e);\n    }\n    else if (f.id === defs.ConnectionBlocked) {\n      connection.emit('blocked', f.fields.reason);\n    }\n    else if (f.id === defs.ConnectionUnblocked) {\n      connection.emit('unblocked');\n    }\n    else {\n      connection.closeWithError(\n        fmt(\"Unexpected frame on channel 0\"),\n        constants.UNEXPECTED_FRAME,\n        new Error(fmt(\"Unexpected frame on channel 0: %s\",\n                      inspect(f, false))));\n    }\n  };\n}\n\n// This changed between versions, as did the codec, methods, etc. AMQP\n// 0-9-1 is fairly similar to 0.8, but better, and nothing implements\n// 0.8 that doesn't implement 0-9-1. In other words, it doesn't make\n// much sense to generalise here.\nC.sendProtocolHeader = function() {\n  this.sendBytes(frame.PROTOCOL_HEADER);\n};\n\n/*\n  The frighteningly complicated opening protocol (spec section 2.2.4):\n\n     Client -> Server\n\n       protocol header ->\n         <- start\n       start-ok ->\n     .. next two zero or more times ..\n         <- secure\n       secure-ok ->\n         <- tune\n       tune-ok ->\n       open ->\n         <- open-ok\n\nIf I'm only supporting SASL's PLAIN mechanism (which I am for the time\nbeing), it gets a bit easier since the server won't in general send\nback a `secure`, it'll just send `tune` after the `start-ok`.\n(SASL PLAIN: http://tools.ietf.org/html/rfc4616)\n\n*/\n\nC.open = function(allFields, openCallback0) {\n  var self = this;\n  var openCallback = openCallback0 || function() {};\n\n  // This is where we'll put our negotiated values\n  var tunedOptions = Object.create(allFields);\n\n  function wait(k) {\n    self.step(function(err, frame) {\n      if (err !== null) bail(err);\n      else if (frame.channel !== 0) {\n        bail(new Error(\n          fmt(\"Frame on channel != 0 during handshake: %s\",\n              inspect(frame, false))));\n      }\n      else k(frame);\n    });\n  }\n\n  function expect(Method, k) {\n    wait(function(frame) {\n      if (frame.id === Method) k(frame);\n      else {\n        bail(new Error(\n          fmt(\"Expected %s; got %s\",\n              methodName(Method), inspect(frame, false))));\n      }\n    });\n  }\n\n  function bail(err) {\n    openCallback(err);\n  }\n\n  function send(Method) {\n    // This can throw an exception if there's some problem with the\n    // options; e.g., something is a string instead of a number.\n    try { self.sendMethod(0, Method, tunedOptions); }\n    catch (err) { bail(err); }\n  }\n\n  function negotiate(server, desired) {\n    // We get sent values for channelMax, frameMax and heartbeat,\n    // which we may accept or lower (subject to a minimum for\n    // frameMax, but we'll leave that to the server to enforce). In\n    // all cases, `0` really means \"no limit\", or rather the highest\n    // value in the encoding, e.g., unsigned short for channelMax.\n    if (server === 0 || desired === 0) {\n      // i.e., whichever places a limit, if either\n      return Math.max(server, desired);\n    }\n    else {\n      return Math.min(server, desired);\n    }\n  }\n\n  function onStart(start) {\n    var mechanisms = start.fields.mechanisms.toString().split(' ');\n    if (mechanisms.indexOf(allFields.mechanism) < 0) {\n      bail(new Error(fmt('SASL mechanism %s is not provided by the server',\n                         allFields.mechanism)));\n      return;\n    }\n    send(defs.ConnectionStartOk);\n    wait(afterStartOk);\n  }\n\n  function afterStartOk(reply) {\n    switch (reply.id) {\n    case defs.ConnectionSecure:\n      bail(new Error(\n        \"Wasn't expecting to have to go through secure\"));\n      break;\n    case defs.ConnectionClose:\n      bail(new Error(fmt(\"Handshake terminated by server: %s\",\n                         closeMsg(reply))));\n      break;\n    case defs.ConnectionTune:\n      var fields = reply.fields;\n      tunedOptions.frameMax =\n        negotiate(fields.frameMax, allFields.frameMax);\n      tunedOptions.channelMax =\n        negotiate(fields.channelMax, allFields.channelMax);\n      tunedOptions.heartbeat =\n        negotiate(fields.heartbeat, allFields.heartbeat);\n      send(defs.ConnectionTuneOk);\n      send(defs.ConnectionOpen);\n      expect(defs.ConnectionOpenOk, onOpenOk);\n      break;\n    default:\n      bail(new Error(\n        fmt(\"Expected connection.secure, connection.close, \" +\n            \"or connection.tune during handshake; got %s\",\n            inspect(reply, false))));\n      break;\n    }\n  }\n\n  function onOpenOk(openOk) {\n    // Impose the maximum of the encoded value, if the negotiated\n    // value is zero, meaning \"no, no limits\"\n    self.channelMax = tunedOptions.channelMax || 0xffff;\n    self.frameMax = tunedOptions.frameMax || 0xffffffff;\n    // 0 means \"no heartbeat\", rather than \"maximum period of\n    // heartbeating\"\n    self.heartbeat = tunedOptions.heartbeat;\n    self.heartbeater = self.startHeartbeater();\n    self.accept = mainAccept;\n    succeed(openOk);\n  }\n\n  // If the server closes the connection, it's probably because of\n  // something we did\n  function endWhileOpening(err) {\n    bail(err || new Error('Socket closed abruptly ' +\n                          'during opening handshake'));\n  }\n\n  this.stream.on('end', endWhileOpening);\n  this.stream.on('error', endWhileOpening);\n\n  function succeed(ok) {\n    self.stream.removeListener('end', endWhileOpening);\n    self.stream.removeListener('error', endWhileOpening);\n    self.stream.on('error', self.onSocketError.bind(self));\n    self.stream.on('end', self.onSocketError.bind(\n      self, new Error('Unexpected close')));\n    self.on('frameError', self.onSocketError.bind(self));\n    self.acceptLoop();\n    openCallback(null, ok);\n  }\n\n  // Now kick off the handshake by prompting the server\n  this.sendProtocolHeader();\n  expect(defs.ConnectionStart, onStart);\n};\n\n// Closing things: AMQP has a closing handshake that applies to\n// closing both connects and channels. As the initiating party, I send\n// Close, then ignore all frames until I see either CloseOK --\n// which signifies that the other party has seen the Close and shut\n// the connection or channel down, so it's fine to free resources; or\n// Close, which means the other party also wanted to close the\n// whatever, and I should send CloseOk so it can free resources,\n// then go back to waiting for the CloseOk. If I receive a Close\n// out of the blue, I should throw away any unsent frames (they will\n// be ignored anyway) and send CloseOk, then clean up resources. In\n// general, Close out of the blue signals an error (or a forced\n// closure, which may as well be an error).\n//\n//  RUNNING [1] --- send Close ---> Closing [2] ---> recv Close --+\n//     |                               |                         [3]\n//     |                               +------ send CloseOk ------+\n//  recv Close                   recv CloseOk\n//     |                               |\n//     V                               V\n//  Ended [4] ---- send CloseOk ---> Closed [5]\n//\n// [1] All frames accepted; getting a Close frame from the server\n// moves to Ended; client may initiate a close by sending Close\n// itself.\n// [2] Client has initiated a close; only CloseOk or (simulataneously\n// sent) Close is accepted.\n// [3] Simultaneous close\n// [4] Server won't send any more frames; accept no more frames, send\n// CloseOk.\n// [5] Fully closed, client will send no more, server will send no\n// more. Signal 'close' or 'error'.\n//\n// There are two signalling mechanisms used in the API. The first is\n// that calling `close` will return a promise, that will either\n// resolve once the connection or channel is cleanly shut down, or\n// will reject if the shutdown times out.\n//\n// The second is the 'close' and 'error' events. These are\n// emitted as above. The events will fire *before* promises are\n// resolved.\n\n// Close the connection without even giving a reason. Typical.\nC.close = function(closeCallback) {\n  var k = closeCallback && function() { closeCallback(null); };\n  this.closeBecause(\"Cheers, thanks\", constants.REPLY_SUCCESS, k);\n};\n\n// Close with a reason and a 'code'. I'm pretty sure RabbitMQ totally\n// ignores these; maybe it logs them. The continuation will be invoked\n// when the CloseOk has been received, and before the 'close' event.\nC.closeBecause = function(reason, code, k) {\n  this.sendMethod(0, defs.ConnectionClose, {\n    replyText: reason,\n    replyCode: code,\n    methodId: 0, classId: 0\n  });\n  var s = stackCapture('closeBecause called: ' + reason);\n  this.toClosing(s, k);\n};\n\nC.closeWithError = function(reason, code, error) {\n  this.emit('error', error);\n  this.closeBecause(reason, code);\n};\n\nC.onSocketError = function(err) {\n  if (!this.expectSocketClose) {\n    // forestall any more calls to onSocketError, since we're signed\n    // up for `'error'` *and* `'end'`\n    this.expectSocketClose = true;\n    this.emit('error', err);\n    var s = stackCapture('Socket error');\n    this.toClosed(s, err);\n  }\n};\n\nfunction invalidOp(msg, stack) {\n  return function() {\n    throw new IllegalOperationError(msg, stack);\n  };\n}\n\nfunction invalidateSend(conn, msg, stack) {\n  conn.sendMethod = conn.sendContent = conn.sendMessage =\n    invalidOp(msg, stack);\n}\n\n// A close has been initiated. Repeat: a close has been initiated.\n// This means we should not send more frames, anyway they will be\n// ignored. We also have to shut down all the channels.\nC.toClosing = function(capturedStack, k) {\n  var send = this.sendMethod.bind(this);\n\n  this.accept = function(f) {\n    if (f.id === defs.ConnectionCloseOk) {\n      if (k) k();\n      var s = stackCapture('ConnectionCloseOk received');\n      this.toClosed(s, undefined);\n    }\n    else if (f.id === defs.ConnectionClose) {\n      send(0, defs.ConnectionCloseOk, {});\n    }\n    // else ignore frame\n  };\n  invalidateSend(this, 'Connection closing', capturedStack);\n};\n\nC._closeChannels = function(capturedStack) {\n  for (var i = 1; i < this.channels.length; i++) {\n    var ch = this.channels[i];\n    if (ch !== null) {\n      ch.channel.toClosed(capturedStack); // %%% or with an error? not clear\n    }\n  }\n};\n\n// A close has been confirmed. Cease all communication.\nC.toClosed = function(capturedStack, maybeErr) {\n  this._closeChannels(capturedStack);\n  var info = fmt('Connection closed (%s)',\n                 (maybeErr) ? maybeErr.toString() : 'by client');\n  // Tidy up, invalidate enverything, dynamite the bridges.\n  invalidateSend(this, info, capturedStack);\n  this.accept = invalidOp(info, capturedStack);\n  this.close = function(cb) {\n    cb && cb(new IllegalOperationError(info, capturedStack));\n  };\n  if (this.heartbeater) this.heartbeater.clear();\n  // This is certainly true now, if it wasn't before\n  this.expectSocketClose = true;\n  this.stream.end();\n  this.emit('close', maybeErr);\n};\n\n// ===\n\nC.startHeartbeater = function() {\n  if (this.heartbeat === 0) return null;\n  else {\n    var self = this;\n    var hb = new Heart(this.heartbeat,\n                       this.checkSend.bind(this),\n                       this.checkRecv.bind(this));\n    hb.on('timeout', function() {\n      var hberr = new Error(\"Heartbeat timeout\");\n      self.emit('error', hberr);\n      var s = stackCapture('Heartbeat timeout');\n      self.toClosed(s, hberr);\n    });\n    hb.on('beat', function() {\n      self.sendHeartbeat();\n    });\n    return hb;\n  }\n};\n\n// I use an array to keep track of the channels, rather than an\n// object. The channel identifiers are numbers, and allocated by the\n// connection. If I try to allocate low numbers when they are\n// available (which I do, by looking from the start of the bitset),\n// this ought to keep the array small, and out of 'sparse array\n// storage'. I also set entries to null, rather than deleting them, in\n// the expectation that the next channel allocation will fill the slot\n// again rather than growing the array. See\n// http://www.html5rocks.com/en/tutorials/speed/v8/\nC.freshChannel = function(channel, options) {\n  var next = this.freeChannels.nextClearBit(1);\n  if (next < 0 || next > this.channelMax)\n    throw new Error(\"No channels left to allocate\");\n  this.freeChannels.set(next);\n\n  var hwm = (options && options.highWaterMark) || DEFAULT_WRITE_HWM;\n  var writeBuffer = new PassThrough({\n    objectMode: true, highWaterMark: hwm\n  });\n  this.channels[next] = {channel: channel, buffer: writeBuffer};\n  writeBuffer.on('drain', function() {\n    channel.onBufferDrain();\n  });\n  this.muxer.pipeFrom(writeBuffer);\n  return next;\n};\n\nC.releaseChannel = function(channel) {\n  this.freeChannels.clear(channel);\n  var buffer = this.channels[channel].buffer;\n  this.muxer.unpipeFrom(buffer);\n  this.channels[channel] = null;\n};\n\nC.acceptLoop = function() {\n  var self = this;\n\n  function go() {\n    try {\n      var f; while (f = self.recvFrame()) self.accept(f);\n    }\n    catch (e) {\n      self.emit('frameError', e);\n    }\n  }\n  self.stream.on('readable', go);\n  go();\n};\n\nC.step = function(cb) {\n  var self = this;\n  function recv() {\n    var f;\n    try {\n      f = self.recvFrame();\n    }\n    catch (e) {\n      cb(e, null);\n      return;\n    }\n    if (f) cb(null, f);\n    else self.stream.once('readable', recv);\n  }\n  recv();\n};\n\nC.checkSend = function() {\n  var check = this.sentSinceLastCheck;\n  this.sentSinceLastCheck = false;\n  return check;\n}\n\nC.checkRecv = function() {\n  var check = this.recvSinceLastCheck;\n  this.recvSinceLastCheck = false;\n  return check;\n}\n\nC.sendBytes = function(bytes) {\n  this.sentSinceLastCheck = true;\n  this.stream.write(bytes);\n};\n\nC.sendHeartbeat = function() {\n  return this.sendBytes(frame.HEARTBEAT_BUF);\n};\n\nvar encodeMethod = defs.encodeMethod;\nvar encodeProperties = defs.encodeProperties;\n\nC.sendMethod = function(channel, Method, fields) {\n  var frame = encodeMethod(Method, channel, fields);\n  this.sentSinceLastCheck = true;\n  var buffer = this.channels[channel].buffer;\n  return buffer.write(frame);\n};\n\nC.sendMessage = function(channel,\n                         Method, fields,\n                         Properties, props,\n                         content) {\n  if (!Buffer.isBuffer(content))\n    throw new TypeError('content is not a buffer');\n\n  var mframe = encodeMethod(Method, channel, fields);\n  var pframe = encodeProperties(Properties, channel,\n                                content.length, props);\n  var buffer = this.channels[channel].buffer;\n  this.sentSinceLastCheck = true;\n\n  var methodHeaderLen = mframe.length + pframe.length;\n  var bodyLen = (content.length > 0) ?\n    content.length + FRAME_OVERHEAD : 0;\n  var allLen = methodHeaderLen + bodyLen;\n\n  if (allLen < SINGLE_CHUNK_THRESHOLD) {\n    var all = Buffer.alloc(allLen);\n    var offset = mframe.copy(all, 0);\n    offset += pframe.copy(all, offset);\n\n    if (bodyLen > 0)\n      makeBodyFrame(channel, content).copy(all, offset);\n    return buffer.write(all);\n  }\n  else {\n    if (methodHeaderLen < SINGLE_CHUNK_THRESHOLD) {\n      var both = Buffer.alloc(methodHeaderLen);\n      var offset = mframe.copy(both, 0);\n      pframe.copy(both, offset);\n      buffer.write(both);\n    }\n    else {\n      buffer.write(mframe);\n      buffer.write(pframe);\n    }\n    return this.sendContent(channel, content);\n  }\n};\n\nvar FRAME_OVERHEAD = defs.FRAME_OVERHEAD;\nvar makeBodyFrame = frame.makeBodyFrame;\n\nC.sendContent = function(channel, body) {\n  if (!Buffer.isBuffer(body)) {\n    throw new TypeError(fmt(\"Expected buffer; got %s\", body));\n  }\n  var writeResult = true;\n  var buffer = this.channels[channel].buffer;\n\n  var maxBody = this.frameMax - FRAME_OVERHEAD;\n\n  for (var offset = 0; offset < body.length; offset += maxBody) {\n    var end = offset + maxBody;\n    var slice = (end > body.length) ? body.slice(offset) : body.slice(offset, end);\n    var bodyFrame = makeBodyFrame(channel, slice);\n    writeResult = buffer.write(bodyFrame);\n  }\n  this.sentSinceLastCheck = true;\n  return writeResult;\n};\n\nvar parseFrame = frame.parseFrame;\nvar decodeFrame = frame.decodeFrame;\n\nC.recvFrame = function() {\n  // %%% identifying invariants might help here?\n  var frame = parseFrame(this.rest, this.frameMax);\n\n  if (!frame) {\n    var incoming = this.stream.read();\n    if (incoming === null) {\n      return false;\n    }\n    else {\n      this.recvSinceLastCheck = true;\n      this.rest = Buffer.concat([this.rest, incoming]);\n      return this.recvFrame();\n    }\n  }\n  else {\n    this.rest = frame.rest;\n    return decodeFrame(frame);\n  }\n};\n\nfunction wrapStream(s) {\n  if (s instanceof Duplex) return s;\n  else {\n    var ws = new Duplex();\n    ws.wrap(s); //wraps the readable side of things\n    ws._write = function(chunk, encoding, callback) {\n      return s.write(chunk, encoding, callback);\n    };\n    return ws;\n  }\n}\n\nfunction isFatalError(error) {\n  switch (error && error.code) {\n  case defs.constants.CONNECTION_FORCED:\n  case defs.constants.REPLY_SUCCESS:\n    return false;\n  default:\n    return true;\n  }\n}\n\nmodule.exports.Connection = Connection;\nmodule.exports.isFatalError = isFatalError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY29ubmVjdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9jb25uZWN0aW9uLmpzPzhkOTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vXG4vL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZzID0gcmVxdWlyZSgnLi9kZWZzJyk7XG52YXIgY29uc3RhbnRzID0gZGVmcy5jb25zdGFudHM7XG52YXIgZnJhbWUgPSByZXF1aXJlKCcuL2ZyYW1lJyk7XG52YXIgSEVBUlRCRUFUID0gZnJhbWUuSEVBUlRCRUFUO1xudmFyIE11eCA9IHJlcXVpcmUoJy4vbXV4JykuTXV4O1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBEdXBsZXggPVxuICByZXF1aXJlKCdzdHJlYW0nKS5EdXBsZXggfHxcbiAgcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBIZWFydCA9IHJlcXVpcmUoJy4vaGVhcnRiZWF0JykuSGVhcnQ7XG5cbnZhciBtZXRob2ROYW1lID0gcmVxdWlyZSgnLi9mb3JtYXQnKS5tZXRob2ROYW1lO1xudmFyIGNsb3NlTXNnID0gcmVxdWlyZSgnLi9mb3JtYXQnKS5jbG9zZU1lc3NhZ2U7XG52YXIgaW5zcGVjdCA9IHJlcXVpcmUoJy4vZm9ybWF0JykuaW5zcGVjdDtcblxudmFyIEJpdFNldCA9IHJlcXVpcmUoJy4vYml0c2V0JykuQml0U2V0O1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIGZtdCA9IHJlcXVpcmUoJ3V0aWwnKS5mb3JtYXQ7XG52YXIgUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdzdHJlYW0nKS5QYXNzVGhyb3VnaCB8fFxuICByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2gnKTtcbnZhciBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJykuSWxsZWdhbE9wZXJhdGlvbkVycm9yO1xudmFyIHN0YWNrQ2FwdHVyZSA9IHJlcXVpcmUoJy4vZXJyb3InKS5zdGFja0NhcHR1cmU7XG5cbi8vIEhpZ2gtd2F0ZXIgbWFyayBmb3IgY2hhbm5lbCB3cml0ZSBidWZmZXJzLCBpbiAnb2JqZWN0cycgKHdoaWNoIGFyZVxuLy8gZW5jb2RlZCBmcmFtZXMgYXMgYnVmZmVycykuXG52YXIgREVGQVVMVF9XUklURV9IV00gPSAxMDI0O1xuLy8gSWYgYWxsIHRoZSBmcmFtZXMgb2YgYSBtZXNzYWdlIChtZXRob2QsIHByb3BlcnRpZXMsIGNvbnRlbnQpIHRvdGFsXG4vLyB0byBsZXNzIHRoYW4gdGhpcywgY29weSB0aGVtIGludG8gYSBzaW5nbGUgYnVmZmVyIGFuZCB3cml0ZSBpdCBhbGxcbi8vIGF0IG9uY2UuIE5vdGUgdGhhdCB0aGlzIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBmcmFtZSBzaXplOiBpZiBpdFxuLy8gd2FzIGdyZWF0ZXIsIHdlIG1pZ2h0IGhhdmUgdG8gZnJhZ21lbnQgdGhlIGNvbnRlbnQuXG52YXIgU0lOR0xFX0NIVU5LX1RIUkVTSE9MRCA9IDIwNDg7XG5cbmZ1bmN0aW9uIENvbm5lY3Rpb24odW5kZXJseWluZykge1xuICBFdmVudEVtaXR0ZXIuY2FsbCggdGhpcyApO1xuICB2YXIgc3RyZWFtID0gdGhpcy5zdHJlYW0gPSB3cmFwU3RyZWFtKHVuZGVybHlpbmcpO1xuICB0aGlzLm11eGVyID0gbmV3IE11eChzdHJlYW0pO1xuXG4gIC8vIGZyYW1lc1xuICB0aGlzLnJlc3QgPSBCdWZmZXIuYWxsb2MoMCk7XG4gIHRoaXMuZnJhbWVNYXggPSBjb25zdGFudHMuRlJBTUVfTUlOX1NJWkU7XG4gIHRoaXMuc2VudFNpbmNlTGFzdENoZWNrID0gZmFsc2U7XG4gIHRoaXMucmVjdlNpbmNlTGFzdENoZWNrID0gZmFsc2U7XG5cbiAgdGhpcy5leHBlY3RTb2NrZXRDbG9zZSA9IGZhbHNlO1xuICB0aGlzLmZyZWVDaGFubmVscyA9IG5ldyBCaXRTZXQoKTtcbiAgdGhpcy5jaGFubmVscyA9IFt7Y2hhbm5lbDoge2FjY2VwdDogY2hhbm5lbDAodGhpcyl9LFxuICAgICAgICAgICAgICAgICAgICBidWZmZXI6IHVuZGVybHlpbmd9XTtcbn1cbmluaGVyaXRzKENvbm5lY3Rpb24sIEV2ZW50RW1pdHRlcik7XG5cbnZhciBDID0gQ29ubmVjdGlvbi5wcm90b3R5cGU7XG5cbi8vIFVzdWFsIGZyYW1lIGFjY2VwdCBtb2RlXG5mdW5jdGlvbiBtYWluQWNjZXB0KGZyYW1lKSB7XG4gIHZhciByZWMgPSB0aGlzLmNoYW5uZWxzW2ZyYW1lLmNoYW5uZWxdO1xuICBpZiAocmVjKSB7IHJldHVybiByZWMuY2hhbm5lbC5hY2NlcHQoZnJhbWUpOyB9XG4gIC8vIE5CIENIQU5ORUxfRVJST1IgbWF5IG5vdCBiZSByaWdodCwgYnV0IEkgZG9uJ3Qga25vdyB3aGF0IGlzIC4uXG4gIGVsc2VcbiAgICB0aGlzLmNsb3NlV2l0aEVycm9yKFxuICAgICAgZm10KCdGcmFtZSBvbiB1bmtub3duIGNoYW5uZWwgJWQnLCBmcmFtZS5jaGFubmVsKSxcbiAgICAgIGNvbnN0YW50cy5DSEFOTkVMX0VSUk9SLFxuICAgICAgbmV3IEVycm9yKGZtdChcIkZyYW1lIG9uIHVua25vd24gY2hhbm5lbDogJXNcIixcbiAgICAgICAgICAgICAgICAgICAgaW5zcGVjdChmcmFtZSwgZmFsc2UpKSkpO1xufVxuXG4vLyBIYW5kbGUgYW55dGhpbmcgdGhhdCBjb21lcyB0aHJvdWdoIG9uIGNoYW5uZWwgMCwgdGhhdCdzIHRoZVxuLy8gY29ubmVjdGlvbiBjb250cm9sIGNoYW5uZWwuIFRoaXMgaXMgb25seSB1c2VkIG9uY2UgbWFpbkFjY2VwdCBpc1xuLy8gaW5zdGFsbGVkIGFzIHRoZSBmcmFtZSBoYW5kbGVyLCBhZnRlciB0aGUgb3BlbmluZyBoYW5kc2hha2UuXG5mdW5jdGlvbiBjaGFubmVsMChjb25uZWN0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgLy8gT25jZSB3ZSBnZXQgYSAnY2xvc2UnLCB3ZSBrbm93IDEuIHdlJ2xsIGdldCBubyBtb3JlIGZyYW1lcywgYW5kXG4gICAgLy8gMi4gYW55dGhpbmcgd2Ugc2VuZCBleGNlcHQgY2xvc2UsIG9yIGNsb3NlLW9rLCB3aWxsIGJlXG4gICAgLy8gaWdub3JlZC4gSWYgd2UgYWxyZWFkeSBzZW50ICdjbG9zZScsIHRoaXMgd29uJ3QgYmUgaW52b2tlZCBzaW5jZVxuICAgIC8vIHdlJ3JlIGFscmVhZHkgaW4gY2xvc2luZyBtb2RlOyBpZiB3ZSBkaWRuJ3Qgd2VsbCB3ZSdyZSBub3QgZ29pbmdcbiAgICAvLyB0byBzZW5kIGl0IG5vdyBhcmUgd2UuXG4gICAgaWYgKGYgPT09IEhFQVJUQkVBVCk7IC8vIGlnbm9yZTsgaXQncyBhbHJlYWR5IGNvdW50ZWQgYXMgYWN0aXZpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gdGhlIHNvY2tldCwgd2hpY2ggaXMgaXRzIHB1cnBvc2VcbiAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkNvbm5lY3Rpb25DbG9zZSkge1xuICAgICAgLy8gT2guIE9LLiBJIGd1ZXNzIHdlJ3JlIGRvbmUgaGVyZSB0aGVuLlxuICAgICAgY29ubmVjdGlvbi5zZW5kTWV0aG9kKDAsIGRlZnMuQ29ubmVjdGlvbkNsb3NlT2ssIHt9KTtcbiAgICAgIHZhciBlbXNnID0gZm10KCdDb25uZWN0aW9uIGNsb3NlZDogJXMnLCBjbG9zZU1zZyhmKSk7XG4gICAgICB2YXIgcyA9IHN0YWNrQ2FwdHVyZShlbXNnKTtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKGVtc2cpO1xuICAgICAgZS5jb2RlID0gZi5maWVsZHMucmVwbHlDb2RlO1xuICAgICAgaWYgKGlzRmF0YWxFcnJvcihlKSkge1xuICAgICAgICBjb25uZWN0aW9uLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICB9XG4gICAgICBjb25uZWN0aW9uLnRvQ2xvc2VkKHMsIGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkNvbm5lY3Rpb25CbG9ja2VkKSB7XG4gICAgICBjb25uZWN0aW9uLmVtaXQoJ2Jsb2NrZWQnLCBmLmZpZWxkcy5yZWFzb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkNvbm5lY3Rpb25VbmJsb2NrZWQpIHtcbiAgICAgIGNvbm5lY3Rpb24uZW1pdCgndW5ibG9ja2VkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29ubmVjdGlvbi5jbG9zZVdpdGhFcnJvcihcbiAgICAgICAgZm10KFwiVW5leHBlY3RlZCBmcmFtZSBvbiBjaGFubmVsIDBcIiksXG4gICAgICAgIGNvbnN0YW50cy5VTkVYUEVDVEVEX0ZSQU1FLFxuICAgICAgICBuZXcgRXJyb3IoZm10KFwiVW5leHBlY3RlZCBmcmFtZSBvbiBjaGFubmVsIDA6ICVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaW5zcGVjdChmLCBmYWxzZSkpKSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBUaGlzIGNoYW5nZWQgYmV0d2VlbiB2ZXJzaW9ucywgYXMgZGlkIHRoZSBjb2RlYywgbWV0aG9kcywgZXRjLiBBTVFQXG4vLyAwLTktMSBpcyBmYWlybHkgc2ltaWxhciB0byAwLjgsIGJ1dCBiZXR0ZXIsIGFuZCBub3RoaW5nIGltcGxlbWVudHNcbi8vIDAuOCB0aGF0IGRvZXNuJ3QgaW1wbGVtZW50IDAtOS0xLiBJbiBvdGhlciB3b3JkcywgaXQgZG9lc24ndCBtYWtlXG4vLyBtdWNoIHNlbnNlIHRvIGdlbmVyYWxpc2UgaGVyZS5cbkMuc2VuZFByb3RvY29sSGVhZGVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2VuZEJ5dGVzKGZyYW1lLlBST1RPQ09MX0hFQURFUik7XG59O1xuXG4vKlxuICBUaGUgZnJpZ2h0ZW5pbmdseSBjb21wbGljYXRlZCBvcGVuaW5nIHByb3RvY29sIChzcGVjIHNlY3Rpb24gMi4yLjQpOlxuXG4gICAgIENsaWVudCAtPiBTZXJ2ZXJcblxuICAgICAgIHByb3RvY29sIGhlYWRlciAtPlxuICAgICAgICAgPC0gc3RhcnRcbiAgICAgICBzdGFydC1vayAtPlxuICAgICAuLiBuZXh0IHR3byB6ZXJvIG9yIG1vcmUgdGltZXMgLi5cbiAgICAgICAgIDwtIHNlY3VyZVxuICAgICAgIHNlY3VyZS1vayAtPlxuICAgICAgICAgPC0gdHVuZVxuICAgICAgIHR1bmUtb2sgLT5cbiAgICAgICBvcGVuIC0+XG4gICAgICAgICA8LSBvcGVuLW9rXG5cbklmIEknbSBvbmx5IHN1cHBvcnRpbmcgU0FTTCdzIFBMQUlOIG1lY2hhbmlzbSAod2hpY2ggSSBhbSBmb3IgdGhlIHRpbWVcbmJlaW5nKSwgaXQgZ2V0cyBhIGJpdCBlYXNpZXIgc2luY2UgdGhlIHNlcnZlciB3b24ndCBpbiBnZW5lcmFsIHNlbmRcbmJhY2sgYSBgc2VjdXJlYCwgaXQnbGwganVzdCBzZW5kIGB0dW5lYCBhZnRlciB0aGUgYHN0YXJ0LW9rYC5cbihTQVNMIFBMQUlOOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0NjE2KVxuXG4qL1xuXG5DLm9wZW4gPSBmdW5jdGlvbihhbGxGaWVsZHMsIG9wZW5DYWxsYmFjazApIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgb3BlbkNhbGxiYWNrID0gb3BlbkNhbGxiYWNrMCB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIC8vIFRoaXMgaXMgd2hlcmUgd2UnbGwgcHV0IG91ciBuZWdvdGlhdGVkIHZhbHVlc1xuICB2YXIgdHVuZWRPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShhbGxGaWVsZHMpO1xuXG4gIGZ1bmN0aW9uIHdhaXQoaykge1xuICAgIHNlbGYuc3RlcChmdW5jdGlvbihlcnIsIGZyYW1lKSB7XG4gICAgICBpZiAoZXJyICE9PSBudWxsKSBiYWlsKGVycik7XG4gICAgICBlbHNlIGlmIChmcmFtZS5jaGFubmVsICE9PSAwKSB7XG4gICAgICAgIGJhaWwobmV3IEVycm9yKFxuICAgICAgICAgIGZtdChcIkZyYW1lIG9uIGNoYW5uZWwgIT0gMCBkdXJpbmcgaGFuZHNoYWtlOiAlc1wiLFxuICAgICAgICAgICAgICBpbnNwZWN0KGZyYW1lLCBmYWxzZSkpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIGsoZnJhbWUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwZWN0KE1ldGhvZCwgaykge1xuICAgIHdhaXQoZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgIGlmIChmcmFtZS5pZCA9PT0gTWV0aG9kKSBrKGZyYW1lKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBiYWlsKG5ldyBFcnJvcihcbiAgICAgICAgICBmbXQoXCJFeHBlY3RlZCAlczsgZ290ICVzXCIsXG4gICAgICAgICAgICAgIG1ldGhvZE5hbWUoTWV0aG9kKSwgaW5zcGVjdChmcmFtZSwgZmFsc2UpKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYmFpbChlcnIpIHtcbiAgICBvcGVuQ2FsbGJhY2soZXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbmQoTWV0aG9kKSB7XG4gICAgLy8gVGhpcyBjYW4gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZXJlJ3Mgc29tZSBwcm9ibGVtIHdpdGggdGhlXG4gICAgLy8gb3B0aW9uczsgZS5nLiwgc29tZXRoaW5nIGlzIGEgc3RyaW5nIGluc3RlYWQgb2YgYSBudW1iZXIuXG4gICAgdHJ5IHsgc2VsZi5zZW5kTWV0aG9kKDAsIE1ldGhvZCwgdHVuZWRPcHRpb25zKTsgfVxuICAgIGNhdGNoIChlcnIpIHsgYmFpbChlcnIpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBuZWdvdGlhdGUoc2VydmVyLCBkZXNpcmVkKSB7XG4gICAgLy8gV2UgZ2V0IHNlbnQgdmFsdWVzIGZvciBjaGFubmVsTWF4LCBmcmFtZU1heCBhbmQgaGVhcnRiZWF0LFxuICAgIC8vIHdoaWNoIHdlIG1heSBhY2NlcHQgb3IgbG93ZXIgKHN1YmplY3QgdG8gYSBtaW5pbXVtIGZvclxuICAgIC8vIGZyYW1lTWF4LCBidXQgd2UnbGwgbGVhdmUgdGhhdCB0byB0aGUgc2VydmVyIHRvIGVuZm9yY2UpLiBJblxuICAgIC8vIGFsbCBjYXNlcywgYDBgIHJlYWxseSBtZWFucyBcIm5vIGxpbWl0XCIsIG9yIHJhdGhlciB0aGUgaGlnaGVzdFxuICAgIC8vIHZhbHVlIGluIHRoZSBlbmNvZGluZywgZS5nLiwgdW5zaWduZWQgc2hvcnQgZm9yIGNoYW5uZWxNYXguXG4gICAgaWYgKHNlcnZlciA9PT0gMCB8fCBkZXNpcmVkID09PSAwKSB7XG4gICAgICAvLyBpLmUuLCB3aGljaGV2ZXIgcGxhY2VzIGEgbGltaXQsIGlmIGVpdGhlclxuICAgICAgcmV0dXJuIE1hdGgubWF4KHNlcnZlciwgZGVzaXJlZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgubWluKHNlcnZlciwgZGVzaXJlZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25TdGFydChzdGFydCkge1xuICAgIHZhciBtZWNoYW5pc21zID0gc3RhcnQuZmllbGRzLm1lY2hhbmlzbXMudG9TdHJpbmcoKS5zcGxpdCgnICcpO1xuICAgIGlmIChtZWNoYW5pc21zLmluZGV4T2YoYWxsRmllbGRzLm1lY2hhbmlzbSkgPCAwKSB7XG4gICAgICBiYWlsKG5ldyBFcnJvcihmbXQoJ1NBU0wgbWVjaGFuaXNtICVzIGlzIG5vdCBwcm92aWRlZCBieSB0aGUgc2VydmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhbGxGaWVsZHMubWVjaGFuaXNtKSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZW5kKGRlZnMuQ29ubmVjdGlvblN0YXJ0T2spO1xuICAgIHdhaXQoYWZ0ZXJTdGFydE9rKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyU3RhcnRPayhyZXBseSkge1xuICAgIHN3aXRjaCAocmVwbHkuaWQpIHtcbiAgICBjYXNlIGRlZnMuQ29ubmVjdGlvblNlY3VyZTpcbiAgICAgIGJhaWwobmV3IEVycm9yKFxuICAgICAgICBcIldhc24ndCBleHBlY3RpbmcgdG8gaGF2ZSB0byBnbyB0aHJvdWdoIHNlY3VyZVwiKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGRlZnMuQ29ubmVjdGlvbkNsb3NlOlxuICAgICAgYmFpbChuZXcgRXJyb3IoZm10KFwiSGFuZHNoYWtlIHRlcm1pbmF0ZWQgYnkgc2VydmVyOiAlc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlTXNnKHJlcGx5KSkpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZGVmcy5Db25uZWN0aW9uVHVuZTpcbiAgICAgIHZhciBmaWVsZHMgPSByZXBseS5maWVsZHM7XG4gICAgICB0dW5lZE9wdGlvbnMuZnJhbWVNYXggPVxuICAgICAgICBuZWdvdGlhdGUoZmllbGRzLmZyYW1lTWF4LCBhbGxGaWVsZHMuZnJhbWVNYXgpO1xuICAgICAgdHVuZWRPcHRpb25zLmNoYW5uZWxNYXggPVxuICAgICAgICBuZWdvdGlhdGUoZmllbGRzLmNoYW5uZWxNYXgsIGFsbEZpZWxkcy5jaGFubmVsTWF4KTtcbiAgICAgIHR1bmVkT3B0aW9ucy5oZWFydGJlYXQgPVxuICAgICAgICBuZWdvdGlhdGUoZmllbGRzLmhlYXJ0YmVhdCwgYWxsRmllbGRzLmhlYXJ0YmVhdCk7XG4gICAgICBzZW5kKGRlZnMuQ29ubmVjdGlvblR1bmVPayk7XG4gICAgICBzZW5kKGRlZnMuQ29ubmVjdGlvbk9wZW4pO1xuICAgICAgZXhwZWN0KGRlZnMuQ29ubmVjdGlvbk9wZW5Paywgb25PcGVuT2spO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJhaWwobmV3IEVycm9yKFxuICAgICAgICBmbXQoXCJFeHBlY3RlZCBjb25uZWN0aW9uLnNlY3VyZSwgY29ubmVjdGlvbi5jbG9zZSwgXCIgK1xuICAgICAgICAgICAgXCJvciBjb25uZWN0aW9uLnR1bmUgZHVyaW5nIGhhbmRzaGFrZTsgZ290ICVzXCIsXG4gICAgICAgICAgICBpbnNwZWN0KHJlcGx5LCBmYWxzZSkpKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk9wZW5PayhvcGVuT2spIHtcbiAgICAvLyBJbXBvc2UgdGhlIG1heGltdW0gb2YgdGhlIGVuY29kZWQgdmFsdWUsIGlmIHRoZSBuZWdvdGlhdGVkXG4gICAgLy8gdmFsdWUgaXMgemVybywgbWVhbmluZyBcIm5vLCBubyBsaW1pdHNcIlxuICAgIHNlbGYuY2hhbm5lbE1heCA9IHR1bmVkT3B0aW9ucy5jaGFubmVsTWF4IHx8IDB4ZmZmZjtcbiAgICBzZWxmLmZyYW1lTWF4ID0gdHVuZWRPcHRpb25zLmZyYW1lTWF4IHx8IDB4ZmZmZmZmZmY7XG4gICAgLy8gMCBtZWFucyBcIm5vIGhlYXJ0YmVhdFwiLCByYXRoZXIgdGhhbiBcIm1heGltdW0gcGVyaW9kIG9mXG4gICAgLy8gaGVhcnRiZWF0aW5nXCJcbiAgICBzZWxmLmhlYXJ0YmVhdCA9IHR1bmVkT3B0aW9ucy5oZWFydGJlYXQ7XG4gICAgc2VsZi5oZWFydGJlYXRlciA9IHNlbGYuc3RhcnRIZWFydGJlYXRlcigpO1xuICAgIHNlbGYuYWNjZXB0ID0gbWFpbkFjY2VwdDtcbiAgICBzdWNjZWVkKG9wZW5Payk7XG4gIH1cblxuICAvLyBJZiB0aGUgc2VydmVyIGNsb3NlcyB0aGUgY29ubmVjdGlvbiwgaXQncyBwcm9iYWJseSBiZWNhdXNlIG9mXG4gIC8vIHNvbWV0aGluZyB3ZSBkaWRcbiAgZnVuY3Rpb24gZW5kV2hpbGVPcGVuaW5nKGVycikge1xuICAgIGJhaWwoZXJyIHx8IG5ldyBFcnJvcignU29ja2V0IGNsb3NlZCBhYnJ1cHRseSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2R1cmluZyBvcGVuaW5nIGhhbmRzaGFrZScpKTtcbiAgfVxuXG4gIHRoaXMuc3RyZWFtLm9uKCdlbmQnLCBlbmRXaGlsZU9wZW5pbmcpO1xuICB0aGlzLnN0cmVhbS5vbignZXJyb3InLCBlbmRXaGlsZU9wZW5pbmcpO1xuXG4gIGZ1bmN0aW9uIHN1Y2NlZWQob2spIHtcbiAgICBzZWxmLnN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgZW5kV2hpbGVPcGVuaW5nKTtcbiAgICBzZWxmLnN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlbmRXaGlsZU9wZW5pbmcpO1xuICAgIHNlbGYuc3RyZWFtLm9uKCdlcnJvcicsIHNlbGYub25Tb2NrZXRFcnJvci5iaW5kKHNlbGYpKTtcbiAgICBzZWxmLnN0cmVhbS5vbignZW5kJywgc2VsZi5vblNvY2tldEVycm9yLmJpbmQoXG4gICAgICBzZWxmLCBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY2xvc2UnKSkpO1xuICAgIHNlbGYub24oJ2ZyYW1lRXJyb3InLCBzZWxmLm9uU29ja2V0RXJyb3IuYmluZChzZWxmKSk7XG4gICAgc2VsZi5hY2NlcHRMb29wKCk7XG4gICAgb3BlbkNhbGxiYWNrKG51bGwsIG9rKTtcbiAgfVxuXG4gIC8vIE5vdyBraWNrIG9mZiB0aGUgaGFuZHNoYWtlIGJ5IHByb21wdGluZyB0aGUgc2VydmVyXG4gIHRoaXMuc2VuZFByb3RvY29sSGVhZGVyKCk7XG4gIGV4cGVjdChkZWZzLkNvbm5lY3Rpb25TdGFydCwgb25TdGFydCk7XG59O1xuXG4vLyBDbG9zaW5nIHRoaW5nczogQU1RUCBoYXMgYSBjbG9zaW5nIGhhbmRzaGFrZSB0aGF0IGFwcGxpZXMgdG9cbi8vIGNsb3NpbmcgYm90aCBjb25uZWN0cyBhbmQgY2hhbm5lbHMuIEFzIHRoZSBpbml0aWF0aW5nIHBhcnR5LCBJIHNlbmRcbi8vIENsb3NlLCB0aGVuIGlnbm9yZSBhbGwgZnJhbWVzIHVudGlsIEkgc2VlIGVpdGhlciBDbG9zZU9LIC0tXG4vLyB3aGljaCBzaWduaWZpZXMgdGhhdCB0aGUgb3RoZXIgcGFydHkgaGFzIHNlZW4gdGhlIENsb3NlIGFuZCBzaHV0XG4vLyB0aGUgY29ubmVjdGlvbiBvciBjaGFubmVsIGRvd24sIHNvIGl0J3MgZmluZSB0byBmcmVlIHJlc291cmNlczsgb3Jcbi8vIENsb3NlLCB3aGljaCBtZWFucyB0aGUgb3RoZXIgcGFydHkgYWxzbyB3YW50ZWQgdG8gY2xvc2UgdGhlXG4vLyB3aGF0ZXZlciwgYW5kIEkgc2hvdWxkIHNlbmQgQ2xvc2VPayBzbyBpdCBjYW4gZnJlZSByZXNvdXJjZXMsXG4vLyB0aGVuIGdvIGJhY2sgdG8gd2FpdGluZyBmb3IgdGhlIENsb3NlT2suIElmIEkgcmVjZWl2ZSBhIENsb3NlXG4vLyBvdXQgb2YgdGhlIGJsdWUsIEkgc2hvdWxkIHRocm93IGF3YXkgYW55IHVuc2VudCBmcmFtZXMgKHRoZXkgd2lsbFxuLy8gYmUgaWdub3JlZCBhbnl3YXkpIGFuZCBzZW5kIENsb3NlT2ssIHRoZW4gY2xlYW4gdXAgcmVzb3VyY2VzLiBJblxuLy8gZ2VuZXJhbCwgQ2xvc2Ugb3V0IG9mIHRoZSBibHVlIHNpZ25hbHMgYW4gZXJyb3IgKG9yIGEgZm9yY2VkXG4vLyBjbG9zdXJlLCB3aGljaCBtYXkgYXMgd2VsbCBiZSBhbiBlcnJvcikuXG4vL1xuLy8gIFJVTk5JTkcgWzFdIC0tLSBzZW5kIENsb3NlIC0tLT4gQ2xvc2luZyBbMl0gLS0tPiByZWN2IENsb3NlIC0tK1xuLy8gICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICBbM11cbi8vICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0gc2VuZCBDbG9zZU9rIC0tLS0tLStcbi8vICByZWN2IENsb3NlICAgICAgICAgICAgICAgICAgIHJlY3YgQ2xvc2VPa1xuLy8gICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gICAgIFYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVlxuLy8gIEVuZGVkIFs0XSAtLS0tIHNlbmQgQ2xvc2VPayAtLS0+IENsb3NlZCBbNV1cbi8vXG4vLyBbMV0gQWxsIGZyYW1lcyBhY2NlcHRlZDsgZ2V0dGluZyBhIENsb3NlIGZyYW1lIGZyb20gdGhlIHNlcnZlclxuLy8gbW92ZXMgdG8gRW5kZWQ7IGNsaWVudCBtYXkgaW5pdGlhdGUgYSBjbG9zZSBieSBzZW5kaW5nIENsb3NlXG4vLyBpdHNlbGYuXG4vLyBbMl0gQ2xpZW50IGhhcyBpbml0aWF0ZWQgYSBjbG9zZTsgb25seSBDbG9zZU9rIG9yIChzaW11bGF0YW5lb3VzbHlcbi8vIHNlbnQpIENsb3NlIGlzIGFjY2VwdGVkLlxuLy8gWzNdIFNpbXVsdGFuZW91cyBjbG9zZVxuLy8gWzRdIFNlcnZlciB3b24ndCBzZW5kIGFueSBtb3JlIGZyYW1lczsgYWNjZXB0IG5vIG1vcmUgZnJhbWVzLCBzZW5kXG4vLyBDbG9zZU9rLlxuLy8gWzVdIEZ1bGx5IGNsb3NlZCwgY2xpZW50IHdpbGwgc2VuZCBubyBtb3JlLCBzZXJ2ZXIgd2lsbCBzZW5kIG5vXG4vLyBtb3JlLiBTaWduYWwgJ2Nsb3NlJyBvciAnZXJyb3InLlxuLy9cbi8vIFRoZXJlIGFyZSB0d28gc2lnbmFsbGluZyBtZWNoYW5pc21zIHVzZWQgaW4gdGhlIEFQSS4gVGhlIGZpcnN0IGlzXG4vLyB0aGF0IGNhbGxpbmcgYGNsb3NlYCB3aWxsIHJldHVybiBhIHByb21pc2UsIHRoYXQgd2lsbCBlaXRoZXJcbi8vIHJlc29sdmUgb25jZSB0aGUgY29ubmVjdGlvbiBvciBjaGFubmVsIGlzIGNsZWFubHkgc2h1dCBkb3duLCBvclxuLy8gd2lsbCByZWplY3QgaWYgdGhlIHNodXRkb3duIHRpbWVzIG91dC5cbi8vXG4vLyBUaGUgc2Vjb25kIGlzIHRoZSAnY2xvc2UnIGFuZCAnZXJyb3InIGV2ZW50cy4gVGhlc2UgYXJlXG4vLyBlbWl0dGVkIGFzIGFib3ZlLiBUaGUgZXZlbnRzIHdpbGwgZmlyZSAqYmVmb3JlKiBwcm9taXNlcyBhcmVcbi8vIHJlc29sdmVkLlxuXG4vLyBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aXRob3V0IGV2ZW4gZ2l2aW5nIGEgcmVhc29uLiBUeXBpY2FsLlxuQy5jbG9zZSA9IGZ1bmN0aW9uKGNsb3NlQ2FsbGJhY2spIHtcbiAgdmFyIGsgPSBjbG9zZUNhbGxiYWNrICYmIGZ1bmN0aW9uKCkgeyBjbG9zZUNhbGxiYWNrKG51bGwpOyB9O1xuICB0aGlzLmNsb3NlQmVjYXVzZShcIkNoZWVycywgdGhhbmtzXCIsIGNvbnN0YW50cy5SRVBMWV9TVUNDRVNTLCBrKTtcbn07XG5cbi8vIENsb3NlIHdpdGggYSByZWFzb24gYW5kIGEgJ2NvZGUnLiBJJ20gcHJldHR5IHN1cmUgUmFiYml0TVEgdG90YWxseVxuLy8gaWdub3JlcyB0aGVzZTsgbWF5YmUgaXQgbG9ncyB0aGVtLiBUaGUgY29udGludWF0aW9uIHdpbGwgYmUgaW52b2tlZFxuLy8gd2hlbiB0aGUgQ2xvc2VPayBoYXMgYmVlbiByZWNlaXZlZCwgYW5kIGJlZm9yZSB0aGUgJ2Nsb3NlJyBldmVudC5cbkMuY2xvc2VCZWNhdXNlID0gZnVuY3Rpb24ocmVhc29uLCBjb2RlLCBrKSB7XG4gIHRoaXMuc2VuZE1ldGhvZCgwLCBkZWZzLkNvbm5lY3Rpb25DbG9zZSwge1xuICAgIHJlcGx5VGV4dDogcmVhc29uLFxuICAgIHJlcGx5Q29kZTogY29kZSxcbiAgICBtZXRob2RJZDogMCwgY2xhc3NJZDogMFxuICB9KTtcbiAgdmFyIHMgPSBzdGFja0NhcHR1cmUoJ2Nsb3NlQmVjYXVzZSBjYWxsZWQ6ICcgKyByZWFzb24pO1xuICB0aGlzLnRvQ2xvc2luZyhzLCBrKTtcbn07XG5cbkMuY2xvc2VXaXRoRXJyb3IgPSBmdW5jdGlvbihyZWFzb24sIGNvZGUsIGVycm9yKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gIHRoaXMuY2xvc2VCZWNhdXNlKHJlYXNvbiwgY29kZSk7XG59O1xuXG5DLm9uU29ja2V0RXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKCF0aGlzLmV4cGVjdFNvY2tldENsb3NlKSB7XG4gICAgLy8gZm9yZXN0YWxsIGFueSBtb3JlIGNhbGxzIHRvIG9uU29ja2V0RXJyb3IsIHNpbmNlIHdlJ3JlIHNpZ25lZFxuICAgIC8vIHVwIGZvciBgJ2Vycm9yJ2AgKmFuZCogYCdlbmQnYFxuICAgIHRoaXMuZXhwZWN0U29ja2V0Q2xvc2UgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIHZhciBzID0gc3RhY2tDYXB0dXJlKCdTb2NrZXQgZXJyb3InKTtcbiAgICB0aGlzLnRvQ2xvc2VkKHMsIGVycik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGludmFsaWRPcChtc2csIHN0YWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbE9wZXJhdGlvbkVycm9yKG1zZywgc3RhY2spO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlU2VuZChjb25uLCBtc2csIHN0YWNrKSB7XG4gIGNvbm4uc2VuZE1ldGhvZCA9IGNvbm4uc2VuZENvbnRlbnQgPSBjb25uLnNlbmRNZXNzYWdlID1cbiAgICBpbnZhbGlkT3AobXNnLCBzdGFjayk7XG59XG5cbi8vIEEgY2xvc2UgaGFzIGJlZW4gaW5pdGlhdGVkLiBSZXBlYXQ6IGEgY2xvc2UgaGFzIGJlZW4gaW5pdGlhdGVkLlxuLy8gVGhpcyBtZWFucyB3ZSBzaG91bGQgbm90IHNlbmQgbW9yZSBmcmFtZXMsIGFueXdheSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuIFdlIGFsc28gaGF2ZSB0byBzaHV0IGRvd24gYWxsIHRoZSBjaGFubmVscy5cbkMudG9DbG9zaW5nID0gZnVuY3Rpb24oY2FwdHVyZWRTdGFjaywgaykge1xuICB2YXIgc2VuZCA9IHRoaXMuc2VuZE1ldGhvZC5iaW5kKHRoaXMpO1xuXG4gIHRoaXMuYWNjZXB0ID0gZnVuY3Rpb24oZikge1xuICAgIGlmIChmLmlkID09PSBkZWZzLkNvbm5lY3Rpb25DbG9zZU9rKSB7XG4gICAgICBpZiAoaykgaygpO1xuICAgICAgdmFyIHMgPSBzdGFja0NhcHR1cmUoJ0Nvbm5lY3Rpb25DbG9zZU9rIHJlY2VpdmVkJyk7XG4gICAgICB0aGlzLnRvQ2xvc2VkKHMsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGYuaWQgPT09IGRlZnMuQ29ubmVjdGlvbkNsb3NlKSB7XG4gICAgICBzZW5kKDAsIGRlZnMuQ29ubmVjdGlvbkNsb3NlT2ssIHt9KTtcbiAgICB9XG4gICAgLy8gZWxzZSBpZ25vcmUgZnJhbWVcbiAgfTtcbiAgaW52YWxpZGF0ZVNlbmQodGhpcywgJ0Nvbm5lY3Rpb24gY2xvc2luZycsIGNhcHR1cmVkU3RhY2spO1xufTtcblxuQy5fY2xvc2VDaGFubmVscyA9IGZ1bmN0aW9uKGNhcHR1cmVkU3RhY2spIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICBpZiAoY2ggIT09IG51bGwpIHtcbiAgICAgIGNoLmNoYW5uZWwudG9DbG9zZWQoY2FwdHVyZWRTdGFjayk7IC8vICUlJSBvciB3aXRoIGFuIGVycm9yPyBub3QgY2xlYXJcbiAgICB9XG4gIH1cbn07XG5cbi8vIEEgY2xvc2UgaGFzIGJlZW4gY29uZmlybWVkLiBDZWFzZSBhbGwgY29tbXVuaWNhdGlvbi5cbkMudG9DbG9zZWQgPSBmdW5jdGlvbihjYXB0dXJlZFN0YWNrLCBtYXliZUVycikge1xuICB0aGlzLl9jbG9zZUNoYW5uZWxzKGNhcHR1cmVkU3RhY2spO1xuICB2YXIgaW5mbyA9IGZtdCgnQ29ubmVjdGlvbiBjbG9zZWQgKCVzKScsXG4gICAgICAgICAgICAgICAgIChtYXliZUVycikgPyBtYXliZUVyci50b1N0cmluZygpIDogJ2J5IGNsaWVudCcpO1xuICAvLyBUaWR5IHVwLCBpbnZhbGlkYXRlIGVudmVyeXRoaW5nLCBkeW5hbWl0ZSB0aGUgYnJpZGdlcy5cbiAgaW52YWxpZGF0ZVNlbmQodGhpcywgaW5mbywgY2FwdHVyZWRTdGFjayk7XG4gIHRoaXMuYWNjZXB0ID0gaW52YWxpZE9wKGluZm8sIGNhcHR1cmVkU3RhY2spO1xuICB0aGlzLmNsb3NlID0gZnVuY3Rpb24oY2IpIHtcbiAgICBjYiAmJiBjYihuZXcgSWxsZWdhbE9wZXJhdGlvbkVycm9yKGluZm8sIGNhcHR1cmVkU3RhY2spKTtcbiAgfTtcbiAgaWYgKHRoaXMuaGVhcnRiZWF0ZXIpIHRoaXMuaGVhcnRiZWF0ZXIuY2xlYXIoKTtcbiAgLy8gVGhpcyBpcyBjZXJ0YWlubHkgdHJ1ZSBub3csIGlmIGl0IHdhc24ndCBiZWZvcmVcbiAgdGhpcy5leHBlY3RTb2NrZXRDbG9zZSA9IHRydWU7XG4gIHRoaXMuc3RyZWFtLmVuZCgpO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbWF5YmVFcnIpO1xufTtcblxuLy8gPT09XG5cbkMuc3RhcnRIZWFydGJlYXRlciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5oZWFydGJlYXQgPT09IDApIHJldHVybiBudWxsO1xuICBlbHNlIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGhiID0gbmV3IEhlYXJ0KHRoaXMuaGVhcnRiZWF0LFxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2VuZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUmVjdi5iaW5kKHRoaXMpKTtcbiAgICBoYi5vbigndGltZW91dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhiZXJyID0gbmV3IEVycm9yKFwiSGVhcnRiZWF0IHRpbWVvdXRcIik7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgaGJlcnIpO1xuICAgICAgdmFyIHMgPSBzdGFja0NhcHR1cmUoJ0hlYXJ0YmVhdCB0aW1lb3V0Jyk7XG4gICAgICBzZWxmLnRvQ2xvc2VkKHMsIGhiZXJyKTtcbiAgICB9KTtcbiAgICBoYi5vbignYmVhdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5zZW5kSGVhcnRiZWF0KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhiO1xuICB9XG59O1xuXG4vLyBJIHVzZSBhbiBhcnJheSB0byBrZWVwIHRyYWNrIG9mIHRoZSBjaGFubmVscywgcmF0aGVyIHRoYW4gYW5cbi8vIG9iamVjdC4gVGhlIGNoYW5uZWwgaWRlbnRpZmllcnMgYXJlIG51bWJlcnMsIGFuZCBhbGxvY2F0ZWQgYnkgdGhlXG4vLyBjb25uZWN0aW9uLiBJZiBJIHRyeSB0byBhbGxvY2F0ZSBsb3cgbnVtYmVycyB3aGVuIHRoZXkgYXJlXG4vLyBhdmFpbGFibGUgKHdoaWNoIEkgZG8sIGJ5IGxvb2tpbmcgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGJpdHNldCksXG4vLyB0aGlzIG91Z2h0IHRvIGtlZXAgdGhlIGFycmF5IHNtYWxsLCBhbmQgb3V0IG9mICdzcGFyc2UgYXJyYXlcbi8vIHN0b3JhZ2UnLiBJIGFsc28gc2V0IGVudHJpZXMgdG8gbnVsbCwgcmF0aGVyIHRoYW4gZGVsZXRpbmcgdGhlbSwgaW5cbi8vIHRoZSBleHBlY3RhdGlvbiB0aGF0IHRoZSBuZXh0IGNoYW5uZWwgYWxsb2NhdGlvbiB3aWxsIGZpbGwgdGhlIHNsb3Rcbi8vIGFnYWluIHJhdGhlciB0aGFuIGdyb3dpbmcgdGhlIGFycmF5LiBTZWVcbi8vIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL3NwZWVkL3Y4L1xuQy5mcmVzaENoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsLCBvcHRpb25zKSB7XG4gIHZhciBuZXh0ID0gdGhpcy5mcmVlQ2hhbm5lbHMubmV4dENsZWFyQml0KDEpO1xuICBpZiAobmV4dCA8IDAgfHwgbmV4dCA+IHRoaXMuY2hhbm5lbE1heClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGFubmVscyBsZWZ0IHRvIGFsbG9jYXRlXCIpO1xuICB0aGlzLmZyZWVDaGFubmVscy5zZXQobmV4dCk7XG5cbiAgdmFyIGh3bSA9IChvcHRpb25zICYmIG9wdGlvbnMuaGlnaFdhdGVyTWFyaykgfHwgREVGQVVMVF9XUklURV9IV007XG4gIHZhciB3cml0ZUJ1ZmZlciA9IG5ldyBQYXNzVGhyb3VnaCh7XG4gICAgb2JqZWN0TW9kZTogdHJ1ZSwgaGlnaFdhdGVyTWFyazogaHdtXG4gIH0pO1xuICB0aGlzLmNoYW5uZWxzW25leHRdID0ge2NoYW5uZWw6IGNoYW5uZWwsIGJ1ZmZlcjogd3JpdGVCdWZmZXJ9O1xuICB3cml0ZUJ1ZmZlci5vbignZHJhaW4nLCBmdW5jdGlvbigpIHtcbiAgICBjaGFubmVsLm9uQnVmZmVyRHJhaW4oKTtcbiAgfSk7XG4gIHRoaXMubXV4ZXIucGlwZUZyb20od3JpdGVCdWZmZXIpO1xuICByZXR1cm4gbmV4dDtcbn07XG5cbkMucmVsZWFzZUNoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsKSB7XG4gIHRoaXMuZnJlZUNoYW5uZWxzLmNsZWFyKGNoYW5uZWwpO1xuICB2YXIgYnVmZmVyID0gdGhpcy5jaGFubmVsc1tjaGFubmVsXS5idWZmZXI7XG4gIHRoaXMubXV4ZXIudW5waXBlRnJvbShidWZmZXIpO1xuICB0aGlzLmNoYW5uZWxzW2NoYW5uZWxdID0gbnVsbDtcbn07XG5cbkMuYWNjZXB0TG9vcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gZ28oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBmOyB3aGlsZSAoZiA9IHNlbGYucmVjdkZyYW1lKCkpIHNlbGYuYWNjZXB0KGYpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgc2VsZi5lbWl0KCdmcmFtZUVycm9yJywgZSk7XG4gICAgfVxuICB9XG4gIHNlbGYuc3RyZWFtLm9uKCdyZWFkYWJsZScsIGdvKTtcbiAgZ28oKTtcbn07XG5cbkMuc3RlcCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZnVuY3Rpb24gcmVjdigpIHtcbiAgICB2YXIgZjtcbiAgICB0cnkge1xuICAgICAgZiA9IHNlbGYucmVjdkZyYW1lKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBjYihlLCBudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGYpIGNiKG51bGwsIGYpO1xuICAgIGVsc2Ugc2VsZi5zdHJlYW0ub25jZSgncmVhZGFibGUnLCByZWN2KTtcbiAgfVxuICByZWN2KCk7XG59O1xuXG5DLmNoZWNrU2VuZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2hlY2sgPSB0aGlzLnNlbnRTaW5jZUxhc3RDaGVjaztcbiAgdGhpcy5zZW50U2luY2VMYXN0Q2hlY2sgPSBmYWxzZTtcbiAgcmV0dXJuIGNoZWNrO1xufVxuXG5DLmNoZWNrUmVjdiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2hlY2sgPSB0aGlzLnJlY3ZTaW5jZUxhc3RDaGVjaztcbiAgdGhpcy5yZWN2U2luY2VMYXN0Q2hlY2sgPSBmYWxzZTtcbiAgcmV0dXJuIGNoZWNrO1xufVxuXG5DLnNlbmRCeXRlcyA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIHRoaXMuc2VudFNpbmNlTGFzdENoZWNrID0gdHJ1ZTtcbiAgdGhpcy5zdHJlYW0ud3JpdGUoYnl0ZXMpO1xufTtcblxuQy5zZW5kSGVhcnRiZWF0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNlbmRCeXRlcyhmcmFtZS5IRUFSVEJFQVRfQlVGKTtcbn07XG5cbnZhciBlbmNvZGVNZXRob2QgPSBkZWZzLmVuY29kZU1ldGhvZDtcbnZhciBlbmNvZGVQcm9wZXJ0aWVzID0gZGVmcy5lbmNvZGVQcm9wZXJ0aWVzO1xuXG5DLnNlbmRNZXRob2QgPSBmdW5jdGlvbihjaGFubmVsLCBNZXRob2QsIGZpZWxkcykge1xuICB2YXIgZnJhbWUgPSBlbmNvZGVNZXRob2QoTWV0aG9kLCBjaGFubmVsLCBmaWVsZHMpO1xuICB0aGlzLnNlbnRTaW5jZUxhc3RDaGVjayA9IHRydWU7XG4gIHZhciBidWZmZXIgPSB0aGlzLmNoYW5uZWxzW2NoYW5uZWxdLmJ1ZmZlcjtcbiAgcmV0dXJuIGJ1ZmZlci53cml0ZShmcmFtZSk7XG59O1xuXG5DLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24oY2hhbm5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBNZXRob2QsIGZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBQcm9wZXJ0aWVzLCBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNvbnRlbnQpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbnRlbnQgaXMgbm90IGEgYnVmZmVyJyk7XG5cbiAgdmFyIG1mcmFtZSA9IGVuY29kZU1ldGhvZChNZXRob2QsIGNoYW5uZWwsIGZpZWxkcyk7XG4gIHZhciBwZnJhbWUgPSBlbmNvZGVQcm9wZXJ0aWVzKFByb3BlcnRpZXMsIGNoYW5uZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQubGVuZ3RoLCBwcm9wcyk7XG4gIHZhciBidWZmZXIgPSB0aGlzLmNoYW5uZWxzW2NoYW5uZWxdLmJ1ZmZlcjtcbiAgdGhpcy5zZW50U2luY2VMYXN0Q2hlY2sgPSB0cnVlO1xuXG4gIHZhciBtZXRob2RIZWFkZXJMZW4gPSBtZnJhbWUubGVuZ3RoICsgcGZyYW1lLmxlbmd0aDtcbiAgdmFyIGJvZHlMZW4gPSAoY29udGVudC5sZW5ndGggPiAwKSA/XG4gICAgY29udGVudC5sZW5ndGggKyBGUkFNRV9PVkVSSEVBRCA6IDA7XG4gIHZhciBhbGxMZW4gPSBtZXRob2RIZWFkZXJMZW4gKyBib2R5TGVuO1xuXG4gIGlmIChhbGxMZW4gPCBTSU5HTEVfQ0hVTktfVEhSRVNIT0xEKSB7XG4gICAgdmFyIGFsbCA9IEJ1ZmZlci5hbGxvYyhhbGxMZW4pO1xuICAgIHZhciBvZmZzZXQgPSBtZnJhbWUuY29weShhbGwsIDApO1xuICAgIG9mZnNldCArPSBwZnJhbWUuY29weShhbGwsIG9mZnNldCk7XG5cbiAgICBpZiAoYm9keUxlbiA+IDApXG4gICAgICBtYWtlQm9keUZyYW1lKGNoYW5uZWwsIGNvbnRlbnQpLmNvcHkoYWxsLCBvZmZzZXQpO1xuICAgIHJldHVybiBidWZmZXIud3JpdGUoYWxsKTtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAobWV0aG9kSGVhZGVyTGVuIDwgU0lOR0xFX0NIVU5LX1RIUkVTSE9MRCkge1xuICAgICAgdmFyIGJvdGggPSBCdWZmZXIuYWxsb2MobWV0aG9kSGVhZGVyTGVuKTtcbiAgICAgIHZhciBvZmZzZXQgPSBtZnJhbWUuY29weShib3RoLCAwKTtcbiAgICAgIHBmcmFtZS5jb3B5KGJvdGgsIG9mZnNldCk7XG4gICAgICBidWZmZXIud3JpdGUoYm90aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYnVmZmVyLndyaXRlKG1mcmFtZSk7XG4gICAgICBidWZmZXIud3JpdGUocGZyYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2VuZENvbnRlbnQoY2hhbm5lbCwgY29udGVudCk7XG4gIH1cbn07XG5cbnZhciBGUkFNRV9PVkVSSEVBRCA9IGRlZnMuRlJBTUVfT1ZFUkhFQUQ7XG52YXIgbWFrZUJvZHlGcmFtZSA9IGZyYW1lLm1ha2VCb2R5RnJhbWU7XG5cbkMuc2VuZENvbnRlbnQgPSBmdW5jdGlvbihjaGFubmVsLCBib2R5KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmbXQoXCJFeHBlY3RlZCBidWZmZXI7IGdvdCAlc1wiLCBib2R5KSk7XG4gIH1cbiAgdmFyIHdyaXRlUmVzdWx0ID0gdHJ1ZTtcbiAgdmFyIGJ1ZmZlciA9IHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uYnVmZmVyO1xuXG4gIHZhciBtYXhCb2R5ID0gdGhpcy5mcmFtZU1heCAtIEZSQU1FX09WRVJIRUFEO1xuXG4gIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGJvZHkubGVuZ3RoOyBvZmZzZXQgKz0gbWF4Qm9keSkge1xuICAgIHZhciBlbmQgPSBvZmZzZXQgKyBtYXhCb2R5O1xuICAgIHZhciBzbGljZSA9IChlbmQgPiBib2R5Lmxlbmd0aCkgPyBib2R5LnNsaWNlKG9mZnNldCkgOiBib2R5LnNsaWNlKG9mZnNldCwgZW5kKTtcbiAgICB2YXIgYm9keUZyYW1lID0gbWFrZUJvZHlGcmFtZShjaGFubmVsLCBzbGljZSk7XG4gICAgd3JpdGVSZXN1bHQgPSBidWZmZXIud3JpdGUoYm9keUZyYW1lKTtcbiAgfVxuICB0aGlzLnNlbnRTaW5jZUxhc3RDaGVjayA9IHRydWU7XG4gIHJldHVybiB3cml0ZVJlc3VsdDtcbn07XG5cbnZhciBwYXJzZUZyYW1lID0gZnJhbWUucGFyc2VGcmFtZTtcbnZhciBkZWNvZGVGcmFtZSA9IGZyYW1lLmRlY29kZUZyYW1lO1xuXG5DLnJlY3ZGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAvLyAlJSUgaWRlbnRpZnlpbmcgaW52YXJpYW50cyBtaWdodCBoZWxwIGhlcmU/XG4gIHZhciBmcmFtZSA9IHBhcnNlRnJhbWUodGhpcy5yZXN0LCB0aGlzLmZyYW1lTWF4KTtcblxuICBpZiAoIWZyYW1lKSB7XG4gICAgdmFyIGluY29taW5nID0gdGhpcy5zdHJlYW0ucmVhZCgpO1xuICAgIGlmIChpbmNvbWluZyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucmVjdlNpbmNlTGFzdENoZWNrID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzdCA9IEJ1ZmZlci5jb25jYXQoW3RoaXMucmVzdCwgaW5jb21pbmddKTtcbiAgICAgIHJldHVybiB0aGlzLnJlY3ZGcmFtZSgpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLnJlc3QgPSBmcmFtZS5yZXN0O1xuICAgIHJldHVybiBkZWNvZGVGcmFtZShmcmFtZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHdyYXBTdHJlYW0ocykge1xuICBpZiAocyBpbnN0YW5jZW9mIER1cGxleCkgcmV0dXJuIHM7XG4gIGVsc2Uge1xuICAgIHZhciB3cyA9IG5ldyBEdXBsZXgoKTtcbiAgICB3cy53cmFwKHMpOyAvL3dyYXBzIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoaW5nc1xuICAgIHdzLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBzLndyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIHdzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRmF0YWxFcnJvcihlcnJvcikge1xuICBzd2l0Y2ggKGVycm9yICYmIGVycm9yLmNvZGUpIHtcbiAgY2FzZSBkZWZzLmNvbnN0YW50cy5DT05ORUNUSU9OX0ZPUkNFRDpcbiAgY2FzZSBkZWZzLmNvbnN0YW50cy5SRVBMWV9TVUNDRVNTOlxuICAgIHJldHVybiBmYWxzZTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uID0gQ29ubmVjdGlvbjtcbm1vZHVsZS5leHBvcnRzLmlzRmF0YWxFcnJvciA9IGlzRmF0YWxFcnJvcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/connection.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/credentials.js":
/*!*************************************************!*\
  !*** ./node_modules/amqplib/lib/credentials.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//\n//\n//\n\n// Different kind of credentials that can be supplied when opening a\n// connection, corresponding to SASL mechanisms There's only two\n// useful mechanisms that RabbitMQ implements:\n//  * PLAIN (send username and password in the plain)\n//  * EXTERNAL (assume the server will figure out who you are from\n//    context, i.e., your SSL certificate)\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nmodule.exports.plain = function(user, passwd) {\n  return {\n    mechanism: 'PLAIN',\n    response: function() {\n      return Buffer.from(['', user, passwd].join(String.fromCharCode(0)))\n    },\n    username: user,\n    password: passwd\n  }\n}\n\nmodule.exports.external = function() {\n  return {\n    mechanism: 'EXTERNAL',\n    response: function() { return Buffer.from(''); }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY3JlZGVudGlhbHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY3JlZGVudGlhbHMuanM/Y2YwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG5cbi8vIERpZmZlcmVudCBraW5kIG9mIGNyZWRlbnRpYWxzIHRoYXQgY2FuIGJlIHN1cHBsaWVkIHdoZW4gb3BlbmluZyBhXG4vLyBjb25uZWN0aW9uLCBjb3JyZXNwb25kaW5nIHRvIFNBU0wgbWVjaGFuaXNtcyBUaGVyZSdzIG9ubHkgdHdvXG4vLyB1c2VmdWwgbWVjaGFuaXNtcyB0aGF0IFJhYmJpdE1RIGltcGxlbWVudHM6XG4vLyAgKiBQTEFJTiAoc2VuZCB1c2VybmFtZSBhbmQgcGFzc3dvcmQgaW4gdGhlIHBsYWluKVxuLy8gICogRVhURVJOQUwgKGFzc3VtZSB0aGUgc2VydmVyIHdpbGwgZmlndXJlIG91dCB3aG8geW91IGFyZSBmcm9tXG4vLyAgICBjb250ZXh0LCBpLmUuLCB5b3VyIFNTTCBjZXJ0aWZpY2F0ZSlcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5tb2R1bGUuZXhwb3J0cy5wbGFpbiA9IGZ1bmN0aW9uKHVzZXIsIHBhc3N3ZCkge1xuICByZXR1cm4ge1xuICAgIG1lY2hhbmlzbTogJ1BMQUlOJyxcbiAgICByZXNwb25zZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oWycnLCB1c2VyLCBwYXNzd2RdLmpvaW4oU3RyaW5nLmZyb21DaGFyQ29kZSgwKSkpXG4gICAgfSxcbiAgICB1c2VybmFtZTogdXNlcixcbiAgICBwYXNzd29yZDogcGFzc3dkXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuZXh0ZXJuYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBtZWNoYW5pc206ICdFWFRFUk5BTCcsXG4gICAgcmVzcG9uc2U6IGZ1bmN0aW9uKCkgeyByZXR1cm4gQnVmZmVyLmZyb20oJycpOyB9XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/credentials.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/defs.js":
/*!******************************************!*\
  !*** ./node_modules/amqplib/lib/defs.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @preserve This file is generated by the script\n * ../bin/generate-defs.js, which is not in general included in a\n * distribution, but is available in the source repository e.g. at\n * https://github.com/squaremo/amqp.node/\n */\n\n\nfunction decodeConnectionStart(buffer) {\n  var val, len, offset = 0, fields = {\n    versionMajor: void 0,\n    versionMinor: void 0,\n    serverProperties: void 0,\n    mechanisms: void 0,\n    locales: void 0\n  };\n  val = buffer[offset];\n  offset++;\n  fields.versionMajor = val;\n  val = buffer[offset];\n  offset++;\n  fields.versionMinor = val;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.slice(offset, offset + len));\n  offset += len;\n  fields.serverProperties = val;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = buffer.slice(offset, offset + len);\n  offset += len;\n  fields.mechanisms = val;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = buffer.slice(offset, offset + len);\n  offset += len;\n  fields.locales = val;\n  return fields;\n}\n\nfunction encodeConnectionStart(channel, fields) {\n  var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;\n  val = fields.serverProperties;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'serverProperties'\");\n  if (\"object\" != typeof val) throw new TypeError(\"Field 'serverProperties' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var serverProperties_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += serverProperties_encoded.length;\n  val = fields.mechanisms;\n  if (void 0 === val) val = Buffer.from(\"PLAIN\"); else if (!Buffer.isBuffer(val)) throw new TypeError(\"Field 'mechanisms' is the wrong type; must be a Buffer\");\n  varyingSize += val.length;\n  val = fields.locales;\n  if (void 0 === val) val = Buffer.from(\"en_US\"); else if (!Buffer.isBuffer(val)) throw new TypeError(\"Field 'locales' is the wrong type; must be a Buffer\");\n  varyingSize += val.length;\n  var buffer = Buffer.alloc(22 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655370, 7);\n  offset = 11;\n  val = fields.versionMajor;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'versionMajor' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt8(val, offset);\n  offset++;\n  val = fields.versionMinor;\n  if (void 0 === val) val = 9; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'versionMinor' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt8(val, offset);\n  offset++;\n  offset += serverProperties_encoded.copy(buffer, offset);\n  val = fields.mechanisms;\n  void 0 === val && (val = Buffer.from(\"PLAIN\"));\n  len = val.length;\n  buffer.writeUInt32BE(len, offset);\n  offset += 4;\n  val.copy(buffer, offset);\n  offset += len;\n  val = fields.locales;\n  void 0 === val && (val = Buffer.from(\"en_US\"));\n  len = val.length;\n  buffer.writeUInt32BE(len, offset);\n  offset += 4;\n  val.copy(buffer, offset);\n  offset += len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionStartOk(buffer) {\n  var val, len, offset = 0, fields = {\n    clientProperties: void 0,\n    mechanism: void 0,\n    response: void 0,\n    locale: void 0\n  };\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.slice(offset, offset + len));\n  offset += len;\n  fields.clientProperties = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.mechanism = val;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = buffer.slice(offset, offset + len);\n  offset += len;\n  fields.response = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.locale = val;\n  return fields;\n}\n\nfunction encodeConnectionStartOk(channel, fields) {\n  var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;\n  val = fields.clientProperties;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'clientProperties'\");\n  if (\"object\" != typeof val) throw new TypeError(\"Field 'clientProperties' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var clientProperties_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += clientProperties_encoded.length;\n  val = fields.mechanism;\n  if (void 0 === val) val = \"PLAIN\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'mechanism' is the wrong type; must be a string (up to 255 chars)\");\n  var mechanism_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += mechanism_len;\n  val = fields.response;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'response'\");\n  if (!Buffer.isBuffer(val)) throw new TypeError(\"Field 'response' is the wrong type; must be a Buffer\");\n  varyingSize += val.length;\n  val = fields.locale;\n  if (void 0 === val) val = \"en_US\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'locale' is the wrong type; must be a string (up to 255 chars)\");\n  var locale_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += locale_len;\n  var buffer = Buffer.alloc(18 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655371, 7);\n  offset = 11;\n  offset += clientProperties_encoded.copy(buffer, offset);\n  val = fields.mechanism;\n  void 0 === val && (val = \"PLAIN\");\n  buffer[offset] = mechanism_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += mechanism_len;\n  val = fields.response;\n  void 0 === val && (val = Buffer.from(void 0));\n  len = val.length;\n  buffer.writeUInt32BE(len, offset);\n  offset += 4;\n  val.copy(buffer, offset);\n  offset += len;\n  val = fields.locale;\n  void 0 === val && (val = \"en_US\");\n  buffer[offset] = locale_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += locale_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionSecure(buffer) {\n  var val, len, offset = 0, fields = {\n    challenge: void 0\n  };\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = buffer.slice(offset, offset + len);\n  offset += len;\n  fields.challenge = val;\n  return fields;\n}\n\nfunction encodeConnectionSecure(channel, fields) {\n  var len, offset = 0, val = null, varyingSize = 0;\n  val = fields.challenge;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'challenge'\");\n  if (!Buffer.isBuffer(val)) throw new TypeError(\"Field 'challenge' is the wrong type; must be a Buffer\");\n  varyingSize += val.length;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655380, 7);\n  offset = 11;\n  val = fields.challenge;\n  void 0 === val && (val = Buffer.from(void 0));\n  len = val.length;\n  buffer.writeUInt32BE(len, offset);\n  offset += 4;\n  val.copy(buffer, offset);\n  offset += len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionSecureOk(buffer) {\n  var val, len, offset = 0, fields = {\n    response: void 0\n  };\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = buffer.slice(offset, offset + len);\n  offset += len;\n  fields.response = val;\n  return fields;\n}\n\nfunction encodeConnectionSecureOk(channel, fields) {\n  var len, offset = 0, val = null, varyingSize = 0;\n  val = fields.response;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'response'\");\n  if (!Buffer.isBuffer(val)) throw new TypeError(\"Field 'response' is the wrong type; must be a Buffer\");\n  varyingSize += val.length;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655381, 7);\n  offset = 11;\n  val = fields.response;\n  void 0 === val && (val = Buffer.from(void 0));\n  len = val.length;\n  buffer.writeUInt32BE(len, offset);\n  offset += 4;\n  val.copy(buffer, offset);\n  offset += len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionTune(buffer) {\n  var val, offset = 0, fields = {\n    channelMax: void 0,\n    frameMax: void 0,\n    heartbeat: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.channelMax = val;\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.frameMax = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.heartbeat = val;\n  return fields;\n}\n\nfunction encodeConnectionTune(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0, buffer = Buffer.alloc(20 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655390, 7);\n  offset = 11;\n  val = fields.channelMax;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'channelMax' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.frameMax;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'frameMax' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  val = fields.heartbeat;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'heartbeat' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionTuneOk(buffer) {\n  var val, offset = 0, fields = {\n    channelMax: void 0,\n    frameMax: void 0,\n    heartbeat: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.channelMax = val;\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.frameMax = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.heartbeat = val;\n  return fields;\n}\n\nfunction encodeConnectionTuneOk(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0, buffer = Buffer.alloc(20 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655391, 7);\n  offset = 11;\n  val = fields.channelMax;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'channelMax' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.frameMax;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'frameMax' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  val = fields.heartbeat;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'heartbeat' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionOpen(buffer) {\n  var val, len, offset = 0, fields = {\n    virtualHost: void 0,\n    capabilities: void 0,\n    insist: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.virtualHost = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.capabilities = val;\n  val = !!(1 & buffer[offset]);\n  fields.insist = val;\n  return fields;\n}\n\nfunction encodeConnectionOpen(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.virtualHost;\n  if (void 0 === val) val = \"/\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'virtualHost' is the wrong type; must be a string (up to 255 chars)\");\n  var virtualHost_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += virtualHost_len;\n  val = fields.capabilities;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'capabilities' is the wrong type; must be a string (up to 255 chars)\");\n  var capabilities_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += capabilities_len;\n  var buffer = Buffer.alloc(15 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655400, 7);\n  offset = 11;\n  val = fields.virtualHost;\n  void 0 === val && (val = \"/\");\n  buffer[offset] = virtualHost_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += virtualHost_len;\n  val = fields.capabilities;\n  void 0 === val && (val = \"\");\n  buffer[offset] = capabilities_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += capabilities_len;\n  val = fields.insist;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionOpenOk(buffer) {\n  var val, len, offset = 0, fields = {\n    knownHosts: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.knownHosts = val;\n  return fields;\n}\n\nfunction encodeConnectionOpenOk(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.knownHosts;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'knownHosts' is the wrong type; must be a string (up to 255 chars)\");\n  var knownHosts_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += knownHosts_len;\n  var buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655401, 7);\n  offset = 11;\n  val = fields.knownHosts;\n  void 0 === val && (val = \"\");\n  buffer[offset] = knownHosts_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += knownHosts_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionClose(buffer) {\n  var val, len, offset = 0, fields = {\n    replyCode: void 0,\n    replyText: void 0,\n    classId: void 0,\n    methodId: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.replyCode = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.replyText = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.classId = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.methodId = val;\n  return fields;\n}\n\nfunction encodeConnectionClose(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.replyText;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'replyText' is the wrong type; must be a string (up to 255 chars)\");\n  var replyText_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += replyText_len;\n  var buffer = Buffer.alloc(19 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655410, 7);\n  offset = 11;\n  val = fields.replyCode;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'replyCode'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'replyCode' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.replyText;\n  void 0 === val && (val = \"\");\n  buffer[offset] = replyText_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += replyText_len;\n  val = fields.classId;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'classId'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'classId' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.methodId;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'methodId'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'methodId' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionCloseOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeConnectionCloseOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655411, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionBlocked(buffer) {\n  var val, len, offset = 0, fields = {\n    reason: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.reason = val;\n  return fields;\n}\n\nfunction encodeConnectionBlocked(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.reason;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'reason' is the wrong type; must be a string (up to 255 chars)\");\n  var reason_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += reason_len;\n  var buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655420, 7);\n  offset = 11;\n  val = fields.reason;\n  void 0 === val && (val = \"\");\n  buffer[offset] = reason_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += reason_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionUnblocked(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeConnectionUnblocked(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655421, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeChannelOpen(buffer) {\n  var val, len, offset = 0, fields = {\n    outOfBand: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.outOfBand = val;\n  return fields;\n}\n\nfunction encodeChannelOpen(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.outOfBand;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'outOfBand' is the wrong type; must be a string (up to 255 chars)\");\n  var outOfBand_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += outOfBand_len;\n  var buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1310730, 7);\n  offset = 11;\n  val = fields.outOfBand;\n  void 0 === val && (val = \"\");\n  buffer[offset] = outOfBand_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += outOfBand_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeChannelOpenOk(buffer) {\n  var val, len, offset = 0, fields = {\n    channelId: void 0\n  };\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = buffer.slice(offset, offset + len);\n  offset += len;\n  fields.channelId = val;\n  return fields;\n}\n\nfunction encodeChannelOpenOk(channel, fields) {\n  var len, offset = 0, val = null, varyingSize = 0;\n  val = fields.channelId;\n  if (void 0 === val) val = Buffer.from(\"\"); else if (!Buffer.isBuffer(val)) throw new TypeError(\"Field 'channelId' is the wrong type; must be a Buffer\");\n  varyingSize += val.length;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1310731, 7);\n  offset = 11;\n  val = fields.channelId;\n  void 0 === val && (val = Buffer.from(\"\"));\n  len = val.length;\n  buffer.writeUInt32BE(len, offset);\n  offset += 4;\n  val.copy(buffer, offset);\n  offset += len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeChannelFlow(buffer) {\n  var val, offset = 0, fields = {\n    active: void 0\n  };\n  val = !!(1 & buffer[offset]);\n  fields.active = val;\n  return fields;\n}\n\nfunction encodeChannelFlow(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0, buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1310740, 7);\n  offset = 11;\n  val = fields.active;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'active'\");\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeChannelFlowOk(buffer) {\n  var val, offset = 0, fields = {\n    active: void 0\n  };\n  val = !!(1 & buffer[offset]);\n  fields.active = val;\n  return fields;\n}\n\nfunction encodeChannelFlowOk(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0, buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1310741, 7);\n  offset = 11;\n  val = fields.active;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'active'\");\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeChannelClose(buffer) {\n  var val, len, offset = 0, fields = {\n    replyCode: void 0,\n    replyText: void 0,\n    classId: void 0,\n    methodId: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.replyCode = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.replyText = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.classId = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.methodId = val;\n  return fields;\n}\n\nfunction encodeChannelClose(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.replyText;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'replyText' is the wrong type; must be a string (up to 255 chars)\");\n  var replyText_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += replyText_len;\n  var buffer = Buffer.alloc(19 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1310760, 7);\n  offset = 11;\n  val = fields.replyCode;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'replyCode'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'replyCode' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.replyText;\n  void 0 === val && (val = \"\");\n  buffer[offset] = replyText_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += replyText_len;\n  val = fields.classId;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'classId'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'classId' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.methodId;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'methodId'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'methodId' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeChannelCloseOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeChannelCloseOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1310761, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeAccessRequest(buffer) {\n  var val, len, offset = 0, fields = {\n    realm: void 0,\n    exclusive: void 0,\n    passive: void 0,\n    active: void 0,\n    write: void 0,\n    read: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.realm = val;\n  val = !!(1 & buffer[offset]);\n  fields.exclusive = val;\n  val = !!(2 & buffer[offset]);\n  fields.passive = val;\n  val = !!(4 & buffer[offset]);\n  fields.active = val;\n  val = !!(8 & buffer[offset]);\n  fields.write = val;\n  val = !!(16 & buffer[offset]);\n  fields.read = val;\n  return fields;\n}\n\nfunction encodeAccessRequest(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.realm;\n  if (void 0 === val) val = \"/data\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'realm' is the wrong type; must be a string (up to 255 chars)\");\n  var realm_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += realm_len;\n  var buffer = Buffer.alloc(14 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1966090, 7);\n  offset = 11;\n  val = fields.realm;\n  void 0 === val && (val = \"/data\");\n  buffer[offset] = realm_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += realm_len;\n  val = fields.exclusive;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.passive;\n  void 0 === val && (val = !0);\n  val && (bits += 2);\n  val = fields.active;\n  void 0 === val && (val = !0);\n  val && (bits += 4);\n  val = fields.write;\n  void 0 === val && (val = !0);\n  val && (bits += 8);\n  val = fields.read;\n  void 0 === val && (val = !0);\n  val && (bits += 16);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeAccessRequestOk(buffer) {\n  var val, offset = 0, fields = {\n    ticket: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  return fields;\n}\n\nfunction encodeAccessRequestOk(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0, buffer = Buffer.alloc(14 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1966091, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 1; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeDeclare(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    exchange: void 0,\n    type: void 0,\n    passive: void 0,\n    durable: void 0,\n    autoDelete: void 0,\n    internal: void 0,\n    nowait: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.type = val;\n  val = !!(1 & buffer[offset]);\n  fields.passive = val;\n  val = !!(2 & buffer[offset]);\n  fields.durable = val;\n  val = !!(4 & buffer[offset]);\n  fields.autoDelete = val;\n  val = !!(8 & buffer[offset]);\n  fields.internal = val;\n  val = !!(16 & buffer[offset]);\n  fields.nowait = val;\n  offset++;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.slice(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeExchangeDeclare(channel, fields) {\n  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.type;\n  if (void 0 === val) val = \"direct\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'type' is the wrong type; must be a string (up to 255 chars)\");\n  var type_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += type_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(17 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621450, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.type;\n  void 0 === val && (val = \"direct\");\n  buffer[offset] = type_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += type_len;\n  val = fields.passive;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.durable;\n  void 0 === val && (val = !1);\n  val && (bits += 2);\n  val = fields.autoDelete;\n  void 0 === val && (val = !1);\n  val && (bits += 4);\n  val = fields.internal;\n  void 0 === val && (val = !1);\n  val && (bits += 8);\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 16);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeDeclareOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeExchangeDeclareOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621451, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeDelete(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    exchange: void 0,\n    ifUnused: void 0,\n    nowait: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  val = !!(1 & buffer[offset]);\n  fields.ifUnused = val;\n  val = !!(2 & buffer[offset]);\n  fields.nowait = val;\n  return fields;\n}\n\nfunction encodeExchangeDelete(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621460, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.ifUnused;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 2);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeDeleteOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeExchangeDeleteOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621461, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeBind(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    destination: void 0,\n    source: void 0,\n    routingKey: void 0,\n    nowait: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.destination = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.source = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  val = !!(1 & buffer[offset]);\n  fields.nowait = val;\n  offset++;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.slice(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeExchangeBind(channel, fields) {\n  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;\n  val = fields.destination;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'destination'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'destination' is the wrong type; must be a string (up to 255 chars)\");\n  var destination_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += destination_len;\n  val = fields.source;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'source'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'source' is the wrong type; must be a string (up to 255 chars)\");\n  var source_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += source_len;\n  val = fields.routingKey;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(18 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621470, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.destination;\n  void 0 === val && (val = void 0);\n  buffer[offset] = destination_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += destination_len;\n  val = fields.source;\n  void 0 === val && (val = void 0);\n  buffer[offset] = source_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += source_len;\n  val = fields.routingKey;\n  void 0 === val && (val = \"\");\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeBindOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeExchangeBindOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621471, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeUnbind(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    destination: void 0,\n    source: void 0,\n    routingKey: void 0,\n    nowait: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.destination = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.source = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  val = !!(1 & buffer[offset]);\n  fields.nowait = val;\n  offset++;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.slice(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeExchangeUnbind(channel, fields) {\n  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;\n  val = fields.destination;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'destination'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'destination' is the wrong type; must be a string (up to 255 chars)\");\n  var destination_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += destination_len;\n  val = fields.source;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'source'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'source' is the wrong type; must be a string (up to 255 chars)\");\n  var source_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += source_len;\n  val = fields.routingKey;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(18 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621480, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.destination;\n  void 0 === val && (val = void 0);\n  buffer[offset] = destination_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += destination_len;\n  val = fields.source;\n  void 0 === val && (val = void 0);\n  buffer[offset] = source_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += source_len;\n  val = fields.routingKey;\n  void 0 === val && (val = \"\");\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeUnbindOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeExchangeUnbindOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621491, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueDeclare(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    passive: void 0,\n    durable: void 0,\n    exclusive: void 0,\n    autoDelete: void 0,\n    nowait: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  val = !!(1 & buffer[offset]);\n  fields.passive = val;\n  val = !!(2 & buffer[offset]);\n  fields.durable = val;\n  val = !!(4 & buffer[offset]);\n  fields.exclusive = val;\n  val = !!(8 & buffer[offset]);\n  fields.autoDelete = val;\n  val = !!(16 & buffer[offset]);\n  fields.nowait = val;\n  offset++;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.slice(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeQueueDeclare(channel, fields) {\n  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276810, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.passive;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.durable;\n  void 0 === val && (val = !1);\n  val && (bits += 2);\n  val = fields.exclusive;\n  void 0 === val && (val = !1);\n  val && (bits += 4);\n  val = fields.autoDelete;\n  void 0 === val && (val = !1);\n  val && (bits += 8);\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 16);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueDeclareOk(buffer) {\n  var val, len, offset = 0, fields = {\n    queue: void 0,\n    messageCount: void 0,\n    consumerCount: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.messageCount = val;\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.consumerCount = val;\n  return fields;\n}\n\nfunction encodeQueueDeclareOk(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.queue;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'queue'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  var buffer = Buffer.alloc(21 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276811, 7);\n  offset = 11;\n  val = fields.queue;\n  void 0 === val && (val = void 0);\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.messageCount;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'messageCount'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'messageCount' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  val = fields.consumerCount;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'consumerCount'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'consumerCount' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueBind(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    exchange: void 0,\n    routingKey: void 0,\n    nowait: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  val = !!(1 & buffer[offset]);\n  fields.nowait = val;\n  offset++;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.slice(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeQueueBind(channel, fields) {\n  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.routingKey;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(18 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276820, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.routingKey;\n  void 0 === val && (val = \"\");\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueBindOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeQueueBindOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276821, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueuePurge(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    nowait: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  val = !!(1 & buffer[offset]);\n  fields.nowait = val;\n  return fields;\n}\n\nfunction encodeQueuePurge(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276830, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueuePurgeOk(buffer) {\n  var val, offset = 0, fields = {\n    messageCount: void 0\n  };\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.messageCount = val;\n  return fields;\n}\n\nfunction encodeQueuePurgeOk(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0, buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276831, 7);\n  offset = 11;\n  val = fields.messageCount;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'messageCount'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'messageCount' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueDelete(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    ifUnused: void 0,\n    ifEmpty: void 0,\n    nowait: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  val = !!(1 & buffer[offset]);\n  fields.ifUnused = val;\n  val = !!(2 & buffer[offset]);\n  fields.ifEmpty = val;\n  val = !!(4 & buffer[offset]);\n  fields.nowait = val;\n  return fields;\n}\n\nfunction encodeQueueDelete(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276840, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.ifUnused;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.ifEmpty;\n  void 0 === val && (val = !1);\n  val && (bits += 2);\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 4);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueDeleteOk(buffer) {\n  var val, offset = 0, fields = {\n    messageCount: void 0\n  };\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.messageCount = val;\n  return fields;\n}\n\nfunction encodeQueueDeleteOk(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0, buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276841, 7);\n  offset = 11;\n  val = fields.messageCount;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'messageCount'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'messageCount' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueUnbind(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    exchange: void 0,\n    routingKey: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.slice(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeQueueUnbind(channel, fields) {\n  var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.routingKey;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(17 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276850, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.routingKey;\n  void 0 === val && (val = \"\");\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueUnbindOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeQueueUnbindOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276851, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicQos(buffer) {\n  var val, offset = 0, fields = {\n    prefetchSize: void 0,\n    prefetchCount: void 0,\n    global: void 0\n  };\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.prefetchSize = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.prefetchCount = val;\n  val = !!(1 & buffer[offset]);\n  fields.global = val;\n  return fields;\n}\n\nfunction encodeBasicQos(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0, buffer = Buffer.alloc(19 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932170, 7);\n  offset = 11;\n  val = fields.prefetchSize;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'prefetchSize' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  val = fields.prefetchCount;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'prefetchCount' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.global;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicQosOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeBasicQosOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932171, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicConsume(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    consumerTag: void 0,\n    noLocal: void 0,\n    noAck: void 0,\n    exclusive: void 0,\n    nowait: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.consumerTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.noLocal = val;\n  val = !!(2 & buffer[offset]);\n  fields.noAck = val;\n  val = !!(4 & buffer[offset]);\n  fields.exclusive = val;\n  val = !!(8 & buffer[offset]);\n  fields.nowait = val;\n  offset++;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.slice(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeBasicConsume(channel, fields) {\n  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  val = fields.consumerTag;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)\");\n  var consumerTag_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += consumerTag_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(17 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932180, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.consumerTag;\n  void 0 === val && (val = \"\");\n  buffer[offset] = consumerTag_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += consumerTag_len;\n  val = fields.noLocal;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.noAck;\n  void 0 === val && (val = !1);\n  val && (bits += 2);\n  val = fields.exclusive;\n  void 0 === val && (val = !1);\n  val && (bits += 4);\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 8);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicConsumeOk(buffer) {\n  var val, len, offset = 0, fields = {\n    consumerTag: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.consumerTag = val;\n  return fields;\n}\n\nfunction encodeBasicConsumeOk(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.consumerTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'consumerTag'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)\");\n  var consumerTag_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += consumerTag_len;\n  var buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932181, 7);\n  offset = 11;\n  val = fields.consumerTag;\n  void 0 === val && (val = void 0);\n  buffer[offset] = consumerTag_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += consumerTag_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicCancel(buffer) {\n  var val, len, offset = 0, fields = {\n    consumerTag: void 0,\n    nowait: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.consumerTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.nowait = val;\n  return fields;\n}\n\nfunction encodeBasicCancel(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.consumerTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'consumerTag'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)\");\n  var consumerTag_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += consumerTag_len;\n  var buffer = Buffer.alloc(14 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932190, 7);\n  offset = 11;\n  val = fields.consumerTag;\n  void 0 === val && (val = void 0);\n  buffer[offset] = consumerTag_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += consumerTag_len;\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicCancelOk(buffer) {\n  var val, len, offset = 0, fields = {\n    consumerTag: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.consumerTag = val;\n  return fields;\n}\n\nfunction encodeBasicCancelOk(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.consumerTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'consumerTag'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)\");\n  var consumerTag_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += consumerTag_len;\n  var buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932191, 7);\n  offset = 11;\n  val = fields.consumerTag;\n  void 0 === val && (val = void 0);\n  buffer[offset] = consumerTag_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += consumerTag_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicPublish(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    exchange: void 0,\n    routingKey: void 0,\n    mandatory: void 0,\n    immediate: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  val = !!(1 & buffer[offset]);\n  fields.mandatory = val;\n  val = !!(2 & buffer[offset]);\n  fields.immediate = val;\n  return fields;\n}\n\nfunction encodeBasicPublish(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.exchange;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.routingKey;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  var buffer = Buffer.alloc(17 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932200, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.exchange;\n  void 0 === val && (val = \"\");\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.routingKey;\n  void 0 === val && (val = \"\");\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  val = fields.mandatory;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.immediate;\n  void 0 === val && (val = !1);\n  val && (bits += 2);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicReturn(buffer) {\n  var val, len, offset = 0, fields = {\n    replyCode: void 0,\n    replyText: void 0,\n    exchange: void 0,\n    routingKey: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.replyCode = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.replyText = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  return fields;\n}\n\nfunction encodeBasicReturn(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.replyText;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'replyText' is the wrong type; must be a string (up to 255 chars)\");\n  var replyText_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += replyText_len;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.routingKey;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'routingKey'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  var buffer = Buffer.alloc(17 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932210, 7);\n  offset = 11;\n  val = fields.replyCode;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'replyCode'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'replyCode' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.replyText;\n  void 0 === val && (val = \"\");\n  buffer[offset] = replyText_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += replyText_len;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.routingKey;\n  void 0 === val && (val = void 0);\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicDeliver(buffer) {\n  var val, len, offset = 0, fields = {\n    consumerTag: void 0,\n    deliveryTag: void 0,\n    redelivered: void 0,\n    exchange: void 0,\n    routingKey: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.consumerTag = val;\n  val = ints.readUInt64BE(buffer, offset);\n  offset += 8;\n  fields.deliveryTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.redelivered = val;\n  offset++;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  return fields;\n}\n\nfunction encodeBasicDeliver(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.consumerTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'consumerTag'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)\");\n  var consumerTag_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += consumerTag_len;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.routingKey;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'routingKey'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  var buffer = Buffer.alloc(24 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932220, 7);\n  offset = 11;\n  val = fields.consumerTag;\n  void 0 === val && (val = void 0);\n  buffer[offset] = consumerTag_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += consumerTag_len;\n  val = fields.deliveryTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'deliveryTag'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'deliveryTag' is the wrong type; must be a number (but not NaN)\");\n  ints.writeUInt64BE(buffer, val, offset);\n  offset += 8;\n  val = fields.redelivered;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.routingKey;\n  void 0 === val && (val = void 0);\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicGet(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    noAck: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  val = !!(1 & buffer[offset]);\n  fields.noAck = val;\n  return fields;\n}\n\nfunction encodeBasicGet(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932230, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.noAck;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicGetOk(buffer) {\n  var val, len, offset = 0, fields = {\n    deliveryTag: void 0,\n    redelivered: void 0,\n    exchange: void 0,\n    routingKey: void 0,\n    messageCount: void 0\n  };\n  val = ints.readUInt64BE(buffer, offset);\n  offset += 8;\n  fields.deliveryTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.redelivered = val;\n  offset++;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.messageCount = val;\n  return fields;\n}\n\nfunction encodeBasicGetOk(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.routingKey;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'routingKey'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  var buffer = Buffer.alloc(27 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932231, 7);\n  offset = 11;\n  val = fields.deliveryTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'deliveryTag'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'deliveryTag' is the wrong type; must be a number (but not NaN)\");\n  ints.writeUInt64BE(buffer, val, offset);\n  offset += 8;\n  val = fields.redelivered;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.routingKey;\n  void 0 === val && (val = void 0);\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  val = fields.messageCount;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'messageCount'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'messageCount' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicGetEmpty(buffer) {\n  var val, len, offset = 0, fields = {\n    clusterId: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.clusterId = val;\n  return fields;\n}\n\nfunction encodeBasicGetEmpty(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.clusterId;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'clusterId' is the wrong type; must be a string (up to 255 chars)\");\n  var clusterId_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += clusterId_len;\n  var buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932232, 7);\n  offset = 11;\n  val = fields.clusterId;\n  void 0 === val && (val = \"\");\n  buffer[offset] = clusterId_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += clusterId_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicAck(buffer) {\n  var val, offset = 0, fields = {\n    deliveryTag: void 0,\n    multiple: void 0\n  };\n  val = ints.readUInt64BE(buffer, offset);\n  offset += 8;\n  fields.deliveryTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.multiple = val;\n  return fields;\n}\n\nfunction encodeBasicAck(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0, buffer = Buffer.alloc(21 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932240, 7);\n  offset = 11;\n  val = fields.deliveryTag;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'deliveryTag' is the wrong type; must be a number (but not NaN)\");\n  ints.writeUInt64BE(buffer, val, offset);\n  offset += 8;\n  val = fields.multiple;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicReject(buffer) {\n  var val, offset = 0, fields = {\n    deliveryTag: void 0,\n    requeue: void 0\n  };\n  val = ints.readUInt64BE(buffer, offset);\n  offset += 8;\n  fields.deliveryTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.requeue = val;\n  return fields;\n}\n\nfunction encodeBasicReject(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0, buffer = Buffer.alloc(21 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932250, 7);\n  offset = 11;\n  val = fields.deliveryTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'deliveryTag'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'deliveryTag' is the wrong type; must be a number (but not NaN)\");\n  ints.writeUInt64BE(buffer, val, offset);\n  offset += 8;\n  val = fields.requeue;\n  void 0 === val && (val = !0);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicRecoverAsync(buffer) {\n  var val, offset = 0, fields = {\n    requeue: void 0\n  };\n  val = !!(1 & buffer[offset]);\n  fields.requeue = val;\n  return fields;\n}\n\nfunction encodeBasicRecoverAsync(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0, buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932260, 7);\n  offset = 11;\n  val = fields.requeue;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicRecover(buffer) {\n  var val, offset = 0, fields = {\n    requeue: void 0\n  };\n  val = !!(1 & buffer[offset]);\n  fields.requeue = val;\n  return fields;\n}\n\nfunction encodeBasicRecover(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0, buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932270, 7);\n  offset = 11;\n  val = fields.requeue;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicRecoverOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeBasicRecoverOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932271, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicNack(buffer) {\n  var val, offset = 0, fields = {\n    deliveryTag: void 0,\n    multiple: void 0,\n    requeue: void 0\n  };\n  val = ints.readUInt64BE(buffer, offset);\n  offset += 8;\n  fields.deliveryTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.multiple = val;\n  val = !!(2 & buffer[offset]);\n  fields.requeue = val;\n  return fields;\n}\n\nfunction encodeBasicNack(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0, buffer = Buffer.alloc(21 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932280, 7);\n  offset = 11;\n  val = fields.deliveryTag;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'deliveryTag' is the wrong type; must be a number (but not NaN)\");\n  ints.writeUInt64BE(buffer, val, offset);\n  offset += 8;\n  val = fields.multiple;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.requeue;\n  void 0 === val && (val = !0);\n  val && (bits += 2);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeTxSelect(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeTxSelect(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5898250, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeTxSelectOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeTxSelectOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5898251, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeTxCommit(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeTxCommit(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5898260, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeTxCommitOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeTxCommitOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5898261, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeTxRollback(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeTxRollback(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5898270, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeTxRollbackOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeTxRollbackOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5898271, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConfirmSelect(buffer) {\n  var val, offset = 0, fields = {\n    nowait: void 0\n  };\n  val = !!(1 & buffer[offset]);\n  fields.nowait = val;\n  return fields;\n}\n\nfunction encodeConfirmSelect(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0, buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5570570, 7);\n  offset = 11;\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConfirmSelectOk(buffer) {\n  var fields = {};\n  return fields;\n}\n\nfunction encodeConfirmSelectOk(channel, fields) {\n  var offset = 0, varyingSize = 0, buffer = Buffer.alloc(12 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5570571, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction encodeBasicProperties(channel, size, fields) {\n  var val, len, offset = 0, flags = 0, scratchOffset = 0, varyingSize = 0;\n  val = fields.contentType;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'contentType' is the wrong type; must be a string (up to 255 chars)\");\n    var contentType_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += contentType_len;\n  }\n  val = fields.contentEncoding;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'contentEncoding' is the wrong type; must be a string (up to 255 chars)\");\n    var contentEncoding_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += contentEncoding_len;\n  }\n  val = fields.headers;\n  if (void 0 != val) {\n    if (\"object\" != typeof val) throw new TypeError(\"Field 'headers' is the wrong type; must be an object\");\n    len = encodeTable(SCRATCH, val, scratchOffset);\n    var headers_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n    scratchOffset += len;\n    varyingSize += headers_encoded.length;\n  }\n  val = fields.deliveryMode;\n  if (void 0 != val) {\n    if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'deliveryMode' is the wrong type; must be a number (but not NaN)\");\n    varyingSize += 1;\n  }\n  val = fields.priority;\n  if (void 0 != val) {\n    if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'priority' is the wrong type; must be a number (but not NaN)\");\n    varyingSize += 1;\n  }\n  val = fields.correlationId;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'correlationId' is the wrong type; must be a string (up to 255 chars)\");\n    var correlationId_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += correlationId_len;\n  }\n  val = fields.replyTo;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'replyTo' is the wrong type; must be a string (up to 255 chars)\");\n    var replyTo_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += replyTo_len;\n  }\n  val = fields.expiration;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'expiration' is the wrong type; must be a string (up to 255 chars)\");\n    var expiration_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += expiration_len;\n  }\n  val = fields.messageId;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'messageId' is the wrong type; must be a string (up to 255 chars)\");\n    var messageId_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += messageId_len;\n  }\n  val = fields.timestamp;\n  if (void 0 != val) {\n    if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'timestamp' is the wrong type; must be a number (but not NaN)\");\n    varyingSize += 8;\n  }\n  val = fields.type;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'type' is the wrong type; must be a string (up to 255 chars)\");\n    var type_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += type_len;\n  }\n  val = fields.userId;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'userId' is the wrong type; must be a string (up to 255 chars)\");\n    var userId_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += userId_len;\n  }\n  val = fields.appId;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'appId' is the wrong type; must be a string (up to 255 chars)\");\n    var appId_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += appId_len;\n  }\n  val = fields.clusterId;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'clusterId' is the wrong type; must be a string (up to 255 chars)\");\n    var clusterId_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += clusterId_len;\n  }\n  var buffer = Buffer.alloc(22 + varyingSize);\n  buffer[0] = 2;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932160, 7);\n  ints.writeUInt64BE(buffer, size, 11);\n  flags = 0;\n  offset = 21;\n  val = fields.contentType;\n  if (void 0 != val) {\n    flags += 32768;\n    buffer[offset] = contentType_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += contentType_len;\n  }\n  val = fields.contentEncoding;\n  if (void 0 != val) {\n    flags += 16384;\n    buffer[offset] = contentEncoding_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += contentEncoding_len;\n  }\n  val = fields.headers;\n  if (void 0 != val) {\n    flags += 8192;\n    offset += headers_encoded.copy(buffer, offset);\n  }\n  val = fields.deliveryMode;\n  if (void 0 != val) {\n    flags += 4096;\n    buffer.writeUInt8(val, offset);\n    offset++;\n  }\n  val = fields.priority;\n  if (void 0 != val) {\n    flags += 2048;\n    buffer.writeUInt8(val, offset);\n    offset++;\n  }\n  val = fields.correlationId;\n  if (void 0 != val) {\n    flags += 1024;\n    buffer[offset] = correlationId_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += correlationId_len;\n  }\n  val = fields.replyTo;\n  if (void 0 != val) {\n    flags += 512;\n    buffer[offset] = replyTo_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += replyTo_len;\n  }\n  val = fields.expiration;\n  if (void 0 != val) {\n    flags += 256;\n    buffer[offset] = expiration_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += expiration_len;\n  }\n  val = fields.messageId;\n  if (void 0 != val) {\n    flags += 128;\n    buffer[offset] = messageId_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += messageId_len;\n  }\n  val = fields.timestamp;\n  if (void 0 != val) {\n    flags += 64;\n    ints.writeUInt64BE(buffer, val, offset);\n    offset += 8;\n  }\n  val = fields.type;\n  if (void 0 != val) {\n    flags += 32;\n    buffer[offset] = type_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += type_len;\n  }\n  val = fields.userId;\n  if (void 0 != val) {\n    flags += 16;\n    buffer[offset] = userId_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += userId_len;\n  }\n  val = fields.appId;\n  if (void 0 != val) {\n    flags += 8;\n    buffer[offset] = appId_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += appId_len;\n  }\n  val = fields.clusterId;\n  if (void 0 != val) {\n    flags += 4;\n    buffer[offset] = clusterId_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += clusterId_len;\n  }\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  buffer.writeUInt16BE(flags, 19);\n  return buffer.slice(0, offset + 1);\n}\n\nfunction decodeBasicProperties(buffer) {\n  var flags, val, len, offset = 2;\n  flags = buffer.readUInt16BE(0);\n  if (0 === flags) return {};\n  var fields = {\n    contentType: void 0,\n    contentEncoding: void 0,\n    headers: void 0,\n    deliveryMode: void 0,\n    priority: void 0,\n    correlationId: void 0,\n    replyTo: void 0,\n    expiration: void 0,\n    messageId: void 0,\n    timestamp: void 0,\n    type: void 0,\n    userId: void 0,\n    appId: void 0,\n    clusterId: void 0\n  };\n  if (32768 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.contentType = val;\n  }\n  if (16384 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.contentEncoding = val;\n  }\n  if (8192 & flags) {\n    len = buffer.readUInt32BE(offset);\n    offset += 4;\n    val = decodeFields(buffer.slice(offset, offset + len));\n    offset += len;\n    fields.headers = val;\n  }\n  if (4096 & flags) {\n    val = buffer[offset];\n    offset++;\n    fields.deliveryMode = val;\n  }\n  if (2048 & flags) {\n    val = buffer[offset];\n    offset++;\n    fields.priority = val;\n  }\n  if (1024 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.correlationId = val;\n  }\n  if (512 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.replyTo = val;\n  }\n  if (256 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.expiration = val;\n  }\n  if (128 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.messageId = val;\n  }\n  if (64 & flags) {\n    val = ints.readUInt64BE(buffer, offset);\n    offset += 8;\n    fields.timestamp = val;\n  }\n  if (32 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.type = val;\n  }\n  if (16 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.userId = val;\n  }\n  if (8 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.appId = val;\n  }\n  if (4 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.clusterId = val;\n  }\n  return fields;\n}\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer, codec = __webpack_require__(/*! ./codec */ \"./node_modules/amqplib/lib/codec.js\"), ints = __webpack_require__(/*! buffer-more-ints */ \"./node_modules/buffer-more-ints/buffer-more-ints.js\"), encodeTable = codec.encodeTable, decodeFields = codec.decodeFields, SCRATCH = Buffer.alloc(16384), EMPTY_OBJECT = Object.freeze({});\n\nmodule.exports.constants = {\n  FRAME_METHOD: 1,\n  FRAME_HEADER: 2,\n  FRAME_BODY: 3,\n  FRAME_HEARTBEAT: 8,\n  FRAME_MIN_SIZE: 4096,\n  FRAME_END: 206,\n  REPLY_SUCCESS: 200,\n  CONTENT_TOO_LARGE: 311,\n  NO_ROUTE: 312,\n  NO_CONSUMERS: 313,\n  ACCESS_REFUSED: 403,\n  NOT_FOUND: 404,\n  RESOURCE_LOCKED: 405,\n  PRECONDITION_FAILED: 406,\n  CONNECTION_FORCED: 320,\n  INVALID_PATH: 402,\n  FRAME_ERROR: 501,\n  SYNTAX_ERROR: 502,\n  COMMAND_INVALID: 503,\n  CHANNEL_ERROR: 504,\n  UNEXPECTED_FRAME: 505,\n  RESOURCE_ERROR: 506,\n  NOT_ALLOWED: 530,\n  NOT_IMPLEMENTED: 540,\n  INTERNAL_ERROR: 541\n};\n\nmodule.exports.constant_strs = {\n  \"1\": \"FRAME-METHOD\",\n  \"2\": \"FRAME-HEADER\",\n  \"3\": \"FRAME-BODY\",\n  \"8\": \"FRAME-HEARTBEAT\",\n  \"200\": \"REPLY-SUCCESS\",\n  \"206\": \"FRAME-END\",\n  \"311\": \"CONTENT-TOO-LARGE\",\n  \"312\": \"NO-ROUTE\",\n  \"313\": \"NO-CONSUMERS\",\n  \"320\": \"CONNECTION-FORCED\",\n  \"402\": \"INVALID-PATH\",\n  \"403\": \"ACCESS-REFUSED\",\n  \"404\": \"NOT-FOUND\",\n  \"405\": \"RESOURCE-LOCKED\",\n  \"406\": \"PRECONDITION-FAILED\",\n  \"501\": \"FRAME-ERROR\",\n  \"502\": \"SYNTAX-ERROR\",\n  \"503\": \"COMMAND-INVALID\",\n  \"504\": \"CHANNEL-ERROR\",\n  \"505\": \"UNEXPECTED-FRAME\",\n  \"506\": \"RESOURCE-ERROR\",\n  \"530\": \"NOT-ALLOWED\",\n  \"540\": \"NOT-IMPLEMENTED\",\n  \"541\": \"INTERNAL-ERROR\",\n  \"4096\": \"FRAME-MIN-SIZE\"\n};\n\nmodule.exports.FRAME_OVERHEAD = 8;\n\nmodule.exports.decode = function(id, buf) {\n  switch (id) {\n   case 655370:\n    return decodeConnectionStart(buf);\n\n   case 655371:\n    return decodeConnectionStartOk(buf);\n\n   case 655380:\n    return decodeConnectionSecure(buf);\n\n   case 655381:\n    return decodeConnectionSecureOk(buf);\n\n   case 655390:\n    return decodeConnectionTune(buf);\n\n   case 655391:\n    return decodeConnectionTuneOk(buf);\n\n   case 655400:\n    return decodeConnectionOpen(buf);\n\n   case 655401:\n    return decodeConnectionOpenOk(buf);\n\n   case 655410:\n    return decodeConnectionClose(buf);\n\n   case 655411:\n    return decodeConnectionCloseOk(buf);\n\n   case 655420:\n    return decodeConnectionBlocked(buf);\n\n   case 655421:\n    return decodeConnectionUnblocked(buf);\n\n   case 1310730:\n    return decodeChannelOpen(buf);\n\n   case 1310731:\n    return decodeChannelOpenOk(buf);\n\n   case 1310740:\n    return decodeChannelFlow(buf);\n\n   case 1310741:\n    return decodeChannelFlowOk(buf);\n\n   case 1310760:\n    return decodeChannelClose(buf);\n\n   case 1310761:\n    return decodeChannelCloseOk(buf);\n\n   case 1966090:\n    return decodeAccessRequest(buf);\n\n   case 1966091:\n    return decodeAccessRequestOk(buf);\n\n   case 2621450:\n    return decodeExchangeDeclare(buf);\n\n   case 2621451:\n    return decodeExchangeDeclareOk(buf);\n\n   case 2621460:\n    return decodeExchangeDelete(buf);\n\n   case 2621461:\n    return decodeExchangeDeleteOk(buf);\n\n   case 2621470:\n    return decodeExchangeBind(buf);\n\n   case 2621471:\n    return decodeExchangeBindOk(buf);\n\n   case 2621480:\n    return decodeExchangeUnbind(buf);\n\n   case 2621491:\n    return decodeExchangeUnbindOk(buf);\n\n   case 3276810:\n    return decodeQueueDeclare(buf);\n\n   case 3276811:\n    return decodeQueueDeclareOk(buf);\n\n   case 3276820:\n    return decodeQueueBind(buf);\n\n   case 3276821:\n    return decodeQueueBindOk(buf);\n\n   case 3276830:\n    return decodeQueuePurge(buf);\n\n   case 3276831:\n    return decodeQueuePurgeOk(buf);\n\n   case 3276840:\n    return decodeQueueDelete(buf);\n\n   case 3276841:\n    return decodeQueueDeleteOk(buf);\n\n   case 3276850:\n    return decodeQueueUnbind(buf);\n\n   case 3276851:\n    return decodeQueueUnbindOk(buf);\n\n   case 3932170:\n    return decodeBasicQos(buf);\n\n   case 3932171:\n    return decodeBasicQosOk(buf);\n\n   case 3932180:\n    return decodeBasicConsume(buf);\n\n   case 3932181:\n    return decodeBasicConsumeOk(buf);\n\n   case 3932190:\n    return decodeBasicCancel(buf);\n\n   case 3932191:\n    return decodeBasicCancelOk(buf);\n\n   case 3932200:\n    return decodeBasicPublish(buf);\n\n   case 3932210:\n    return decodeBasicReturn(buf);\n\n   case 3932220:\n    return decodeBasicDeliver(buf);\n\n   case 3932230:\n    return decodeBasicGet(buf);\n\n   case 3932231:\n    return decodeBasicGetOk(buf);\n\n   case 3932232:\n    return decodeBasicGetEmpty(buf);\n\n   case 3932240:\n    return decodeBasicAck(buf);\n\n   case 3932250:\n    return decodeBasicReject(buf);\n\n   case 3932260:\n    return decodeBasicRecoverAsync(buf);\n\n   case 3932270:\n    return decodeBasicRecover(buf);\n\n   case 3932271:\n    return decodeBasicRecoverOk(buf);\n\n   case 3932280:\n    return decodeBasicNack(buf);\n\n   case 5898250:\n    return decodeTxSelect(buf);\n\n   case 5898251:\n    return decodeTxSelectOk(buf);\n\n   case 5898260:\n    return decodeTxCommit(buf);\n\n   case 5898261:\n    return decodeTxCommitOk(buf);\n\n   case 5898270:\n    return decodeTxRollback(buf);\n\n   case 5898271:\n    return decodeTxRollbackOk(buf);\n\n   case 5570570:\n    return decodeConfirmSelect(buf);\n\n   case 5570571:\n    return decodeConfirmSelectOk(buf);\n\n   case 60:\n    return decodeBasicProperties(buf);\n\n   default:\n    throw new Error(\"Unknown class/method ID\");\n  }\n};\n\nmodule.exports.encodeMethod = function(id, channel, fields) {\n  switch (id) {\n   case 655370:\n    return encodeConnectionStart(channel, fields);\n\n   case 655371:\n    return encodeConnectionStartOk(channel, fields);\n\n   case 655380:\n    return encodeConnectionSecure(channel, fields);\n\n   case 655381:\n    return encodeConnectionSecureOk(channel, fields);\n\n   case 655390:\n    return encodeConnectionTune(channel, fields);\n\n   case 655391:\n    return encodeConnectionTuneOk(channel, fields);\n\n   case 655400:\n    return encodeConnectionOpen(channel, fields);\n\n   case 655401:\n    return encodeConnectionOpenOk(channel, fields);\n\n   case 655410:\n    return encodeConnectionClose(channel, fields);\n\n   case 655411:\n    return encodeConnectionCloseOk(channel, fields);\n\n   case 655420:\n    return encodeConnectionBlocked(channel, fields);\n\n   case 655421:\n    return encodeConnectionUnblocked(channel, fields);\n\n   case 1310730:\n    return encodeChannelOpen(channel, fields);\n\n   case 1310731:\n    return encodeChannelOpenOk(channel, fields);\n\n   case 1310740:\n    return encodeChannelFlow(channel, fields);\n\n   case 1310741:\n    return encodeChannelFlowOk(channel, fields);\n\n   case 1310760:\n    return encodeChannelClose(channel, fields);\n\n   case 1310761:\n    return encodeChannelCloseOk(channel, fields);\n\n   case 1966090:\n    return encodeAccessRequest(channel, fields);\n\n   case 1966091:\n    return encodeAccessRequestOk(channel, fields);\n\n   case 2621450:\n    return encodeExchangeDeclare(channel, fields);\n\n   case 2621451:\n    return encodeExchangeDeclareOk(channel, fields);\n\n   case 2621460:\n    return encodeExchangeDelete(channel, fields);\n\n   case 2621461:\n    return encodeExchangeDeleteOk(channel, fields);\n\n   case 2621470:\n    return encodeExchangeBind(channel, fields);\n\n   case 2621471:\n    return encodeExchangeBindOk(channel, fields);\n\n   case 2621480:\n    return encodeExchangeUnbind(channel, fields);\n\n   case 2621491:\n    return encodeExchangeUnbindOk(channel, fields);\n\n   case 3276810:\n    return encodeQueueDeclare(channel, fields);\n\n   case 3276811:\n    return encodeQueueDeclareOk(channel, fields);\n\n   case 3276820:\n    return encodeQueueBind(channel, fields);\n\n   case 3276821:\n    return encodeQueueBindOk(channel, fields);\n\n   case 3276830:\n    return encodeQueuePurge(channel, fields);\n\n   case 3276831:\n    return encodeQueuePurgeOk(channel, fields);\n\n   case 3276840:\n    return encodeQueueDelete(channel, fields);\n\n   case 3276841:\n    return encodeQueueDeleteOk(channel, fields);\n\n   case 3276850:\n    return encodeQueueUnbind(channel, fields);\n\n   case 3276851:\n    return encodeQueueUnbindOk(channel, fields);\n\n   case 3932170:\n    return encodeBasicQos(channel, fields);\n\n   case 3932171:\n    return encodeBasicQosOk(channel, fields);\n\n   case 3932180:\n    return encodeBasicConsume(channel, fields);\n\n   case 3932181:\n    return encodeBasicConsumeOk(channel, fields);\n\n   case 3932190:\n    return encodeBasicCancel(channel, fields);\n\n   case 3932191:\n    return encodeBasicCancelOk(channel, fields);\n\n   case 3932200:\n    return encodeBasicPublish(channel, fields);\n\n   case 3932210:\n    return encodeBasicReturn(channel, fields);\n\n   case 3932220:\n    return encodeBasicDeliver(channel, fields);\n\n   case 3932230:\n    return encodeBasicGet(channel, fields);\n\n   case 3932231:\n    return encodeBasicGetOk(channel, fields);\n\n   case 3932232:\n    return encodeBasicGetEmpty(channel, fields);\n\n   case 3932240:\n    return encodeBasicAck(channel, fields);\n\n   case 3932250:\n    return encodeBasicReject(channel, fields);\n\n   case 3932260:\n    return encodeBasicRecoverAsync(channel, fields);\n\n   case 3932270:\n    return encodeBasicRecover(channel, fields);\n\n   case 3932271:\n    return encodeBasicRecoverOk(channel, fields);\n\n   case 3932280:\n    return encodeBasicNack(channel, fields);\n\n   case 5898250:\n    return encodeTxSelect(channel, fields);\n\n   case 5898251:\n    return encodeTxSelectOk(channel, fields);\n\n   case 5898260:\n    return encodeTxCommit(channel, fields);\n\n   case 5898261:\n    return encodeTxCommitOk(channel, fields);\n\n   case 5898270:\n    return encodeTxRollback(channel, fields);\n\n   case 5898271:\n    return encodeTxRollbackOk(channel, fields);\n\n   case 5570570:\n    return encodeConfirmSelect(channel, fields);\n\n   case 5570571:\n    return encodeConfirmSelectOk(channel, fields);\n\n   default:\n    throw new Error(\"Unknown class/method ID\");\n  }\n};\n\nmodule.exports.encodeProperties = function(id, channel, size, fields) {\n  switch (id) {\n   case 60:\n    return encodeBasicProperties(channel, size, fields);\n\n   default:\n    throw new Error(\"Unknown class/properties ID\");\n  }\n};\n\nmodule.exports.info = function(id) {\n  switch (id) {\n   case 655370:\n    return methodInfoConnectionStart;\n\n   case 655371:\n    return methodInfoConnectionStartOk;\n\n   case 655380:\n    return methodInfoConnectionSecure;\n\n   case 655381:\n    return methodInfoConnectionSecureOk;\n\n   case 655390:\n    return methodInfoConnectionTune;\n\n   case 655391:\n    return methodInfoConnectionTuneOk;\n\n   case 655400:\n    return methodInfoConnectionOpen;\n\n   case 655401:\n    return methodInfoConnectionOpenOk;\n\n   case 655410:\n    return methodInfoConnectionClose;\n\n   case 655411:\n    return methodInfoConnectionCloseOk;\n\n   case 655420:\n    return methodInfoConnectionBlocked;\n\n   case 655421:\n    return methodInfoConnectionUnblocked;\n\n   case 1310730:\n    return methodInfoChannelOpen;\n\n   case 1310731:\n    return methodInfoChannelOpenOk;\n\n   case 1310740:\n    return methodInfoChannelFlow;\n\n   case 1310741:\n    return methodInfoChannelFlowOk;\n\n   case 1310760:\n    return methodInfoChannelClose;\n\n   case 1310761:\n    return methodInfoChannelCloseOk;\n\n   case 1966090:\n    return methodInfoAccessRequest;\n\n   case 1966091:\n    return methodInfoAccessRequestOk;\n\n   case 2621450:\n    return methodInfoExchangeDeclare;\n\n   case 2621451:\n    return methodInfoExchangeDeclareOk;\n\n   case 2621460:\n    return methodInfoExchangeDelete;\n\n   case 2621461:\n    return methodInfoExchangeDeleteOk;\n\n   case 2621470:\n    return methodInfoExchangeBind;\n\n   case 2621471:\n    return methodInfoExchangeBindOk;\n\n   case 2621480:\n    return methodInfoExchangeUnbind;\n\n   case 2621491:\n    return methodInfoExchangeUnbindOk;\n\n   case 3276810:\n    return methodInfoQueueDeclare;\n\n   case 3276811:\n    return methodInfoQueueDeclareOk;\n\n   case 3276820:\n    return methodInfoQueueBind;\n\n   case 3276821:\n    return methodInfoQueueBindOk;\n\n   case 3276830:\n    return methodInfoQueuePurge;\n\n   case 3276831:\n    return methodInfoQueuePurgeOk;\n\n   case 3276840:\n    return methodInfoQueueDelete;\n\n   case 3276841:\n    return methodInfoQueueDeleteOk;\n\n   case 3276850:\n    return methodInfoQueueUnbind;\n\n   case 3276851:\n    return methodInfoQueueUnbindOk;\n\n   case 3932170:\n    return methodInfoBasicQos;\n\n   case 3932171:\n    return methodInfoBasicQosOk;\n\n   case 3932180:\n    return methodInfoBasicConsume;\n\n   case 3932181:\n    return methodInfoBasicConsumeOk;\n\n   case 3932190:\n    return methodInfoBasicCancel;\n\n   case 3932191:\n    return methodInfoBasicCancelOk;\n\n   case 3932200:\n    return methodInfoBasicPublish;\n\n   case 3932210:\n    return methodInfoBasicReturn;\n\n   case 3932220:\n    return methodInfoBasicDeliver;\n\n   case 3932230:\n    return methodInfoBasicGet;\n\n   case 3932231:\n    return methodInfoBasicGetOk;\n\n   case 3932232:\n    return methodInfoBasicGetEmpty;\n\n   case 3932240:\n    return methodInfoBasicAck;\n\n   case 3932250:\n    return methodInfoBasicReject;\n\n   case 3932260:\n    return methodInfoBasicRecoverAsync;\n\n   case 3932270:\n    return methodInfoBasicRecover;\n\n   case 3932271:\n    return methodInfoBasicRecoverOk;\n\n   case 3932280:\n    return methodInfoBasicNack;\n\n   case 5898250:\n    return methodInfoTxSelect;\n\n   case 5898251:\n    return methodInfoTxSelectOk;\n\n   case 5898260:\n    return methodInfoTxCommit;\n\n   case 5898261:\n    return methodInfoTxCommitOk;\n\n   case 5898270:\n    return methodInfoTxRollback;\n\n   case 5898271:\n    return methodInfoTxRollbackOk;\n\n   case 5570570:\n    return methodInfoConfirmSelect;\n\n   case 5570571:\n    return methodInfoConfirmSelectOk;\n\n   case 60:\n    return propertiesInfoBasicProperties;\n\n   default:\n    throw new Error(\"Unknown class/method ID\");\n  }\n};\n\nmodule.exports.ConnectionStart = 655370;\n\nvar methodInfoConnectionStart = module.exports.methodInfoConnectionStart = {\n  id: 655370,\n  name: \"ConnectionStart\",\n  args: [ {\n    type: \"octet\",\n    name: \"versionMajor\",\n    \"default\": 0\n  }, {\n    type: \"octet\",\n    name: \"versionMinor\",\n    \"default\": 9\n  }, {\n    type: \"table\",\n    name: \"serverProperties\"\n  }, {\n    type: \"longstr\",\n    name: \"mechanisms\",\n    \"default\": \"PLAIN\"\n  }, {\n    type: \"longstr\",\n    name: \"locales\",\n    \"default\": \"en_US\"\n  } ]\n};\n\nmodule.exports.ConnectionStartOk = 655371;\n\nvar methodInfoConnectionStartOk = module.exports.methodInfoConnectionStartOk = {\n  id: 655371,\n  name: \"ConnectionStartOk\",\n  args: [ {\n    type: \"table\",\n    name: \"clientProperties\"\n  }, {\n    type: \"shortstr\",\n    name: \"mechanism\",\n    \"default\": \"PLAIN\"\n  }, {\n    type: \"longstr\",\n    name: \"response\"\n  }, {\n    type: \"shortstr\",\n    name: \"locale\",\n    \"default\": \"en_US\"\n  } ]\n};\n\nmodule.exports.ConnectionSecure = 655380;\n\nvar methodInfoConnectionSecure = module.exports.methodInfoConnectionSecure = {\n  id: 655380,\n  name: \"ConnectionSecure\",\n  args: [ {\n    type: \"longstr\",\n    name: \"challenge\"\n  } ]\n};\n\nmodule.exports.ConnectionSecureOk = 655381;\n\nvar methodInfoConnectionSecureOk = module.exports.methodInfoConnectionSecureOk = {\n  id: 655381,\n  name: \"ConnectionSecureOk\",\n  args: [ {\n    type: \"longstr\",\n    name: \"response\"\n  } ]\n};\n\nmodule.exports.ConnectionTune = 655390;\n\nvar methodInfoConnectionTune = module.exports.methodInfoConnectionTune = {\n  id: 655390,\n  name: \"ConnectionTune\",\n  args: [ {\n    type: \"short\",\n    name: \"channelMax\",\n    \"default\": 0\n  }, {\n    type: \"long\",\n    name: \"frameMax\",\n    \"default\": 0\n  }, {\n    type: \"short\",\n    name: \"heartbeat\",\n    \"default\": 0\n  } ]\n};\n\nmodule.exports.ConnectionTuneOk = 655391;\n\nvar methodInfoConnectionTuneOk = module.exports.methodInfoConnectionTuneOk = {\n  id: 655391,\n  name: \"ConnectionTuneOk\",\n  args: [ {\n    type: \"short\",\n    name: \"channelMax\",\n    \"default\": 0\n  }, {\n    type: \"long\",\n    name: \"frameMax\",\n    \"default\": 0\n  }, {\n    type: \"short\",\n    name: \"heartbeat\",\n    \"default\": 0\n  } ]\n};\n\nmodule.exports.ConnectionOpen = 655400;\n\nvar methodInfoConnectionOpen = module.exports.methodInfoConnectionOpen = {\n  id: 655400,\n  name: \"ConnectionOpen\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"virtualHost\",\n    \"default\": \"/\"\n  }, {\n    type: \"shortstr\",\n    name: \"capabilities\",\n    \"default\": \"\"\n  }, {\n    type: \"bit\",\n    name: \"insist\",\n    \"default\": !1\n  } ]\n};\n\nmodule.exports.ConnectionOpenOk = 655401;\n\nvar methodInfoConnectionOpenOk = module.exports.methodInfoConnectionOpenOk = {\n  id: 655401,\n  name: \"ConnectionOpenOk\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"knownHosts\",\n    \"default\": \"\"\n  } ]\n};\n\nmodule.exports.ConnectionClose = 655410;\n\nvar methodInfoConnectionClose = module.exports.methodInfoConnectionClose = {\n  id: 655410,\n  name: \"ConnectionClose\",\n  args: [ {\n    type: \"short\",\n    name: \"replyCode\"\n  }, {\n    type: \"shortstr\",\n    name: \"replyText\",\n    \"default\": \"\"\n  }, {\n    type: \"short\",\n    name: \"classId\"\n  }, {\n    type: \"short\",\n    name: \"methodId\"\n  } ]\n};\n\nmodule.exports.ConnectionCloseOk = 655411;\n\nvar methodInfoConnectionCloseOk = module.exports.methodInfoConnectionCloseOk = {\n  id: 655411,\n  name: \"ConnectionCloseOk\",\n  args: []\n};\n\nmodule.exports.ConnectionBlocked = 655420;\n\nvar methodInfoConnectionBlocked = module.exports.methodInfoConnectionBlocked = {\n  id: 655420,\n  name: \"ConnectionBlocked\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"reason\",\n    \"default\": \"\"\n  } ]\n};\n\nmodule.exports.ConnectionUnblocked = 655421;\n\nvar methodInfoConnectionUnblocked = module.exports.methodInfoConnectionUnblocked = {\n  id: 655421,\n  name: \"ConnectionUnblocked\",\n  args: []\n};\n\nmodule.exports.ChannelOpen = 1310730;\n\nvar methodInfoChannelOpen = module.exports.methodInfoChannelOpen = {\n  id: 1310730,\n  name: \"ChannelOpen\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"outOfBand\",\n    \"default\": \"\"\n  } ]\n};\n\nmodule.exports.ChannelOpenOk = 1310731;\n\nvar methodInfoChannelOpenOk = module.exports.methodInfoChannelOpenOk = {\n  id: 1310731,\n  name: \"ChannelOpenOk\",\n  args: [ {\n    type: \"longstr\",\n    name: \"channelId\",\n    \"default\": \"\"\n  } ]\n};\n\nmodule.exports.ChannelFlow = 1310740;\n\nvar methodInfoChannelFlow = module.exports.methodInfoChannelFlow = {\n  id: 1310740,\n  name: \"ChannelFlow\",\n  args: [ {\n    type: \"bit\",\n    name: \"active\"\n  } ]\n};\n\nmodule.exports.ChannelFlowOk = 1310741;\n\nvar methodInfoChannelFlowOk = module.exports.methodInfoChannelFlowOk = {\n  id: 1310741,\n  name: \"ChannelFlowOk\",\n  args: [ {\n    type: \"bit\",\n    name: \"active\"\n  } ]\n};\n\nmodule.exports.ChannelClose = 1310760;\n\nvar methodInfoChannelClose = module.exports.methodInfoChannelClose = {\n  id: 1310760,\n  name: \"ChannelClose\",\n  args: [ {\n    type: \"short\",\n    name: \"replyCode\"\n  }, {\n    type: \"shortstr\",\n    name: \"replyText\",\n    \"default\": \"\"\n  }, {\n    type: \"short\",\n    name: \"classId\"\n  }, {\n    type: \"short\",\n    name: \"methodId\"\n  } ]\n};\n\nmodule.exports.ChannelCloseOk = 1310761;\n\nvar methodInfoChannelCloseOk = module.exports.methodInfoChannelCloseOk = {\n  id: 1310761,\n  name: \"ChannelCloseOk\",\n  args: []\n};\n\nmodule.exports.AccessRequest = 1966090;\n\nvar methodInfoAccessRequest = module.exports.methodInfoAccessRequest = {\n  id: 1966090,\n  name: \"AccessRequest\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"realm\",\n    \"default\": \"/data\"\n  }, {\n    type: \"bit\",\n    name: \"exclusive\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"passive\",\n    \"default\": !0\n  }, {\n    type: \"bit\",\n    name: \"active\",\n    \"default\": !0\n  }, {\n    type: \"bit\",\n    name: \"write\",\n    \"default\": !0\n  }, {\n    type: \"bit\",\n    name: \"read\",\n    \"default\": !0\n  } ]\n};\n\nmodule.exports.AccessRequestOk = 1966091;\n\nvar methodInfoAccessRequestOk = module.exports.methodInfoAccessRequestOk = {\n  id: 1966091,\n  name: \"AccessRequestOk\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    \"default\": 1\n  } ]\n};\n\nmodule.exports.ExchangeDeclare = 2621450;\n\nvar methodInfoExchangeDeclare = module.exports.methodInfoExchangeDeclare = {\n  id: 2621450,\n  name: \"ExchangeDeclare\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    \"default\": 0\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"shortstr\",\n    name: \"type\",\n    \"default\": \"direct\"\n  }, {\n    type: \"bit\",\n    name: \"passive\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"durable\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"autoDelete\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"internal\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    \"default\": !1\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    \"default\": {}\n  } ]\n};\n\nmodule.exports.ExchangeDeclareOk = 2621451;\n\nvar methodInfoExchangeDeclareOk = module.exports.methodInfoExchangeDeclareOk = {\n  id: 2621451,\n  name: \"ExchangeDeclareOk\",\n  args: []\n};\n\nmodule.exports.ExchangeDelete = 2621460;\n\nvar methodInfoExchangeDelete = module.exports.methodInfoExchangeDelete = {\n  id: 2621460,\n  name: \"ExchangeDelete\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    \"default\": 0\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"bit\",\n    name: \"ifUnused\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    \"default\": !1\n  } ]\n};\n\nmodule.exports.ExchangeDeleteOk = 2621461;\n\nvar methodInfoExchangeDeleteOk = module.exports.methodInfoExchangeDeleteOk = {\n  id: 2621461,\n  name: \"ExchangeDeleteOk\",\n  args: []\n};\n\nmodule.exports.ExchangeBind = 2621470;\n\nvar methodInfoExchangeBind = module.exports.methodInfoExchangeBind = {\n  id: 2621470,\n  name: \"ExchangeBind\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    \"default\": 0\n  }, {\n    type: \"shortstr\",\n    name: \"destination\"\n  }, {\n    type: \"shortstr\",\n    name: \"source\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\",\n    \"default\": \"\"\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    \"default\": !1\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    \"default\": {}\n  } ]\n};\n\nmodule.exports.ExchangeBindOk = 2621471;\n\nvar methodInfoExchangeBindOk = module.exports.methodInfoExchangeBindOk = {\n  id: 2621471,\n  name: \"ExchangeBindOk\",\n  args: []\n};\n\nmodule.exports.ExchangeUnbind = 2621480;\n\nvar methodInfoExchangeUnbind = module.exports.methodInfoExchangeUnbind = {\n  id: 2621480,\n  name: \"ExchangeUnbind\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    \"default\": 0\n  }, {\n    type: \"shortstr\",\n    name: \"destination\"\n  }, {\n    type: \"shortstr\",\n    name: \"source\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\",\n    \"default\": \"\"\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    \"default\": !1\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    \"default\": {}\n  } ]\n};\n\nmodule.exports.ExchangeUnbindOk = 2621491;\n\nvar methodInfoExchangeUnbindOk = module.exports.methodInfoExchangeUnbindOk = {\n  id: 2621491,\n  name: \"ExchangeUnbindOk\",\n  args: []\n};\n\nmodule.exports.QueueDeclare = 3276810;\n\nvar methodInfoQueueDeclare = module.exports.methodInfoQueueDeclare = {\n  id: 3276810,\n  name: \"QueueDeclare\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    \"default\": 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    \"default\": \"\"\n  }, {\n    type: \"bit\",\n    name: \"passive\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"durable\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"exclusive\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"autoDelete\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    \"default\": !1\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    \"default\": {}\n  } ]\n};\n\nmodule.exports.QueueDeclareOk = 3276811;\n\nvar methodInfoQueueDeclareOk = module.exports.methodInfoQueueDeclareOk = {\n  id: 3276811,\n  name: \"QueueDeclareOk\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"queue\"\n  }, {\n    type: \"long\",\n    name: \"messageCount\"\n  }, {\n    type: \"long\",\n    name: \"consumerCount\"\n  } ]\n};\n\nmodule.exports.QueueBind = 3276820;\n\nvar methodInfoQueueBind = module.exports.methodInfoQueueBind = {\n  id: 3276820,\n  name: \"QueueBind\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    \"default\": 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    \"default\": \"\"\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\",\n    \"default\": \"\"\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    \"default\": !1\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    \"default\": {}\n  } ]\n};\n\nmodule.exports.QueueBindOk = 3276821;\n\nvar methodInfoQueueBindOk = module.exports.methodInfoQueueBindOk = {\n  id: 3276821,\n  name: \"QueueBindOk\",\n  args: []\n};\n\nmodule.exports.QueuePurge = 3276830;\n\nvar methodInfoQueuePurge = module.exports.methodInfoQueuePurge = {\n  id: 3276830,\n  name: \"QueuePurge\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    \"default\": 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    \"default\": \"\"\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    \"default\": !1\n  } ]\n};\n\nmodule.exports.QueuePurgeOk = 3276831;\n\nvar methodInfoQueuePurgeOk = module.exports.methodInfoQueuePurgeOk = {\n  id: 3276831,\n  name: \"QueuePurgeOk\",\n  args: [ {\n    type: \"long\",\n    name: \"messageCount\"\n  } ]\n};\n\nmodule.exports.QueueDelete = 3276840;\n\nvar methodInfoQueueDelete = module.exports.methodInfoQueueDelete = {\n  id: 3276840,\n  name: \"QueueDelete\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    \"default\": 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    \"default\": \"\"\n  }, {\n    type: \"bit\",\n    name: \"ifUnused\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"ifEmpty\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    \"default\": !1\n  } ]\n};\n\nmodule.exports.QueueDeleteOk = 3276841;\n\nvar methodInfoQueueDeleteOk = module.exports.methodInfoQueueDeleteOk = {\n  id: 3276841,\n  name: \"QueueDeleteOk\",\n  args: [ {\n    type: \"long\",\n    name: \"messageCount\"\n  } ]\n};\n\nmodule.exports.QueueUnbind = 3276850;\n\nvar methodInfoQueueUnbind = module.exports.methodInfoQueueUnbind = {\n  id: 3276850,\n  name: \"QueueUnbind\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    \"default\": 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    \"default\": \"\"\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\",\n    \"default\": \"\"\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    \"default\": {}\n  } ]\n};\n\nmodule.exports.QueueUnbindOk = 3276851;\n\nvar methodInfoQueueUnbindOk = module.exports.methodInfoQueueUnbindOk = {\n  id: 3276851,\n  name: \"QueueUnbindOk\",\n  args: []\n};\n\nmodule.exports.BasicQos = 3932170;\n\nvar methodInfoBasicQos = module.exports.methodInfoBasicQos = {\n  id: 3932170,\n  name: \"BasicQos\",\n  args: [ {\n    type: \"long\",\n    name: \"prefetchSize\",\n    \"default\": 0\n  }, {\n    type: \"short\",\n    name: \"prefetchCount\",\n    \"default\": 0\n  }, {\n    type: \"bit\",\n    name: \"global\",\n    \"default\": !1\n  } ]\n};\n\nmodule.exports.BasicQosOk = 3932171;\n\nvar methodInfoBasicQosOk = module.exports.methodInfoBasicQosOk = {\n  id: 3932171,\n  name: \"BasicQosOk\",\n  args: []\n};\n\nmodule.exports.BasicConsume = 3932180;\n\nvar methodInfoBasicConsume = module.exports.methodInfoBasicConsume = {\n  id: 3932180,\n  name: \"BasicConsume\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    \"default\": 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    \"default\": \"\"\n  }, {\n    type: \"shortstr\",\n    name: \"consumerTag\",\n    \"default\": \"\"\n  }, {\n    type: \"bit\",\n    name: \"noLocal\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"noAck\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"exclusive\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    \"default\": !1\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    \"default\": {}\n  } ]\n};\n\nmodule.exports.BasicConsumeOk = 3932181;\n\nvar methodInfoBasicConsumeOk = module.exports.methodInfoBasicConsumeOk = {\n  id: 3932181,\n  name: \"BasicConsumeOk\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"consumerTag\"\n  } ]\n};\n\nmodule.exports.BasicCancel = 3932190;\n\nvar methodInfoBasicCancel = module.exports.methodInfoBasicCancel = {\n  id: 3932190,\n  name: \"BasicCancel\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"consumerTag\"\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    \"default\": !1\n  } ]\n};\n\nmodule.exports.BasicCancelOk = 3932191;\n\nvar methodInfoBasicCancelOk = module.exports.methodInfoBasicCancelOk = {\n  id: 3932191,\n  name: \"BasicCancelOk\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"consumerTag\"\n  } ]\n};\n\nmodule.exports.BasicPublish = 3932200;\n\nvar methodInfoBasicPublish = module.exports.methodInfoBasicPublish = {\n  id: 3932200,\n  name: \"BasicPublish\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    \"default\": 0\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\",\n    \"default\": \"\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\",\n    \"default\": \"\"\n  }, {\n    type: \"bit\",\n    name: \"mandatory\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"immediate\",\n    \"default\": !1\n  } ]\n};\n\nmodule.exports.BasicReturn = 3932210;\n\nvar methodInfoBasicReturn = module.exports.methodInfoBasicReturn = {\n  id: 3932210,\n  name: \"BasicReturn\",\n  args: [ {\n    type: \"short\",\n    name: \"replyCode\"\n  }, {\n    type: \"shortstr\",\n    name: \"replyText\",\n    \"default\": \"\"\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\"\n  } ]\n};\n\nmodule.exports.BasicDeliver = 3932220;\n\nvar methodInfoBasicDeliver = module.exports.methodInfoBasicDeliver = {\n  id: 3932220,\n  name: \"BasicDeliver\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"consumerTag\"\n  }, {\n    type: \"longlong\",\n    name: \"deliveryTag\"\n  }, {\n    type: \"bit\",\n    name: \"redelivered\",\n    \"default\": !1\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\"\n  } ]\n};\n\nmodule.exports.BasicGet = 3932230;\n\nvar methodInfoBasicGet = module.exports.methodInfoBasicGet = {\n  id: 3932230,\n  name: \"BasicGet\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    \"default\": 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    \"default\": \"\"\n  }, {\n    type: \"bit\",\n    name: \"noAck\",\n    \"default\": !1\n  } ]\n};\n\nmodule.exports.BasicGetOk = 3932231;\n\nvar methodInfoBasicGetOk = module.exports.methodInfoBasicGetOk = {\n  id: 3932231,\n  name: \"BasicGetOk\",\n  args: [ {\n    type: \"longlong\",\n    name: \"deliveryTag\"\n  }, {\n    type: \"bit\",\n    name: \"redelivered\",\n    \"default\": !1\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\"\n  }, {\n    type: \"long\",\n    name: \"messageCount\"\n  } ]\n};\n\nmodule.exports.BasicGetEmpty = 3932232;\n\nvar methodInfoBasicGetEmpty = module.exports.methodInfoBasicGetEmpty = {\n  id: 3932232,\n  name: \"BasicGetEmpty\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"clusterId\",\n    \"default\": \"\"\n  } ]\n};\n\nmodule.exports.BasicAck = 3932240;\n\nvar methodInfoBasicAck = module.exports.methodInfoBasicAck = {\n  id: 3932240,\n  name: \"BasicAck\",\n  args: [ {\n    type: \"longlong\",\n    name: \"deliveryTag\",\n    \"default\": 0\n  }, {\n    type: \"bit\",\n    name: \"multiple\",\n    \"default\": !1\n  } ]\n};\n\nmodule.exports.BasicReject = 3932250;\n\nvar methodInfoBasicReject = module.exports.methodInfoBasicReject = {\n  id: 3932250,\n  name: \"BasicReject\",\n  args: [ {\n    type: \"longlong\",\n    name: \"deliveryTag\"\n  }, {\n    type: \"bit\",\n    name: \"requeue\",\n    \"default\": !0\n  } ]\n};\n\nmodule.exports.BasicRecoverAsync = 3932260;\n\nvar methodInfoBasicRecoverAsync = module.exports.methodInfoBasicRecoverAsync = {\n  id: 3932260,\n  name: \"BasicRecoverAsync\",\n  args: [ {\n    type: \"bit\",\n    name: \"requeue\",\n    \"default\": !1\n  } ]\n};\n\nmodule.exports.BasicRecover = 3932270;\n\nvar methodInfoBasicRecover = module.exports.methodInfoBasicRecover = {\n  id: 3932270,\n  name: \"BasicRecover\",\n  args: [ {\n    type: \"bit\",\n    name: \"requeue\",\n    \"default\": !1\n  } ]\n};\n\nmodule.exports.BasicRecoverOk = 3932271;\n\nvar methodInfoBasicRecoverOk = module.exports.methodInfoBasicRecoverOk = {\n  id: 3932271,\n  name: \"BasicRecoverOk\",\n  args: []\n};\n\nmodule.exports.BasicNack = 3932280;\n\nvar methodInfoBasicNack = module.exports.methodInfoBasicNack = {\n  id: 3932280,\n  name: \"BasicNack\",\n  args: [ {\n    type: \"longlong\",\n    name: \"deliveryTag\",\n    \"default\": 0\n  }, {\n    type: \"bit\",\n    name: \"multiple\",\n    \"default\": !1\n  }, {\n    type: \"bit\",\n    name: \"requeue\",\n    \"default\": !0\n  } ]\n};\n\nmodule.exports.TxSelect = 5898250;\n\nvar methodInfoTxSelect = module.exports.methodInfoTxSelect = {\n  id: 5898250,\n  name: \"TxSelect\",\n  args: []\n};\n\nmodule.exports.TxSelectOk = 5898251;\n\nvar methodInfoTxSelectOk = module.exports.methodInfoTxSelectOk = {\n  id: 5898251,\n  name: \"TxSelectOk\",\n  args: []\n};\n\nmodule.exports.TxCommit = 5898260;\n\nvar methodInfoTxCommit = module.exports.methodInfoTxCommit = {\n  id: 5898260,\n  name: \"TxCommit\",\n  args: []\n};\n\nmodule.exports.TxCommitOk = 5898261;\n\nvar methodInfoTxCommitOk = module.exports.methodInfoTxCommitOk = {\n  id: 5898261,\n  name: \"TxCommitOk\",\n  args: []\n};\n\nmodule.exports.TxRollback = 5898270;\n\nvar methodInfoTxRollback = module.exports.methodInfoTxRollback = {\n  id: 5898270,\n  name: \"TxRollback\",\n  args: []\n};\n\nmodule.exports.TxRollbackOk = 5898271;\n\nvar methodInfoTxRollbackOk = module.exports.methodInfoTxRollbackOk = {\n  id: 5898271,\n  name: \"TxRollbackOk\",\n  args: []\n};\n\nmodule.exports.ConfirmSelect = 5570570;\n\nvar methodInfoConfirmSelect = module.exports.methodInfoConfirmSelect = {\n  id: 5570570,\n  name: \"ConfirmSelect\",\n  args: [ {\n    type: \"bit\",\n    name: \"nowait\",\n    \"default\": !1\n  } ]\n};\n\nmodule.exports.ConfirmSelectOk = 5570571;\n\nvar methodInfoConfirmSelectOk = module.exports.methodInfoConfirmSelectOk = {\n  id: 5570571,\n  name: \"ConfirmSelectOk\",\n  args: []\n};\n\nmodule.exports.BasicProperties = 60;\n\nvar propertiesInfoBasicProperties = module.exports.propertiesInfoBasicProperties = {\n  id: 60,\n  name: \"BasicProperties\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"contentType\"\n  }, {\n    type: \"shortstr\",\n    name: \"contentEncoding\"\n  }, {\n    type: \"table\",\n    name: \"headers\"\n  }, {\n    type: \"octet\",\n    name: \"deliveryMode\"\n  }, {\n    type: \"octet\",\n    name: \"priority\"\n  }, {\n    type: \"shortstr\",\n    name: \"correlationId\"\n  }, {\n    type: \"shortstr\",\n    name: \"replyTo\"\n  }, {\n    type: \"shortstr\",\n    name: \"expiration\"\n  }, {\n    type: \"shortstr\",\n    name: \"messageId\"\n  }, {\n    type: \"timestamp\",\n    name: \"timestamp\"\n  }, {\n    type: \"shortstr\",\n    name: \"type\"\n  }, {\n    type: \"shortstr\",\n    name: \"userId\"\n  }, {\n    type: \"shortstr\",\n    name: \"appId\"\n  }, {\n    type: \"shortstr\",\n    name: \"clusterId\"\n  } ]\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZGVmcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9kZWZzLmpzPzVlNjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBwcmVzZXJ2ZSBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBzY3JpcHRcbiAqIC4uL2Jpbi9nZW5lcmF0ZS1kZWZzLmpzLCB3aGljaCBpcyBub3QgaW4gZ2VuZXJhbCBpbmNsdWRlZCBpbiBhXG4gKiBkaXN0cmlidXRpb24sIGJ1dCBpcyBhdmFpbGFibGUgaW4gdGhlIHNvdXJjZSByZXBvc2l0b3J5IGUuZy4gYXRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zcXVhcmVtby9hbXFwLm5vZGUvXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uU3RhcnQoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHZlcnNpb25NYWpvcjogdm9pZCAwLFxuICAgIHZlcnNpb25NaW5vcjogdm9pZCAwLFxuICAgIHNlcnZlclByb3BlcnRpZXM6IHZvaWQgMCxcbiAgICBtZWNoYW5pc21zOiB2b2lkIDAsXG4gICAgbG9jYWxlczogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlcltvZmZzZXRdO1xuICBvZmZzZXQrKztcbiAgZmllbGRzLnZlcnNpb25NYWpvciA9IHZhbDtcbiAgdmFsID0gYnVmZmVyW29mZnNldF07XG4gIG9mZnNldCsrO1xuICBmaWVsZHMudmVyc2lvbk1pbm9yID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5zZXJ2ZXJQcm9wZXJ0aWVzID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMubWVjaGFuaXNtcyA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmxvY2FsZXMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25TdGFydChjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwLCBzY3JhdGNoT2Zmc2V0ID0gMDtcbiAgdmFsID0gZmllbGRzLnNlcnZlclByb3BlcnRpZXM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdzZXJ2ZXJQcm9wZXJ0aWVzJ1wiKTtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdzZXJ2ZXJQcm9wZXJ0aWVzJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIGxlbiA9IGVuY29kZVRhYmxlKFNDUkFUQ0gsIHZhbCwgc2NyYXRjaE9mZnNldCk7XG4gIHZhciBzZXJ2ZXJQcm9wZXJ0aWVzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gc2VydmVyUHJvcGVydGllc19lbmNvZGVkLmxlbmd0aDtcbiAgdmFsID0gZmllbGRzLm1lY2hhbmlzbXM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gQnVmZmVyLmZyb20oXCJQTEFJTlwiKTsgZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ21lY2hhbmlzbXMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgQnVmZmVyXCIpO1xuICB2YXJ5aW5nU2l6ZSArPSB2YWwubGVuZ3RoO1xuICB2YWwgPSBmaWVsZHMubG9jYWxlcztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBCdWZmZXIuZnJvbShcImVuX1VTXCIpOyBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnbG9jYWxlcycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBCdWZmZXJcIik7XG4gIHZhcnlpbmdTaXplICs9IHZhbC5sZW5ndGg7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjIgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTUzNzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnZlcnNpb25NYWpvcjtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd2ZXJzaW9uTWFqb3InIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGZpZWxkcy52ZXJzaW9uTWlub3I7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gOTsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndmVyc2lvbk1pbm9yJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50OCh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICBvZmZzZXQgKz0gc2VydmVyUHJvcGVydGllc19lbmNvZGVkLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICB2YWwgPSBmaWVsZHMubWVjaGFuaXNtcztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IEJ1ZmZlci5mcm9tKFwiUExBSU5cIikpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuICBidWZmZXIud3JpdGVVSW50MzJCRShsZW4sIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwuY29weShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSBsZW47XG4gIHZhbCA9IGZpZWxkcy5sb2NhbGVzO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gQnVmZmVyLmZyb20oXCJlbl9VU1wiKSk7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGxlbiwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uU3RhcnRPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY2xpZW50UHJvcGVydGllczogdm9pZCAwLFxuICAgIG1lY2hhbmlzbTogdm9pZCAwLFxuICAgIHJlc3BvbnNlOiB2b2lkIDAsXG4gICAgbG9jYWxlOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZGVjb2RlRmllbGRzKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuY2xpZW50UHJvcGVydGllcyA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5tZWNoYW5pc20gPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yZXNwb25zZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5sb2NhbGUgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25TdGFydE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwO1xuICB2YWwgPSBmaWVsZHMuY2xpZW50UHJvcGVydGllcztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2NsaWVudFByb3BlcnRpZXMnXCIpO1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NsaWVudFByb3BlcnRpZXMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgdmFyIGNsaWVudFByb3BlcnRpZXNfZW5jb2RlZCA9IFNDUkFUQ0guc2xpY2Uoc2NyYXRjaE9mZnNldCwgc2NyYXRjaE9mZnNldCArIGxlbik7XG4gIHNjcmF0Y2hPZmZzZXQgKz0gbGVuO1xuICB2YXJ5aW5nU2l6ZSArPSBjbGllbnRQcm9wZXJ0aWVzX2VuY29kZWQubGVuZ3RoO1xuICB2YWwgPSBmaWVsZHMubWVjaGFuaXNtO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiUExBSU5cIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnbWVjaGFuaXNtJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIG1lY2hhbmlzbV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gbWVjaGFuaXNtX2xlbjtcbiAgdmFsID0gZmllbGRzLnJlc3BvbnNlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncmVzcG9uc2UnXCIpO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3Jlc3BvbnNlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIEJ1ZmZlclwiKTtcbiAgdmFyeWluZ1NpemUgKz0gdmFsLmxlbmd0aDtcbiAgdmFsID0gZmllbGRzLmxvY2FsZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcImVuX1VTXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2xvY2FsZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBsb2NhbGVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGxvY2FsZV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTggKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTUzNzEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgb2Zmc2V0ICs9IGNsaWVudFByb3BlcnRpZXNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgdmFsID0gZmllbGRzLm1lY2hhbmlzbTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiUExBSU5cIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gbWVjaGFuaXNtX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gbWVjaGFuaXNtX2xlbjtcbiAgdmFsID0gZmllbGRzLnJlc3BvbnNlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gQnVmZmVyLmZyb20odm9pZCAwKSk7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGxlbiwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgdmFsID0gZmllbGRzLmxvY2FsZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiZW5fVVNcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gbG9jYWxlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gbG9jYWxlX2xlbjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uU2VjdXJlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBjaGFsbGVuZ2U6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuY2hhbGxlbmdlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uU2VjdXJlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5jaGFsbGVuZ2U7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjaGFsbGVuZ2UnXCIpO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NoYWxsZW5nZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBCdWZmZXJcIik7XG4gIHZhcnlpbmdTaXplICs9IHZhbC5sZW5ndGg7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTYgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTUzODAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmNoYWxsZW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IEJ1ZmZlci5mcm9tKHZvaWQgMCkpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuICBidWZmZXIud3JpdGVVSW50MzJCRShsZW4sIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwuY29weShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSBsZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvblNlY3VyZU9rKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICByZXNwb25zZTogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yZXNwb25zZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvblNlY3VyZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5yZXNwb25zZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ3Jlc3BvbnNlJ1wiKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyZXNwb25zZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBCdWZmZXJcIik7XG4gIHZhcnlpbmdTaXplICs9IHZhbC5sZW5ndGg7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTYgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTUzODEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnJlc3BvbnNlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gQnVmZmVyLmZyb20odm9pZCAwKSk7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGxlbiwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uVHVuZShidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNoYW5uZWxNYXg6IHZvaWQgMCxcbiAgICBmcmFtZU1heDogdm9pZCAwLFxuICAgIGhlYXJ0YmVhdDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5jaGFubmVsTWF4ID0gdmFsO1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBmaWVsZHMuZnJhbWVNYXggPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5oZWFydGJlYXQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25UdW5lKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjAgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTUzOTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmNoYW5uZWxNYXg7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2hhbm5lbE1heCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLmZyYW1lTWF4O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2ZyYW1lTWF4JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBmaWVsZHMuaGVhcnRiZWF0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2hlYXJ0YmVhdCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uVHVuZU9rKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY2hhbm5lbE1heDogdm9pZCAwLFxuICAgIGZyYW1lTWF4OiB2b2lkIDAsXG4gICAgaGVhcnRiZWF0OiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLmNoYW5uZWxNYXggPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGZpZWxkcy5mcmFtZU1heCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLmhlYXJ0YmVhdCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvblR1bmVPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDIwICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNjU1MzkxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jaGFubmVsTWF4O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NoYW5uZWxNYXgnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5mcmFtZU1heDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdmcmFtZU1heCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZmllbGRzLmhlYXJ0YmVhdDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdoZWFydGJlYXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvbk9wZW4oYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHZpcnR1YWxIb3N0OiB2b2lkIDAsXG4gICAgY2FwYWJpbGl0aWVzOiB2b2lkIDAsXG4gICAgaW5zaXN0OiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy52aXJ0dWFsSG9zdCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5jYXBhYmlsaXRpZXMgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5pbnNpc3QgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25PcGVuKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnZpcnR1YWxIb3N0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiL1wiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd2aXJ0dWFsSG9zdCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciB2aXJ0dWFsSG9zdF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gdmlydHVhbEhvc3RfbGVuO1xuICB2YWwgPSBmaWVsZHMuY2FwYWJpbGl0aWVzO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NhcGFiaWxpdGllcycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBjYXBhYmlsaXRpZXNfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGNhcGFiaWxpdGllc19sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTUgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTU0MDAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnZpcnR1YWxIb3N0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCIvXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHZpcnR1YWxIb3N0X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gdmlydHVhbEhvc3RfbGVuO1xuICB2YWwgPSBmaWVsZHMuY2FwYWJpbGl0aWVzO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gY2FwYWJpbGl0aWVzX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY2FwYWJpbGl0aWVzX2xlbjtcbiAgdmFsID0gZmllbGRzLmluc2lzdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNvbm5lY3Rpb25PcGVuT2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGtub3duSG9zdHM6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmtub3duSG9zdHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25PcGVuT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5rbm93bkhvc3RzO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2tub3duSG9zdHMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIga25vd25Ib3N0c19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0ga25vd25Ib3N0c19sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTU0MDEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmtub3duSG9zdHM7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBrbm93bkhvc3RzX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0ga25vd25Ib3N0c19sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvbkNsb3NlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICByZXBseUNvZGU6IHZvaWQgMCxcbiAgICByZXBseVRleHQ6IHZvaWQgMCxcbiAgICBjbGFzc0lkOiB2b2lkIDAsXG4gICAgbWV0aG9kSWQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMucmVwbHlDb2RlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJlcGx5VGV4dCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLmNsYXNzSWQgPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5tZXRob2RJZCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvbkNsb3NlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVwbHlUZXh0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5VGV4dCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByZXBseVRleHRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTkgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTU0MTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnJlcGx5Q29kZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ3JlcGx5Q29kZSdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyZXBseUNvZGUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5yZXBseVRleHQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSByZXBseVRleHRfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSByZXBseVRleHRfbGVuO1xuICB2YWwgPSBmaWVsZHMuY2xhc3NJZDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2NsYXNzSWQnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2xhc3NJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLm1ldGhvZElkO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnbWV0aG9kSWQnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnbWV0aG9kSWQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvbkNsb3NlT2soYnVmZmVyKSB7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvbkNsb3NlT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTQxMSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNvbm5lY3Rpb25CbG9ja2VkKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICByZWFzb246IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJlYXNvbiA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvbkJsb2NrZWQoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5yZWFzb247XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVhc29uJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHJlYXNvbl9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcmVhc29uX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTQyMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVhc29uO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcmVhc29uX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcmVhc29uX2xlbjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uVW5ibG9ja2VkKGJ1ZmZlcikge1xuICB2YXIgZmllbGRzID0ge307XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25VbmJsb2NrZWQoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTQyMSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNoYW5uZWxPcGVuKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBvdXRPZkJhbmQ6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLm91dE9mQmFuZCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2hhbm5lbE9wZW4oY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5vdXRPZkJhbmQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnb3V0T2ZCYW5kJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIG91dE9mQmFuZF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gb3V0T2ZCYW5kX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDEzMTA3MzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLm91dE9mQmFuZDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IG91dE9mQmFuZF9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IG91dE9mQmFuZF9sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ2hhbm5lbE9wZW5PayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY2hhbm5lbElkOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNoYW5uZWxJZCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2hhbm5lbE9wZW5PayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY2hhbm5lbElkO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IEJ1ZmZlci5mcm9tKFwiXCIpOyBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2hhbm5lbElkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIEJ1ZmZlclwiKTtcbiAgdmFyeWluZ1NpemUgKz0gdmFsLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDEzMTA3MzEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmNoYW5uZWxJZDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IEJ1ZmZlci5mcm9tKFwiXCIpKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUobGVuLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNoYW5uZWxGbG93KGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgYWN0aXZlOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmFjdGl2ZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2hhbm5lbEZsb3coY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxMzEwNzQwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5hY3RpdmU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdhY3RpdmUnXCIpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ2hhbm5lbEZsb3dPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGFjdGl2ZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5hY3RpdmUgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNoYW5uZWxGbG93T2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxMzEwNzQxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5hY3RpdmU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdhY3RpdmUnXCIpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ2hhbm5lbENsb3NlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICByZXBseUNvZGU6IHZvaWQgMCxcbiAgICByZXBseVRleHQ6IHZvaWQgMCxcbiAgICBjbGFzc0lkOiB2b2lkIDAsXG4gICAgbWV0aG9kSWQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMucmVwbHlDb2RlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJlcGx5VGV4dCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLmNsYXNzSWQgPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5tZXRob2RJZCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2hhbm5lbENsb3NlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVwbHlUZXh0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5VGV4dCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByZXBseVRleHRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTkgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxMzEwNzYwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5yZXBseUNvZGU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdyZXBseUNvZGUnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVwbHlDb2RlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMucmVwbHlUZXh0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcmVwbHlUZXh0X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcmVwbHlUZXh0X2xlbjtcbiAgdmFsID0gZmllbGRzLmNsYXNzSWQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjbGFzc0lkJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NsYXNzSWQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5tZXRob2RJZDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ21ldGhvZElkJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ21ldGhvZElkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNoYW5uZWxDbG9zZU9rKGJ1ZmZlcikge1xuICB2YXIgZmllbGRzID0ge307XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNoYW5uZWxDbG9zZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxMzEwNzYxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQWNjZXNzUmVxdWVzdChidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgcmVhbG06IHZvaWQgMCxcbiAgICBleGNsdXNpdmU6IHZvaWQgMCxcbiAgICBwYXNzaXZlOiB2b2lkIDAsXG4gICAgYWN0aXZlOiB2b2lkIDAsXG4gICAgd3JpdGU6IHZvaWQgMCxcbiAgICByZWFkOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yZWFsbSA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmV4Y2x1c2l2ZSA9IHZhbDtcbiAgdmFsID0gISEoMiAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLnBhc3NpdmUgPSB2YWw7XG4gIHZhbCA9ICEhKDQgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5hY3RpdmUgPSB2YWw7XG4gIHZhbCA9ICEhKDggJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy53cml0ZSA9IHZhbDtcbiAgdmFsID0gISEoMTYgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5yZWFkID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVBY2Nlc3NSZXF1ZXN0KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnJlYWxtO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiL2RhdGFcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVhbG0nIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcmVhbG1fbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJlYWxtX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNCArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDE5NjYwOTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnJlYWxtO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCIvZGF0YVwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSByZWFsbV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJlYWxtX2xlbjtcbiAgdmFsID0gZmllbGRzLmV4Y2x1c2l2ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMucGFzc2l2ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICEwKTtcbiAgdmFsICYmIChiaXRzICs9IDIpO1xuICB2YWwgPSBmaWVsZHMuYWN0aXZlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITApO1xuICB2YWwgJiYgKGJpdHMgKz0gNCk7XG4gIHZhbCA9IGZpZWxkcy53cml0ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICEwKTtcbiAgdmFsICYmIChiaXRzICs9IDgpO1xuICB2YWwgPSBmaWVsZHMucmVhZDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICEwKTtcbiAgdmFsICYmIChiaXRzICs9IDE2KTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVBY2Nlc3NSZXF1ZXN0T2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVBY2Nlc3NSZXF1ZXN0T2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNCArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDE5NjYwOTEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAxOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VEZWNsYXJlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBleGNoYW5nZTogdm9pZCAwLFxuICAgIHR5cGU6IHZvaWQgMCxcbiAgICBwYXNzaXZlOiB2b2lkIDAsXG4gICAgZHVyYWJsZTogdm9pZCAwLFxuICAgIGF1dG9EZWxldGU6IHZvaWQgMCxcbiAgICBpbnRlcm5hbDogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZXhjaGFuZ2UgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMudHlwZSA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLnBhc3NpdmUgPSB2YWw7XG4gIHZhbCA9ICEhKDIgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5kdXJhYmxlID0gdmFsO1xuICB2YWwgPSAhISg0ICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuYXV0b0RlbGV0ZSA9IHZhbDtcbiAgdmFsID0gISEoOCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmludGVybmFsID0gdmFsO1xuICB2YWwgPSAhISgxNiAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm5vd2FpdCA9IHZhbDtcbiAgb2Zmc2V0Kys7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGRlY29kZUZpZWxkcyhidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmFyZ3VtZW50cyA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlRXhjaGFuZ2VEZWNsYXJlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwLCBzY3JhdGNoT2Zmc2V0ID0gMDtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZXhjaGFuZ2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnR5cGU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJkaXJlY3RcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndHlwZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciB0eXBlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSB0eXBlX2xlbjtcbiAgdmFsID0gZmllbGRzLmFyZ3VtZW50cztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSB7fTsgZWxzZSBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FyZ3VtZW50cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgYXJndW1lbnRzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gYXJndW1lbnRzX2VuY29kZWQubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE3ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMjYyMTQ1MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSBleGNoYW5nZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnR5cGU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcImRpcmVjdFwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSB0eXBlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gdHlwZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5wYXNzaXZlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIHZhbCA9IGZpZWxkcy5kdXJhYmxlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIHZhbCA9IGZpZWxkcy5hdXRvRGVsZXRlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gNCk7XG4gIHZhbCA9IGZpZWxkcy5pbnRlcm5hbDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDgpO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMTYpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBiaXRzID0gMDtcbiAgb2Zmc2V0ICs9IGFyZ3VtZW50c19lbmNvZGVkLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUV4Y2hhbmdlRGVjbGFyZU9rKGJ1ZmZlcikge1xuICB2YXIgZmllbGRzID0ge307XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUV4Y2hhbmdlRGVjbGFyZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDUxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VEZWxldGUoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgaWZVbnVzZWQ6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmV4Y2hhbmdlID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuaWZVbnVzZWQgPSB2YWw7XG4gIHZhbCA9ICEhKDIgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUV4Y2hhbmdlRGVsZXRlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZXhjaGFuZ2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDI2MjE0NjAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5pZlVudXNlZDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VEZWxldGVPayhidWZmZXIpIHtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVFeGNoYW5nZURlbGV0ZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDYxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VCaW5kKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBkZXN0aW5hdGlvbjogdm9pZCAwLFxuICAgIHNvdXJjZTogdm9pZCAwLFxuICAgIHJvdXRpbmdLZXk6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMCxcbiAgICBhcmd1bWVudHM6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmRlc3RpbmF0aW9uID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnNvdXJjZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yb3V0aW5nS2V5ID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm93YWl0ID0gdmFsO1xuICBvZmZzZXQrKztcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZGVjb2RlRmllbGRzKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuYXJndW1lbnRzID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVFeGNoYW5nZUJpbmQoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwO1xuICB2YWwgPSBmaWVsZHMuZGVzdGluYXRpb247XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdkZXN0aW5hdGlvbidcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdkZXN0aW5hdGlvbicgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBkZXN0aW5hdGlvbl9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gZGVzdGluYXRpb25fbGVuO1xuICB2YWwgPSBmaWVsZHMuc291cmNlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnc291cmNlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3NvdXJjZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBzb3VyY2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHNvdXJjZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5hcmd1bWVudHM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0ge307IGVsc2UgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdhcmd1bWVudHMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgdmFyIGFyZ3VtZW50c19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IGFyZ3VtZW50c19lbmNvZGVkLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxOCArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDI2MjE0NzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5kZXN0aW5hdGlvbjtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZGVzdGluYXRpb25fbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBkZXN0aW5hdGlvbl9sZW47XG4gIHZhbCA9IGZpZWxkcy5zb3VyY2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IHNvdXJjZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHNvdXJjZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcm91dGluZ0tleV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJvdXRpbmdLZXlfbGVuO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJpdHMgPSAwO1xuICBvZmZzZXQgKz0gYXJndW1lbnRzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VCaW5kT2soYnVmZmVyKSB7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlRXhjaGFuZ2VCaW5kT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDI2MjE0NzEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVFeGNoYW5nZVVuYmluZChidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgZGVzdGluYXRpb246IHZvaWQgMCxcbiAgICBzb3VyY2U6IHZvaWQgMCxcbiAgICByb3V0aW5nS2V5OiB2b2lkIDAsXG4gICAgbm93YWl0OiB2b2lkIDAsXG4gICAgYXJndW1lbnRzOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnRpY2tldCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5kZXN0aW5hdGlvbiA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5zb3VyY2UgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucm91dGluZ0tleSA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm5vd2FpdCA9IHZhbDtcbiAgb2Zmc2V0Kys7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGRlY29kZUZpZWxkcyhidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmFyZ3VtZW50cyA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlRXhjaGFuZ2VVbmJpbmQoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwO1xuICB2YWwgPSBmaWVsZHMuZGVzdGluYXRpb247XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdkZXN0aW5hdGlvbidcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdkZXN0aW5hdGlvbicgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBkZXN0aW5hdGlvbl9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gZGVzdGluYXRpb25fbGVuO1xuICB2YWwgPSBmaWVsZHMuc291cmNlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnc291cmNlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3NvdXJjZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBzb3VyY2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHNvdXJjZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5hcmd1bWVudHM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0ge307IGVsc2UgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdhcmd1bWVudHMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgdmFyIGFyZ3VtZW50c19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IGFyZ3VtZW50c19lbmNvZGVkLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxOCArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDI2MjE0ODAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5kZXN0aW5hdGlvbjtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZGVzdGluYXRpb25fbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBkZXN0aW5hdGlvbl9sZW47XG4gIHZhbCA9IGZpZWxkcy5zb3VyY2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IHNvdXJjZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHNvdXJjZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcm91dGluZ0tleV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJvdXRpbmdLZXlfbGVuO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJpdHMgPSAwO1xuICBvZmZzZXQgKz0gYXJndW1lbnRzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VVbmJpbmRPayhidWZmZXIpIHtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVFeGNoYW5nZVVuYmluZE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDkxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVEZWNsYXJlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBxdWV1ZTogdm9pZCAwLFxuICAgIHBhc3NpdmU6IHZvaWQgMCxcbiAgICBkdXJhYmxlOiB2b2lkIDAsXG4gICAgZXhjbHVzaXZlOiB2b2lkIDAsXG4gICAgYXV0b0RlbGV0ZTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5wYXNzaXZlID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuZHVyYWJsZSA9IHZhbDtcbiAgdmFsID0gISEoNCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmV4Y2x1c2l2ZSA9IHZhbDtcbiAgdmFsID0gISEoOCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmF1dG9EZWxldGUgPSB2YWw7XG4gIHZhbCA9ICEhKDE2ICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm93YWl0ID0gdmFsO1xuICBvZmZzZXQrKztcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZGVjb2RlRmllbGRzKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuYXJndW1lbnRzID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZURlY2xhcmUoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncXVldWUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcXVldWVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLmFyZ3VtZW50cztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSB7fTsgZWxzZSBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FyZ3VtZW50cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgYXJndW1lbnRzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gYXJndW1lbnRzX2VuY29kZWQubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzI3NjgxMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcXVldWVfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5wYXNzaXZlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIHZhbCA9IGZpZWxkcy5kdXJhYmxlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIHZhbCA9IGZpZWxkcy5leGNsdXNpdmU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSA0KTtcbiAgdmFsID0gZmllbGRzLmF1dG9EZWxldGU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSA4KTtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDE2KTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIG9mZnNldCArPSBhcmd1bWVudHNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVRdWV1ZURlY2xhcmVPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgcXVldWU6IHZvaWQgMCxcbiAgICBtZXNzYWdlQ291bnQ6IHZvaWQgMCxcbiAgICBjb25zdW1lckNvdW50OiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5xdWV1ZSA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLm1lc3NhZ2VDb3VudCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLmNvbnN1bWVyQ291bnQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlRGVjbGFyZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdxdWV1ZSdcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdxdWV1ZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBxdWV1ZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcXVldWVfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDIxICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzI3NjgxMSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IHF1ZXVlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMubWVzc2FnZUNvdW50O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnbWVzc2FnZUNvdW50J1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ21lc3NhZ2VDb3VudCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZmllbGRzLmNvbnN1bWVyQ291bnQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjb25zdW1lckNvdW50J1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NvbnN1bWVyQ291bnQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVCaW5kKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBxdWV1ZTogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZXhjaGFuZ2UgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucm91dGluZ0tleSA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm5vd2FpdCA9IHZhbDtcbiAgb2Zmc2V0Kys7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGRlY29kZUZpZWxkcyhidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmFyZ3VtZW50cyA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlUXVldWVCaW5kKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwLCBzY3JhdGNoT2Zmc2V0ID0gMDtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3F1ZXVlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHF1ZXVlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2V4Y2hhbmdlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4Y2hhbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGV4Y2hhbmdlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5hcmd1bWVudHM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0ge307IGVsc2UgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdhcmd1bWVudHMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgdmFyIGFyZ3VtZW50c19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IGFyZ3VtZW50c19lbmNvZGVkLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxOCArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4MjAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHF1ZXVlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGV4Y2hhbmdlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJvdXRpbmdLZXlfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBiaXRzID0gMDtcbiAgb2Zmc2V0ICs9IGFyZ3VtZW50c19lbmNvZGVkLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXVlQmluZE9rKGJ1ZmZlcikge1xuICB2YXIgZmllbGRzID0ge307XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlQmluZE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzMjc2ODIxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVQdXJnZShidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgcXVldWU6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnF1ZXVlID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm93YWl0ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZVB1cmdlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3F1ZXVlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHF1ZXVlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBxdWV1ZV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTYgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzMjc2ODMwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBxdWV1ZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXVlUHVyZ2VPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIG1lc3NhZ2VDb3VudDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGZpZWxkcy5tZXNzYWdlQ291bnQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlUHVyZ2VPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzI3NjgzMSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMubWVzc2FnZUNvdW50O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnbWVzc2FnZUNvdW50J1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ21lc3NhZ2VDb3VudCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVRdWV1ZURlbGV0ZShidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgcXVldWU6IHZvaWQgMCxcbiAgICBpZlVudXNlZDogdm9pZCAwLFxuICAgIGlmRW1wdHk6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnF1ZXVlID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuaWZVbnVzZWQgPSB2YWw7XG4gIHZhbCA9ICEhKDIgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5pZkVtcHR5ID0gdmFsO1xuICB2YWwgPSAhISg0ICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm93YWl0ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZURlbGV0ZShjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdxdWV1ZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBxdWV1ZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcXVldWVfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzI3Njg0MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcXVldWVfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5pZlVudXNlZDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMuaWZFbXB0eTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDIpO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gNCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVEZWxldGVPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIG1lc3NhZ2VDb3VudDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGZpZWxkcy5tZXNzYWdlQ291bnQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlRGVsZXRlT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4NDEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLm1lc3NhZ2VDb3VudDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ21lc3NhZ2VDb3VudCdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZXNzYWdlQ291bnQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVVbmJpbmQoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIHF1ZXVlOiB2b2lkIDAsXG4gICAgZXhjaGFuZ2U6IHZvaWQgMCxcbiAgICByb3V0aW5nS2V5OiB2b2lkIDAsXG4gICAgYXJndW1lbnRzOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnRpY2tldCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5xdWV1ZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5leGNoYW5nZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yb3V0aW5nS2V5ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5hcmd1bWVudHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlVW5iaW5kKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncXVldWUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcXVldWVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZXhjaGFuZ2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncm91dGluZ0tleScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByb3V0aW5nS2V5X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLmFyZ3VtZW50cztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSB7fTsgZWxzZSBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FyZ3VtZW50cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgYXJndW1lbnRzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gYXJndW1lbnRzX2VuY29kZWQubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE3ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzI3Njg1MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcXVldWVfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcm91dGluZ0tleV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJvdXRpbmdLZXlfbGVuO1xuICBvZmZzZXQgKz0gYXJndW1lbnRzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVVbmJpbmRPayhidWZmZXIpIHtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZVVuYmluZE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzMjc2ODUxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNRb3MoYnVmZmVyKSB7XG4gIHZhciB2YWwsIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBwcmVmZXRjaFNpemU6IHZvaWQgMCxcbiAgICBwcmVmZXRjaENvdW50OiB2b2lkIDAsXG4gICAgZ2xvYmFsOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLnByZWZldGNoU2l6ZSA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnByZWZldGNoQ291bnQgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5nbG9iYWwgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUW9zKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE5ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE3MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucHJlZmV0Y2hTaXplO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3ByZWZldGNoU2l6ZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZmllbGRzLnByZWZldGNoQ291bnQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncHJlZmV0Y2hDb3VudCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLmdsb2JhbDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUW9zT2soYnVmZmVyKSB7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNRb3NPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhcnlpbmdTaXplID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE3MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljQ29uc3VtZShidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgcXVldWU6IHZvaWQgMCxcbiAgICBjb25zdW1lclRhZzogdm9pZCAwLFxuICAgIG5vTG9jYWw6IHZvaWQgMCxcbiAgICBub0Fjazogdm9pZCAwLFxuICAgIGV4Y2x1c2l2ZTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuY29uc3VtZXJUYWcgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub0xvY2FsID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm9BY2sgPSB2YWw7XG4gIHZhbCA9ICEhKDQgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5leGNsdXNpdmUgPSB2YWw7XG4gIHZhbCA9ICEhKDggJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIG9mZnNldCsrO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5hcmd1bWVudHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljQ29uc3VtZShjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMCwgc2NyYXRjaE9mZnNldCA9IDA7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdxdWV1ZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBxdWV1ZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY29uc3VtZXJUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgY29uc3VtZXJUYWdfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGNvbnN1bWVyVGFnX2xlbjtcbiAgdmFsID0gZmllbGRzLmFyZ3VtZW50cztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSB7fTsgZWxzZSBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FyZ3VtZW50cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgYXJndW1lbnRzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gYXJndW1lbnRzX2VuY29kZWQubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE3ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE4MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcXVldWVfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGNvbnN1bWVyVGFnX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YWwgPSBmaWVsZHMubm9Mb2NhbDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMubm9BY2s7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAyKTtcbiAgdmFsID0gZmllbGRzLmV4Y2x1c2l2ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDQpO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gOCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJpdHMgPSAwO1xuICBvZmZzZXQgKz0gYXJndW1lbnRzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNDb25zdW1lT2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNvbnN1bWVyVGFnOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5jb25zdW1lclRhZyA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNDb25zdW1lT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2NvbnN1bWVyVGFnJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NvbnN1bWVyVGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGNvbnN1bWVyVGFnX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBjb25zdW1lclRhZ19sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMTgxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gY29uc3VtZXJUYWdfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBjb25zdW1lclRhZ19sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNDYW5jZWwoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNvbnN1bWVyVGFnOiB2b2lkIDAsXG4gICAgbm93YWl0OiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5jb25zdW1lclRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm5vd2FpdCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNDYW5jZWwoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjb25zdW1lclRhZydcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjb25zdW1lclRhZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBjb25zdW1lclRhZ19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE0ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE5MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGNvbnN1bWVyVGFnX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNDYW5jZWxPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY29uc3VtZXJUYWc6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNvbnN1bWVyVGFnID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0NhbmNlbE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjb25zdW1lclRhZydcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjb25zdW1lclRhZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBjb25zdW1lclRhZ19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEzICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE5MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGNvbnN1bWVyVGFnX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY29uc3VtZXJUYWdfbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUHVibGlzaChidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgZXhjaGFuZ2U6IHZvaWQgMCxcbiAgICByb3V0aW5nS2V5OiB2b2lkIDAsXG4gICAgbWFuZGF0b3J5OiB2b2lkIDAsXG4gICAgaW1tZWRpYXRlOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnRpY2tldCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5leGNoYW5nZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yb3V0aW5nS2V5ID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubWFuZGF0b3J5ID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuaW1tZWRpYXRlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY1B1Ymxpc2goY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncm91dGluZ0tleScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByb3V0aW5nS2V5X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIyMDAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGV4Y2hhbmdlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJvdXRpbmdLZXlfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLm1hbmRhdG9yeTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMuaW1tZWRpYXRlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNSZXR1cm4oYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHJlcGx5Q29kZTogdm9pZCAwLFxuICAgIHJlcGx5VGV4dDogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5yZXBseUNvZGUgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucmVwbHlUZXh0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmV4Y2hhbmdlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJvdXRpbmdLZXkgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUmV0dXJuKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVwbHlUZXh0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5VGV4dCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByZXBseVRleHRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2V4Y2hhbmdlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4Y2hhbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGV4Y2hhbmdlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncm91dGluZ0tleSdcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyb3V0aW5nS2V5JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHJvdXRpbmdLZXlfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJvdXRpbmdLZXlfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE3ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjIxMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVwbHlDb2RlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncmVwbHlDb2RlJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5Q29kZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnJlcGx5VGV4dDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJlcGx5VGV4dF9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNEZWxpdmVyKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBjb25zdW1lclRhZzogdm9pZCAwLFxuICAgIGRlbGl2ZXJ5VGFnOiB2b2lkIDAsXG4gICAgcmVkZWxpdmVyZWQ6IHZvaWQgMCxcbiAgICBleGNoYW5nZTogdm9pZCAwLFxuICAgIHJvdXRpbmdLZXk6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNvbnN1bWVyVGFnID0gdmFsO1xuICB2YWwgPSBpbnRzLnJlYWRVSW50NjRCRShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICBmaWVsZHMuZGVsaXZlcnlUYWcgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5yZWRlbGl2ZXJlZCA9IHZhbDtcbiAgb2Zmc2V0Kys7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZXhjaGFuZ2UgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucm91dGluZ0tleSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNEZWxpdmVyKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmNvbnN1bWVyVGFnO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnY29uc3VtZXJUYWcnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY29uc3VtZXJUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgY29uc3VtZXJUYWdfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGNvbnN1bWVyVGFnX2xlbjtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZXhjaGFuZ2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdyb3V0aW5nS2V5J1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjQgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjIwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gY29uc3VtZXJUYWdfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBjb25zdW1lclRhZ19sZW47XG4gIHZhbCA9IGZpZWxkcy5kZWxpdmVyeVRhZztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2RlbGl2ZXJ5VGFnJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2RlbGl2ZXJ5VGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBpbnRzLndyaXRlVUludDY0QkUoYnVmZmVyLCB2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICB2YWwgPSBmaWVsZHMucmVkZWxpdmVyZWQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNHZXQoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIHF1ZXVlOiB2b2lkIDAsXG4gICAgbm9BY2s6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnF1ZXVlID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm9BY2sgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljR2V0KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3F1ZXVlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHF1ZXVlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBxdWV1ZV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTYgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjMwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBxdWV1ZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLm5vQWNrO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNHZXRPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgZGVsaXZlcnlUYWc6IHZvaWQgMCxcbiAgICByZWRlbGl2ZXJlZDogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwLFxuICAgIG1lc3NhZ2VDb3VudDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIGZpZWxkcy5kZWxpdmVyeVRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLnJlZGVsaXZlcmVkID0gdmFsO1xuICBvZmZzZXQrKztcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5leGNoYW5nZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yb3V0aW5nS2V5ID0gdmFsO1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBmaWVsZHMubWVzc2FnZUNvdW50ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0dldE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZXhjaGFuZ2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdyb3V0aW5nS2V5J1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjcgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjMxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5kZWxpdmVyeVRhZztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2RlbGl2ZXJ5VGFnJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2RlbGl2ZXJ5VGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBpbnRzLndyaXRlVUludDY0QkUoYnVmZmVyLCB2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICB2YWwgPSBmaWVsZHMucmVkZWxpdmVyZWQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5tZXNzYWdlQ291bnQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdtZXNzYWdlQ291bnQnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnbWVzc2FnZUNvdW50JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljR2V0RW1wdHkoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNsdXN0ZXJJZDogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuY2x1c3RlcklkID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0dldEVtcHR5KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY2x1c3RlcklkO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NsdXN0ZXJJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBjbHVzdGVySWRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGNsdXN0ZXJJZF9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjMyLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jbHVzdGVySWQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBjbHVzdGVySWRfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBjbHVzdGVySWRfbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljQWNrKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgZGVsaXZlcnlUYWc6IHZvaWQgMCxcbiAgICBtdWx0aXBsZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIGZpZWxkcy5kZWxpdmVyeVRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm11bHRpcGxlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0FjayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyMSArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIyNDAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmRlbGl2ZXJ5VGFnO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2RlbGl2ZXJ5VGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBpbnRzLndyaXRlVUludDY0QkUoYnVmZmVyLCB2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICB2YWwgPSBmaWVsZHMubXVsdGlwbGU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY1JlamVjdChidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGRlbGl2ZXJ5VGFnOiB2b2lkIDAsXG4gICAgcmVxdWV1ZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIGZpZWxkcy5kZWxpdmVyeVRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLnJlcXVldWUgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUmVqZWN0KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDIxICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjI1MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuZGVsaXZlcnlUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdkZWxpdmVyeVRhZydcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdkZWxpdmVyeVRhZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgaW50cy53cml0ZVVJbnQ2NEJFKGJ1ZmZlciwgdmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gODtcbiAgdmFsID0gZmllbGRzLnJlcXVldWU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMCk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY1JlY292ZXJBc3luYyhidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHJlcXVldWU6IHZvaWQgMFxuICB9O1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMucmVxdWV1ZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNSZWNvdmVyQXN5bmMoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjYwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5yZXF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNSZWNvdmVyKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgcmVxdWV1ZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5yZXF1ZXVlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY1JlY292ZXIoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjcwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5yZXF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNSZWNvdmVyT2soYnVmZmVyKSB7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNSZWNvdmVyT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIyNzEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY05hY2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBkZWxpdmVyeVRhZzogdm9pZCAwLFxuICAgIG11bHRpcGxlOiB2b2lkIDAsXG4gICAgcmVxdWV1ZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIGZpZWxkcy5kZWxpdmVyeVRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm11bHRpcGxlID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMucmVxdWV1ZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNOYWNrKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDIxICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjI4MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuZGVsaXZlcnlUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZGVsaXZlcnlUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGludHMud3JpdGVVSW50NjRCRShidWZmZXIsIHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIHZhbCA9IGZpZWxkcy5tdWx0aXBsZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMucmVxdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICEwKTtcbiAgdmFsICYmIChiaXRzICs9IDIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVR4U2VsZWN0KGJ1ZmZlcikge1xuICB2YXIgZmllbGRzID0ge307XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVR4U2VsZWN0KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg1ODk4MjUwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVHhTZWxlY3RPayhidWZmZXIpIHtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVUeFNlbGVjdE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg1ODk4MjUxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVHhDb21taXQoYnVmZmVyKSB7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlVHhDb21taXQoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDU4OTgyNjAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUeENvbW1pdE9rKGJ1ZmZlcikge1xuICB2YXIgZmllbGRzID0ge307XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVR4Q29tbWl0T2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDU4OTgyNjEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUeFJvbGxiYWNrKGJ1ZmZlcikge1xuICB2YXIgZmllbGRzID0ge307XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVR4Um9sbGJhY2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDU4OTgyNzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUeFJvbGxiYWNrT2soYnVmZmVyKSB7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlVHhSb2xsYmFja09rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg1ODk4MjcxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29uZmlybVNlbGVjdChidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIG5vd2FpdDogdm9pZCAwXG4gIH07XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbmZpcm1TZWxlY3QoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg1NTcwNTcwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5ub3dhaXQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25maXJtU2VsZWN0T2soYnVmZmVyKSB7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29uZmlybVNlbGVjdE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFyeWluZ1NpemUgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg1NTcwNTcxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNQcm9wZXJ0aWVzKGNoYW5uZWwsIHNpemUsIGZpZWxkcykge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZsYWdzID0gMCwgc2NyYXRjaE9mZnNldCA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmNvbnRlbnRUeXBlO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjb250ZW50VHlwZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIGNvbnRlbnRUeXBlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gICAgdmFyeWluZ1NpemUgKz0gY29udGVudFR5cGVfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5jb250ZW50RW5jb2Rpbmc7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NvbnRlbnRFbmNvZGluZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIGNvbnRlbnRFbmNvZGluZ19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IGNvbnRlbnRFbmNvZGluZ19sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLmhlYWRlcnM7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdoZWFkZXJzJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgICB2YXIgaGVhZGVyc19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgICB2YXJ5aW5nU2l6ZSArPSBoZWFkZXJzX2VuY29kZWQubGVuZ3RoO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5kZWxpdmVyeU1vZGU7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2RlbGl2ZXJ5TW9kZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5wcmlvcml0eTtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncHJpb3JpdHknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgfVxuICB2YWwgPSBmaWVsZHMuY29ycmVsYXRpb25JZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY29ycmVsYXRpb25JZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIGNvcnJlbGF0aW9uSWRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSBjb3JyZWxhdGlvbklkX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMucmVwbHlUbztcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVwbHlUbycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIHJlcGx5VG9fbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSByZXBseVRvX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMuZXhwaXJhdGlvbjtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhwaXJhdGlvbicgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIGV4cGlyYXRpb25fbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSBleHBpcmF0aW9uX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMubWVzc2FnZUlkO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZXNzYWdlSWQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICAgIHZhciBtZXNzYWdlSWRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSBtZXNzYWdlSWRfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy50aW1lc3RhbXA7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpbWVzdGFtcCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSA4O1xuICB9XG4gIHZhbCA9IGZpZWxkcy50eXBlO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0eXBlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgICB2YXIgdHlwZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IHR5cGVfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy51c2VySWQ7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3VzZXJJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIHVzZXJJZF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IHVzZXJJZF9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLmFwcElkO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdhcHBJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIGFwcElkX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gICAgdmFyeWluZ1NpemUgKz0gYXBwSWRfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5jbHVzdGVySWQ7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NsdXN0ZXJJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIGNsdXN0ZXJJZF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IGNsdXN0ZXJJZF9sZW47XG4gIH1cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyMiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMjtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIxNjAsIDcpO1xuICBpbnRzLndyaXRlVUludDY0QkUoYnVmZmVyLCBzaXplLCAxMSk7XG4gIGZsYWdzID0gMDtcbiAgb2Zmc2V0ID0gMjE7XG4gIHZhbCA9IGZpZWxkcy5jb250ZW50VHlwZTtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSAzMjc2ODtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IGNvbnRlbnRUeXBlX2xlbjtcbiAgICBvZmZzZXQrKztcbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgICBvZmZzZXQgKz0gY29udGVudFR5cGVfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5jb250ZW50RW5jb2Rpbmc7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gMTYzODQ7XG4gICAgYnVmZmVyW29mZnNldF0gPSBjb250ZW50RW5jb2RpbmdfbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSBjb250ZW50RW5jb2RpbmdfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5oZWFkZXJzO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDgxOTI7XG4gICAgb2Zmc2V0ICs9IGhlYWRlcnNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgfVxuICB2YWwgPSBmaWVsZHMuZGVsaXZlcnlNb2RlO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDQwOTY7XG4gICAgYnVmZmVyLndyaXRlVUludDgodmFsLCBvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5wcmlvcml0eTtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSAyMDQ4O1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgfVxuICB2YWwgPSBmaWVsZHMuY29ycmVsYXRpb25JZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSAxMDI0O1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gY29ycmVsYXRpb25JZF9sZW47XG4gICAgb2Zmc2V0Kys7XG4gICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gICAgb2Zmc2V0ICs9IGNvcnJlbGF0aW9uSWRfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5yZXBseVRvO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDUxMjtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IHJlcGx5VG9fbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSByZXBseVRvX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMuZXhwaXJhdGlvbjtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSAyNTY7XG4gICAgYnVmZmVyW29mZnNldF0gPSBleHBpcmF0aW9uX2xlbjtcbiAgICBvZmZzZXQrKztcbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgICBvZmZzZXQgKz0gZXhwaXJhdGlvbl9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLm1lc3NhZ2VJZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSAxMjg7XG4gICAgYnVmZmVyW29mZnNldF0gPSBtZXNzYWdlSWRfbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSBtZXNzYWdlSWRfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy50aW1lc3RhbXA7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gNjQ7XG4gICAgaW50cy53cml0ZVVJbnQ2NEJFKGJ1ZmZlciwgdmFsLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA4O1xuICB9XG4gIHZhbCA9IGZpZWxkcy50eXBlO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDMyO1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gdHlwZV9sZW47XG4gICAgb2Zmc2V0Kys7XG4gICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gICAgb2Zmc2V0ICs9IHR5cGVfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy51c2VySWQ7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gMTY7XG4gICAgYnVmZmVyW29mZnNldF0gPSB1c2VySWRfbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSB1c2VySWRfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5hcHBJZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSA4O1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gYXBwSWRfbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSBhcHBJZF9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLmNsdXN0ZXJJZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSA0O1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gY2x1c3RlcklkX2xlbjtcbiAgICBvZmZzZXQrKztcbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgICBvZmZzZXQgKz0gY2x1c3RlcklkX2xlbjtcbiAgfVxuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGZsYWdzLCAxOSk7XG4gIHJldHVybiBidWZmZXIuc2xpY2UoMCwgb2Zmc2V0ICsgMSk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUHJvcGVydGllcyhidWZmZXIpIHtcbiAgdmFyIGZsYWdzLCB2YWwsIGxlbiwgb2Zmc2V0ID0gMjtcbiAgZmxhZ3MgPSBidWZmZXIucmVhZFVJbnQxNkJFKDApO1xuICBpZiAoMCA9PT0gZmxhZ3MpIHJldHVybiB7fTtcbiAgdmFyIGZpZWxkcyA9IHtcbiAgICBjb250ZW50VHlwZTogdm9pZCAwLFxuICAgIGNvbnRlbnRFbmNvZGluZzogdm9pZCAwLFxuICAgIGhlYWRlcnM6IHZvaWQgMCxcbiAgICBkZWxpdmVyeU1vZGU6IHZvaWQgMCxcbiAgICBwcmlvcml0eTogdm9pZCAwLFxuICAgIGNvcnJlbGF0aW9uSWQ6IHZvaWQgMCxcbiAgICByZXBseVRvOiB2b2lkIDAsXG4gICAgZXhwaXJhdGlvbjogdm9pZCAwLFxuICAgIG1lc3NhZ2VJZDogdm9pZCAwLFxuICAgIHRpbWVzdGFtcDogdm9pZCAwLFxuICAgIHR5cGU6IHZvaWQgMCxcbiAgICB1c2VySWQ6IHZvaWQgMCxcbiAgICBhcHBJZDogdm9pZCAwLFxuICAgIGNsdXN0ZXJJZDogdm9pZCAwXG4gIH07XG4gIGlmICgzMjc2OCAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLmNvbnRlbnRUeXBlID0gdmFsO1xuICB9XG4gIGlmICgxNjM4NCAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLmNvbnRlbnRFbmNvZGluZyA9IHZhbDtcbiAgfVxuICBpZiAoODE5MiAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHZhbCA9IGRlY29kZUZpZWxkcyhidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5oZWFkZXJzID0gdmFsO1xuICB9XG4gIGlmICg0MDk2ICYgZmxhZ3MpIHtcbiAgICB2YWwgPSBidWZmZXJbb2Zmc2V0XTtcbiAgICBvZmZzZXQrKztcbiAgICBmaWVsZHMuZGVsaXZlcnlNb2RlID0gdmFsO1xuICB9XG4gIGlmICgyMDQ4ICYgZmxhZ3MpIHtcbiAgICB2YWwgPSBidWZmZXJbb2Zmc2V0XTtcbiAgICBvZmZzZXQrKztcbiAgICBmaWVsZHMucHJpb3JpdHkgPSB2YWw7XG4gIH1cbiAgaWYgKDEwMjQgJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5jb3JyZWxhdGlvbklkID0gdmFsO1xuICB9XG4gIGlmICg1MTIgJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5yZXBseVRvID0gdmFsO1xuICB9XG4gIGlmICgyNTYgJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5leHBpcmF0aW9uID0gdmFsO1xuICB9XG4gIGlmICgxMjggJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5tZXNzYWdlSWQgPSB2YWw7XG4gIH1cbiAgaWYgKDY0ICYgZmxhZ3MpIHtcbiAgICB2YWwgPSBpbnRzLnJlYWRVSW50NjRCRShidWZmZXIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDg7XG4gICAgZmllbGRzLnRpbWVzdGFtcCA9IHZhbDtcbiAgfVxuICBpZiAoMzIgJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy50eXBlID0gdmFsO1xuICB9XG4gIGlmICgxNiAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLnVzZXJJZCA9IHZhbDtcbiAgfVxuICBpZiAoOCAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLmFwcElkID0gdmFsO1xuICB9XG4gIGlmICg0ICYgZmxhZ3MpIHtcbiAgICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgb2Zmc2V0Kys7XG4gICAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgb2Zmc2V0ICs9IGxlbjtcbiAgICBmaWVsZHMuY2x1c3RlcklkID0gdmFsO1xuICB9XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKFwic2FmZS1idWZmZXJcIikuQnVmZmVyLCBjb2RlYyA9IHJlcXVpcmUoXCIuL2NvZGVjXCIpLCBpbnRzID0gcmVxdWlyZShcImJ1ZmZlci1tb3JlLWludHNcIiksIGVuY29kZVRhYmxlID0gY29kZWMuZW5jb2RlVGFibGUsIGRlY29kZUZpZWxkcyA9IGNvZGVjLmRlY29kZUZpZWxkcywgU0NSQVRDSCA9IEJ1ZmZlci5hbGxvYygxNjM4NCksIEVNUFRZX09CSkVDVCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG5tb2R1bGUuZXhwb3J0cy5jb25zdGFudHMgPSB7XG4gIEZSQU1FX01FVEhPRDogMSxcbiAgRlJBTUVfSEVBREVSOiAyLFxuICBGUkFNRV9CT0RZOiAzLFxuICBGUkFNRV9IRUFSVEJFQVQ6IDgsXG4gIEZSQU1FX01JTl9TSVpFOiA0MDk2LFxuICBGUkFNRV9FTkQ6IDIwNixcbiAgUkVQTFlfU1VDQ0VTUzogMjAwLFxuICBDT05URU5UX1RPT19MQVJHRTogMzExLFxuICBOT19ST1VURTogMzEyLFxuICBOT19DT05TVU1FUlM6IDMxMyxcbiAgQUNDRVNTX1JFRlVTRUQ6IDQwMyxcbiAgTk9UX0ZPVU5EOiA0MDQsXG4gIFJFU09VUkNFX0xPQ0tFRDogNDA1LFxuICBQUkVDT05ESVRJT05fRkFJTEVEOiA0MDYsXG4gIENPTk5FQ1RJT05fRk9SQ0VEOiAzMjAsXG4gIElOVkFMSURfUEFUSDogNDAyLFxuICBGUkFNRV9FUlJPUjogNTAxLFxuICBTWU5UQVhfRVJST1I6IDUwMixcbiAgQ09NTUFORF9JTlZBTElEOiA1MDMsXG4gIENIQU5ORUxfRVJST1I6IDUwNCxcbiAgVU5FWFBFQ1RFRF9GUkFNRTogNTA1LFxuICBSRVNPVVJDRV9FUlJPUjogNTA2LFxuICBOT1RfQUxMT1dFRDogNTMwLFxuICBOT1RfSU1QTEVNRU5URUQ6IDU0MCxcbiAgSU5URVJOQUxfRVJST1I6IDU0MVxufTtcblxubW9kdWxlLmV4cG9ydHMuY29uc3RhbnRfc3RycyA9IHtcbiAgXCIxXCI6IFwiRlJBTUUtTUVUSE9EXCIsXG4gIFwiMlwiOiBcIkZSQU1FLUhFQURFUlwiLFxuICBcIjNcIjogXCJGUkFNRS1CT0RZXCIsXG4gIFwiOFwiOiBcIkZSQU1FLUhFQVJUQkVBVFwiLFxuICBcIjIwMFwiOiBcIlJFUExZLVNVQ0NFU1NcIixcbiAgXCIyMDZcIjogXCJGUkFNRS1FTkRcIixcbiAgXCIzMTFcIjogXCJDT05URU5ULVRPTy1MQVJHRVwiLFxuICBcIjMxMlwiOiBcIk5PLVJPVVRFXCIsXG4gIFwiMzEzXCI6IFwiTk8tQ09OU1VNRVJTXCIsXG4gIFwiMzIwXCI6IFwiQ09OTkVDVElPTi1GT1JDRURcIixcbiAgXCI0MDJcIjogXCJJTlZBTElELVBBVEhcIixcbiAgXCI0MDNcIjogXCJBQ0NFU1MtUkVGVVNFRFwiLFxuICBcIjQwNFwiOiBcIk5PVC1GT1VORFwiLFxuICBcIjQwNVwiOiBcIlJFU09VUkNFLUxPQ0tFRFwiLFxuICBcIjQwNlwiOiBcIlBSRUNPTkRJVElPTi1GQUlMRURcIixcbiAgXCI1MDFcIjogXCJGUkFNRS1FUlJPUlwiLFxuICBcIjUwMlwiOiBcIlNZTlRBWC1FUlJPUlwiLFxuICBcIjUwM1wiOiBcIkNPTU1BTkQtSU5WQUxJRFwiLFxuICBcIjUwNFwiOiBcIkNIQU5ORUwtRVJST1JcIixcbiAgXCI1MDVcIjogXCJVTkVYUEVDVEVELUZSQU1FXCIsXG4gIFwiNTA2XCI6IFwiUkVTT1VSQ0UtRVJST1JcIixcbiAgXCI1MzBcIjogXCJOT1QtQUxMT1dFRFwiLFxuICBcIjU0MFwiOiBcIk5PVC1JTVBMRU1FTlRFRFwiLFxuICBcIjU0MVwiOiBcIklOVEVSTkFMLUVSUk9SXCIsXG4gIFwiNDA5NlwiOiBcIkZSQU1FLU1JTi1TSVpFXCJcbn07XG5cbm1vZHVsZS5leHBvcnRzLkZSQU1FX09WRVJIRUFEID0gODtcblxubW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24oaWQsIGJ1Zikge1xuICBzd2l0Y2ggKGlkKSB7XG4gICBjYXNlIDY1NTM3MDpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvblN0YXJ0KGJ1Zik7XG5cbiAgIGNhc2UgNjU1MzcxOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uU3RhcnRPayhidWYpO1xuXG4gICBjYXNlIDY1NTM4MDpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvblNlY3VyZShidWYpO1xuXG4gICBjYXNlIDY1NTM4MTpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvblNlY3VyZU9rKGJ1Zik7XG5cbiAgIGNhc2UgNjU1MzkwOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uVHVuZShidWYpO1xuXG4gICBjYXNlIDY1NTM5MTpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvblR1bmVPayhidWYpO1xuXG4gICBjYXNlIDY1NTQwMDpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvbk9wZW4oYnVmKTtcblxuICAgY2FzZSA2NTU0MDE6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25PcGVuT2soYnVmKTtcblxuICAgY2FzZSA2NTU0MTA6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25DbG9zZShidWYpO1xuXG4gICBjYXNlIDY1NTQxMTpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvbkNsb3NlT2soYnVmKTtcblxuICAgY2FzZSA2NTU0MjA6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25CbG9ja2VkKGJ1Zik7XG5cbiAgIGNhc2UgNjU1NDIxOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uVW5ibG9ja2VkKGJ1Zik7XG5cbiAgIGNhc2UgMTMxMDczMDpcbiAgICByZXR1cm4gZGVjb2RlQ2hhbm5lbE9wZW4oYnVmKTtcblxuICAgY2FzZSAxMzEwNzMxOlxuICAgIHJldHVybiBkZWNvZGVDaGFubmVsT3Blbk9rKGJ1Zik7XG5cbiAgIGNhc2UgMTMxMDc0MDpcbiAgICByZXR1cm4gZGVjb2RlQ2hhbm5lbEZsb3coYnVmKTtcblxuICAgY2FzZSAxMzEwNzQxOlxuICAgIHJldHVybiBkZWNvZGVDaGFubmVsRmxvd09rKGJ1Zik7XG5cbiAgIGNhc2UgMTMxMDc2MDpcbiAgICByZXR1cm4gZGVjb2RlQ2hhbm5lbENsb3NlKGJ1Zik7XG5cbiAgIGNhc2UgMTMxMDc2MTpcbiAgICByZXR1cm4gZGVjb2RlQ2hhbm5lbENsb3NlT2soYnVmKTtcblxuICAgY2FzZSAxOTY2MDkwOlxuICAgIHJldHVybiBkZWNvZGVBY2Nlc3NSZXF1ZXN0KGJ1Zik7XG5cbiAgIGNhc2UgMTk2NjA5MTpcbiAgICByZXR1cm4gZGVjb2RlQWNjZXNzUmVxdWVzdE9rKGJ1Zik7XG5cbiAgIGNhc2UgMjYyMTQ1MDpcbiAgICByZXR1cm4gZGVjb2RlRXhjaGFuZ2VEZWNsYXJlKGJ1Zik7XG5cbiAgIGNhc2UgMjYyMTQ1MTpcbiAgICByZXR1cm4gZGVjb2RlRXhjaGFuZ2VEZWNsYXJlT2soYnVmKTtcblxuICAgY2FzZSAyNjIxNDYwOlxuICAgIHJldHVybiBkZWNvZGVFeGNoYW5nZURlbGV0ZShidWYpO1xuXG4gICBjYXNlIDI2MjE0NjE6XG4gICAgcmV0dXJuIGRlY29kZUV4Y2hhbmdlRGVsZXRlT2soYnVmKTtcblxuICAgY2FzZSAyNjIxNDcwOlxuICAgIHJldHVybiBkZWNvZGVFeGNoYW5nZUJpbmQoYnVmKTtcblxuICAgY2FzZSAyNjIxNDcxOlxuICAgIHJldHVybiBkZWNvZGVFeGNoYW5nZUJpbmRPayhidWYpO1xuXG4gICBjYXNlIDI2MjE0ODA6XG4gICAgcmV0dXJuIGRlY29kZUV4Y2hhbmdlVW5iaW5kKGJ1Zik7XG5cbiAgIGNhc2UgMjYyMTQ5MTpcbiAgICByZXR1cm4gZGVjb2RlRXhjaGFuZ2VVbmJpbmRPayhidWYpO1xuXG4gICBjYXNlIDMyNzY4MTA6XG4gICAgcmV0dXJuIGRlY29kZVF1ZXVlRGVjbGFyZShidWYpO1xuXG4gICBjYXNlIDMyNzY4MTE6XG4gICAgcmV0dXJuIGRlY29kZVF1ZXVlRGVjbGFyZU9rKGJ1Zik7XG5cbiAgIGNhc2UgMzI3NjgyMDpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVCaW5kKGJ1Zik7XG5cbiAgIGNhc2UgMzI3NjgyMTpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVCaW5kT2soYnVmKTtcblxuICAgY2FzZSAzMjc2ODMwOlxuICAgIHJldHVybiBkZWNvZGVRdWV1ZVB1cmdlKGJ1Zik7XG5cbiAgIGNhc2UgMzI3NjgzMTpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVQdXJnZU9rKGJ1Zik7XG5cbiAgIGNhc2UgMzI3Njg0MDpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVEZWxldGUoYnVmKTtcblxuICAgY2FzZSAzMjc2ODQxOlxuICAgIHJldHVybiBkZWNvZGVRdWV1ZURlbGV0ZU9rKGJ1Zik7XG5cbiAgIGNhc2UgMzI3Njg1MDpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVVbmJpbmQoYnVmKTtcblxuICAgY2FzZSAzMjc2ODUxOlxuICAgIHJldHVybiBkZWNvZGVRdWV1ZVVuYmluZE9rKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjE3MDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNRb3MoYnVmKTtcblxuICAgY2FzZSAzOTMyMTcxOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY1Fvc09rKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjE4MDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNDb25zdW1lKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjE4MTpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNDb25zdW1lT2soYnVmKTtcblxuICAgY2FzZSAzOTMyMTkwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY0NhbmNlbChidWYpO1xuXG4gICBjYXNlIDM5MzIxOTE6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljQ2FuY2VsT2soYnVmKTtcblxuICAgY2FzZSAzOTMyMjAwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY1B1Ymxpc2goYnVmKTtcblxuICAgY2FzZSAzOTMyMjEwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY1JldHVybihidWYpO1xuXG4gICBjYXNlIDM5MzIyMjA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljRGVsaXZlcihidWYpO1xuXG4gICBjYXNlIDM5MzIyMzA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljR2V0KGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjIzMTpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNHZXRPayhidWYpO1xuXG4gICBjYXNlIDM5MzIyMzI6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljR2V0RW1wdHkoYnVmKTtcblxuICAgY2FzZSAzOTMyMjQwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY0FjayhidWYpO1xuXG4gICBjYXNlIDM5MzIyNTA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljUmVqZWN0KGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjI2MDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNSZWNvdmVyQXN5bmMoYnVmKTtcblxuICAgY2FzZSAzOTMyMjcwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY1JlY292ZXIoYnVmKTtcblxuICAgY2FzZSAzOTMyMjcxOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY1JlY292ZXJPayhidWYpO1xuXG4gICBjYXNlIDM5MzIyODA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljTmFjayhidWYpO1xuXG4gICBjYXNlIDU4OTgyNTA6XG4gICAgcmV0dXJuIGRlY29kZVR4U2VsZWN0KGJ1Zik7XG5cbiAgIGNhc2UgNTg5ODI1MTpcbiAgICByZXR1cm4gZGVjb2RlVHhTZWxlY3RPayhidWYpO1xuXG4gICBjYXNlIDU4OTgyNjA6XG4gICAgcmV0dXJuIGRlY29kZVR4Q29tbWl0KGJ1Zik7XG5cbiAgIGNhc2UgNTg5ODI2MTpcbiAgICByZXR1cm4gZGVjb2RlVHhDb21taXRPayhidWYpO1xuXG4gICBjYXNlIDU4OTgyNzA6XG4gICAgcmV0dXJuIGRlY29kZVR4Um9sbGJhY2soYnVmKTtcblxuICAgY2FzZSA1ODk4MjcxOlxuICAgIHJldHVybiBkZWNvZGVUeFJvbGxiYWNrT2soYnVmKTtcblxuICAgY2FzZSA1NTcwNTcwOlxuICAgIHJldHVybiBkZWNvZGVDb25maXJtU2VsZWN0KGJ1Zik7XG5cbiAgIGNhc2UgNTU3MDU3MTpcbiAgICByZXR1cm4gZGVjb2RlQ29uZmlybVNlbGVjdE9rKGJ1Zik7XG5cbiAgIGNhc2UgNjA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljUHJvcGVydGllcyhidWYpO1xuXG4gICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY2xhc3MvbWV0aG9kIElEXCIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGVNZXRob2QgPSBmdW5jdGlvbihpZCwgY2hhbm5lbCwgZmllbGRzKSB7XG4gIHN3aXRjaCAoaWQpIHtcbiAgIGNhc2UgNjU1MzcwOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uU3RhcnQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTUzNzE6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25TdGFydE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1MzgwOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uU2VjdXJlKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1MzgxOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uU2VjdXJlT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTUzOTA6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25UdW5lKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1MzkxOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uVHVuZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1NDAwOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uT3BlbihjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTQwMTpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvbk9wZW5PayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTQxMDpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvbkNsb3NlKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1NDExOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uQ2xvc2VPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTQyMDpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvbkJsb2NrZWQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTU0MjE6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25VbmJsb2NrZWQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAxMzEwNzMwOlxuICAgIHJldHVybiBlbmNvZGVDaGFubmVsT3BlbihjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDEzMTA3MzE6XG4gICAgcmV0dXJuIGVuY29kZUNoYW5uZWxPcGVuT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAxMzEwNzQwOlxuICAgIHJldHVybiBlbmNvZGVDaGFubmVsRmxvdyhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDEzMTA3NDE6XG4gICAgcmV0dXJuIGVuY29kZUNoYW5uZWxGbG93T2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAxMzEwNzYwOlxuICAgIHJldHVybiBlbmNvZGVDaGFubmVsQ2xvc2UoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAxMzEwNzYxOlxuICAgIHJldHVybiBlbmNvZGVDaGFubmVsQ2xvc2VPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDE5NjYwOTA6XG4gICAgcmV0dXJuIGVuY29kZUFjY2Vzc1JlcXVlc3QoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAxOTY2MDkxOlxuICAgIHJldHVybiBlbmNvZGVBY2Nlc3NSZXF1ZXN0T2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAyNjIxNDUwOlxuICAgIHJldHVybiBlbmNvZGVFeGNoYW5nZURlY2xhcmUoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAyNjIxNDUxOlxuICAgIHJldHVybiBlbmNvZGVFeGNoYW5nZURlY2xhcmVPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDI2MjE0NjA6XG4gICAgcmV0dXJuIGVuY29kZUV4Y2hhbmdlRGVsZXRlKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMjYyMTQ2MTpcbiAgICByZXR1cm4gZW5jb2RlRXhjaGFuZ2VEZWxldGVPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDI2MjE0NzA6XG4gICAgcmV0dXJuIGVuY29kZUV4Y2hhbmdlQmluZChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDI2MjE0NzE6XG4gICAgcmV0dXJuIGVuY29kZUV4Y2hhbmdlQmluZE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMjYyMTQ4MDpcbiAgICByZXR1cm4gZW5jb2RlRXhjaGFuZ2VVbmJpbmQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAyNjIxNDkxOlxuICAgIHJldHVybiBlbmNvZGVFeGNoYW5nZVVuYmluZE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzI3NjgxMDpcbiAgICByZXR1cm4gZW5jb2RlUXVldWVEZWNsYXJlKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzI3NjgxMTpcbiAgICByZXR1cm4gZW5jb2RlUXVldWVEZWNsYXJlT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzMjc2ODIwOlxuICAgIHJldHVybiBlbmNvZGVRdWV1ZUJpbmQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzMjc2ODIxOlxuICAgIHJldHVybiBlbmNvZGVRdWV1ZUJpbmRPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4MzA6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlUHVyZ2UoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzMjc2ODMxOlxuICAgIHJldHVybiBlbmNvZGVRdWV1ZVB1cmdlT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzMjc2ODQwOlxuICAgIHJldHVybiBlbmNvZGVRdWV1ZURlbGV0ZShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4NDE6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlRGVsZXRlT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzMjc2ODUwOlxuICAgIHJldHVybiBlbmNvZGVRdWV1ZVVuYmluZChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4NTE6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlVW5iaW5kT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMTcwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY1FvcyhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIxNzE6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUW9zT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMTgwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY0NvbnN1bWUoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMTgxOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY0NvbnN1bWVPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIxOTA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljQ2FuY2VsKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjE5MTpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNDYW5jZWxPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyMDA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUHVibGlzaChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyMTA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUmV0dXJuKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjIyMDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNEZWxpdmVyKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjIzMDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNHZXQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjMxOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY0dldE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjIzMjpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNHZXRFbXB0eShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyNDA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljQWNrKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjI1MDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNSZWplY3QoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjYwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY1JlY292ZXJBc3luYyhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyNzA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUmVjb3ZlcihjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyNzE6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUmVjb3Zlck9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjI4MDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNOYWNrKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNTg5ODI1MDpcbiAgICByZXR1cm4gZW5jb2RlVHhTZWxlY3QoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA1ODk4MjUxOlxuICAgIHJldHVybiBlbmNvZGVUeFNlbGVjdE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNTg5ODI2MDpcbiAgICByZXR1cm4gZW5jb2RlVHhDb21taXQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA1ODk4MjYxOlxuICAgIHJldHVybiBlbmNvZGVUeENvbW1pdE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNTg5ODI3MDpcbiAgICByZXR1cm4gZW5jb2RlVHhSb2xsYmFjayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDU4OTgyNzE6XG4gICAgcmV0dXJuIGVuY29kZVR4Um9sbGJhY2tPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDU1NzA1NzA6XG4gICAgcmV0dXJuIGVuY29kZUNvbmZpcm1TZWxlY3QoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA1NTcwNTcxOlxuICAgIHJldHVybiBlbmNvZGVDb25maXJtU2VsZWN0T2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNsYXNzL21ldGhvZCBJRFwiKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZW5jb2RlUHJvcGVydGllcyA9IGZ1bmN0aW9uKGlkLCBjaGFubmVsLCBzaXplLCBmaWVsZHMpIHtcbiAgc3dpdGNoIChpZCkge1xuICAgY2FzZSA2MDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNQcm9wZXJ0aWVzKGNoYW5uZWwsIHNpemUsIGZpZWxkcyk7XG5cbiAgIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjbGFzcy9wcm9wZXJ0aWVzIElEXCIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pbmZvID0gZnVuY3Rpb24oaWQpIHtcbiAgc3dpdGNoIChpZCkge1xuICAgY2FzZSA2NTUzNzA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uU3RhcnQ7XG5cbiAgIGNhc2UgNjU1MzcxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvblN0YXJ0T2s7XG5cbiAgIGNhc2UgNjU1MzgwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvblNlY3VyZTtcblxuICAgY2FzZSA2NTUzODE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uU2VjdXJlT2s7XG5cbiAgIGNhc2UgNjU1MzkwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvblR1bmU7XG5cbiAgIGNhc2UgNjU1MzkxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvblR1bmVPaztcblxuICAgY2FzZSA2NTU0MDA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uT3BlbjtcblxuICAgY2FzZSA2NTU0MDE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uT3Blbk9rO1xuXG4gICBjYXNlIDY1NTQxMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25DbG9zZTtcblxuICAgY2FzZSA2NTU0MTE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uQ2xvc2VPaztcblxuICAgY2FzZSA2NTU0MjA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uQmxvY2tlZDtcblxuICAgY2FzZSA2NTU0MjE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uVW5ibG9ja2VkO1xuXG4gICBjYXNlIDEzMTA3MzA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9DaGFubmVsT3BlbjtcblxuICAgY2FzZSAxMzEwNzMxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ2hhbm5lbE9wZW5PaztcblxuICAgY2FzZSAxMzEwNzQwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ2hhbm5lbEZsb3c7XG5cbiAgIGNhc2UgMTMxMDc0MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0NoYW5uZWxGbG93T2s7XG5cbiAgIGNhc2UgMTMxMDc2MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0NoYW5uZWxDbG9zZTtcblxuICAgY2FzZSAxMzEwNzYxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ2hhbm5lbENsb3NlT2s7XG5cbiAgIGNhc2UgMTk2NjA5MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0FjY2Vzc1JlcXVlc3Q7XG5cbiAgIGNhc2UgMTk2NjA5MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0FjY2Vzc1JlcXVlc3RPaztcblxuICAgY2FzZSAyNjIxNDUwOlxuICAgIHJldHVybiBtZXRob2RJbmZvRXhjaGFuZ2VEZWNsYXJlO1xuXG4gICBjYXNlIDI2MjE0NTE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9FeGNoYW5nZURlY2xhcmVPaztcblxuICAgY2FzZSAyNjIxNDYwOlxuICAgIHJldHVybiBtZXRob2RJbmZvRXhjaGFuZ2VEZWxldGU7XG5cbiAgIGNhc2UgMjYyMTQ2MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0V4Y2hhbmdlRGVsZXRlT2s7XG5cbiAgIGNhc2UgMjYyMTQ3MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0V4Y2hhbmdlQmluZDtcblxuICAgY2FzZSAyNjIxNDcxOlxuICAgIHJldHVybiBtZXRob2RJbmZvRXhjaGFuZ2VCaW5kT2s7XG5cbiAgIGNhc2UgMjYyMTQ4MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0V4Y2hhbmdlVW5iaW5kO1xuXG4gICBjYXNlIDI2MjE0OTE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9FeGNoYW5nZVVuYmluZE9rO1xuXG4gICBjYXNlIDMyNzY4MTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9RdWV1ZURlY2xhcmU7XG5cbiAgIGNhc2UgMzI3NjgxMTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlRGVjbGFyZU9rO1xuXG4gICBjYXNlIDMyNzY4MjA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9RdWV1ZUJpbmQ7XG5cbiAgIGNhc2UgMzI3NjgyMTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlQmluZE9rO1xuXG4gICBjYXNlIDMyNzY4MzA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9RdWV1ZVB1cmdlO1xuXG4gICBjYXNlIDMyNzY4MzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9RdWV1ZVB1cmdlT2s7XG5cbiAgIGNhc2UgMzI3Njg0MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlRGVsZXRlO1xuXG4gICBjYXNlIDMyNzY4NDE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9RdWV1ZURlbGV0ZU9rO1xuXG4gICBjYXNlIDMyNzY4NTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9RdWV1ZVVuYmluZDtcblxuICAgY2FzZSAzMjc2ODUxOlxuICAgIHJldHVybiBtZXRob2RJbmZvUXVldWVVbmJpbmRPaztcblxuICAgY2FzZSAzOTMyMTcwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNRb3M7XG5cbiAgIGNhc2UgMzkzMjE3MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljUW9zT2s7XG5cbiAgIGNhc2UgMzkzMjE4MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljQ29uc3VtZTtcblxuICAgY2FzZSAzOTMyMTgxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNDb25zdW1lT2s7XG5cbiAgIGNhc2UgMzkzMjE5MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljQ2FuY2VsO1xuXG4gICBjYXNlIDM5MzIxOTE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY0NhbmNlbE9rO1xuXG4gICBjYXNlIDM5MzIyMDA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY1B1Ymxpc2g7XG5cbiAgIGNhc2UgMzkzMjIxMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljUmV0dXJuO1xuXG4gICBjYXNlIDM5MzIyMjA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY0RlbGl2ZXI7XG5cbiAgIGNhc2UgMzkzMjIzMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljR2V0O1xuXG4gICBjYXNlIDM5MzIyMzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY0dldE9rO1xuXG4gICBjYXNlIDM5MzIyMzI6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY0dldEVtcHR5O1xuXG4gICBjYXNlIDM5MzIyNDA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY0FjaztcblxuICAgY2FzZSAzOTMyMjUwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNSZWplY3Q7XG5cbiAgIGNhc2UgMzkzMjI2MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljUmVjb3ZlckFzeW5jO1xuXG4gICBjYXNlIDM5MzIyNzA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY1JlY292ZXI7XG5cbiAgIGNhc2UgMzkzMjI3MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljUmVjb3Zlck9rO1xuXG4gICBjYXNlIDM5MzIyODA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY05hY2s7XG5cbiAgIGNhc2UgNTg5ODI1MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1R4U2VsZWN0O1xuXG4gICBjYXNlIDU4OTgyNTE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9UeFNlbGVjdE9rO1xuXG4gICBjYXNlIDU4OTgyNjA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9UeENvbW1pdDtcblxuICAgY2FzZSA1ODk4MjYxOlxuICAgIHJldHVybiBtZXRob2RJbmZvVHhDb21taXRPaztcblxuICAgY2FzZSA1ODk4MjcwOlxuICAgIHJldHVybiBtZXRob2RJbmZvVHhSb2xsYmFjaztcblxuICAgY2FzZSA1ODk4MjcxOlxuICAgIHJldHVybiBtZXRob2RJbmZvVHhSb2xsYmFja09rO1xuXG4gICBjYXNlIDU1NzA1NzA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25maXJtU2VsZWN0O1xuXG4gICBjYXNlIDU1NzA1NzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25maXJtU2VsZWN0T2s7XG5cbiAgIGNhc2UgNjA6XG4gICAgcmV0dXJuIHByb3BlcnRpZXNJbmZvQmFzaWNQcm9wZXJ0aWVzO1xuXG4gICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY2xhc3MvbWV0aG9kIElEXCIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uU3RhcnQgPSA2NTUzNzA7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvblN0YXJ0ID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25TdGFydCA9IHtcbiAgaWQ6IDY1NTM3MCxcbiAgbmFtZTogXCJDb25uZWN0aW9uU3RhcnRcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJvY3RldFwiLFxuICAgIG5hbWU6IFwidmVyc2lvbk1ham9yXCIsXG4gICAgXCJkZWZhdWx0XCI6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwib2N0ZXRcIixcbiAgICBuYW1lOiBcInZlcnNpb25NaW5vclwiLFxuICAgIFwiZGVmYXVsdFwiOiA5XG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJzZXJ2ZXJQcm9wZXJ0aWVzXCJcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ3N0clwiLFxuICAgIG5hbWU6IFwibWVjaGFuaXNtc1wiLFxuICAgIFwiZGVmYXVsdFwiOiBcIlBMQUlOXCJcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ3N0clwiLFxuICAgIG5hbWU6IFwibG9jYWxlc1wiLFxuICAgIFwiZGVmYXVsdFwiOiBcImVuX1VTXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uU3RhcnRPayA9IDY1NTM3MTtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uU3RhcnRPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uU3RhcnRPayA9IHtcbiAgaWQ6IDY1NTM3MSxcbiAgbmFtZTogXCJDb25uZWN0aW9uU3RhcnRPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJjbGllbnRQcm9wZXJ0aWVzXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcIm1lY2hhbmlzbVwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIlBMQUlOXCJcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ3N0clwiLFxuICAgIG5hbWU6IFwicmVzcG9uc2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwibG9jYWxlXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiZW5fVVNcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25TZWN1cmUgPSA2NTUzODA7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvblNlY3VyZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uU2VjdXJlID0ge1xuICBpZDogNjU1MzgwLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25TZWN1cmVcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJsb25nc3RyXCIsXG4gICAgbmFtZTogXCJjaGFsbGVuZ2VcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25TZWN1cmVPayA9IDY1NTM4MTtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uU2VjdXJlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvblNlY3VyZU9rID0ge1xuICBpZDogNjU1MzgxLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25TZWN1cmVPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdzdHJcIixcbiAgICBuYW1lOiBcInJlc3BvbnNlXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uVHVuZSA9IDY1NTM5MDtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uVHVuZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uVHVuZSA9IHtcbiAgaWQ6IDY1NTM5MCxcbiAgbmFtZTogXCJDb25uZWN0aW9uVHVuZVwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJjaGFubmVsTWF4XCIsXG4gICAgXCJkZWZhdWx0XCI6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ1wiLFxuICAgIG5hbWU6IFwiZnJhbWVNYXhcIixcbiAgICBcImRlZmF1bHRcIjogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwiaGVhcnRiZWF0XCIsXG4gICAgXCJkZWZhdWx0XCI6IDBcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uVHVuZU9rID0gNjU1MzkxO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25UdW5lT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvblR1bmVPayA9IHtcbiAgaWQ6IDY1NTM5MSxcbiAgbmFtZTogXCJDb25uZWN0aW9uVHVuZU9rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcImNoYW5uZWxNYXhcIixcbiAgICBcImRlZmF1bHRcIjogMFxuICB9LCB7XG4gICAgdHlwZTogXCJsb25nXCIsXG4gICAgbmFtZTogXCJmcmFtZU1heFwiLFxuICAgIFwiZGVmYXVsdFwiOiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJoZWFydGJlYXRcIixcbiAgICBcImRlZmF1bHRcIjogMFxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25PcGVuID0gNjU1NDAwO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25PcGVuID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25PcGVuID0ge1xuICBpZDogNjU1NDAwLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25PcGVuXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInZpcnR1YWxIb3N0XCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiL1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjYXBhYmlsaXRpZXNcIixcbiAgICBcImRlZmF1bHRcIjogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImluc2lzdFwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25PcGVuT2sgPSA2NTU0MDE7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvbk9wZW5PayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uT3Blbk9rID0ge1xuICBpZDogNjU1NDAxLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25PcGVuT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwia25vd25Ib3N0c1wiLFxuICAgIFwiZGVmYXVsdFwiOiBcIlwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbkNsb3NlID0gNjU1NDEwO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25DbG9zZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uQ2xvc2UgPSB7XG4gIGlkOiA2NTU0MTAsXG4gIG5hbWU6IFwiQ29ubmVjdGlvbkNsb3NlXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInJlcGx5Q29kZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJyZXBseVRleHRcIixcbiAgICBcImRlZmF1bHRcIjogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwiY2xhc3NJZFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJtZXRob2RJZFwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbkNsb3NlT2sgPSA2NTU0MTE7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvbkNsb3NlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvbkNsb3NlT2sgPSB7XG4gIGlkOiA2NTU0MTEsXG4gIG5hbWU6IFwiQ29ubmVjdGlvbkNsb3NlT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25CbG9ja2VkID0gNjU1NDIwO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25CbG9ja2VkID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25CbG9ja2VkID0ge1xuICBpZDogNjU1NDIwLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25CbG9ja2VkXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJlYXNvblwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIlwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvblVuYmxvY2tlZCA9IDY1NTQyMTtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uVW5ibG9ja2VkID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25VbmJsb2NrZWQgPSB7XG4gIGlkOiA2NTU0MjEsXG4gIG5hbWU6IFwiQ29ubmVjdGlvblVuYmxvY2tlZFwiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbE9wZW4gPSAxMzEwNzMwO1xuXG52YXIgbWV0aG9kSW5mb0NoYW5uZWxPcGVuID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0NoYW5uZWxPcGVuID0ge1xuICBpZDogMTMxMDczMCxcbiAgbmFtZTogXCJDaGFubmVsT3BlblwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJvdXRPZkJhbmRcIixcbiAgICBcImRlZmF1bHRcIjogXCJcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNoYW5uZWxPcGVuT2sgPSAxMzEwNzMxO1xuXG52YXIgbWV0aG9kSW5mb0NoYW5uZWxPcGVuT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ2hhbm5lbE9wZW5PayA9IHtcbiAgaWQ6IDEzMTA3MzEsXG4gIG5hbWU6IFwiQ2hhbm5lbE9wZW5Pa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdzdHJcIixcbiAgICBuYW1lOiBcImNoYW5uZWxJZFwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIlwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbEZsb3cgPSAxMzEwNzQwO1xuXG52YXIgbWV0aG9kSW5mb0NoYW5uZWxGbG93ID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0NoYW5uZWxGbG93ID0ge1xuICBpZDogMTMxMDc0MCxcbiAgbmFtZTogXCJDaGFubmVsRmxvd1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiYWN0aXZlXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5DaGFubmVsRmxvd09rID0gMTMxMDc0MTtcblxudmFyIG1ldGhvZEluZm9DaGFubmVsRmxvd09rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0NoYW5uZWxGbG93T2sgPSB7XG4gIGlkOiAxMzEwNzQxLFxuICBuYW1lOiBcIkNoYW5uZWxGbG93T2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImFjdGl2ZVwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbENsb3NlID0gMTMxMDc2MDtcblxudmFyIG1ldGhvZEluZm9DaGFubmVsQ2xvc2UgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ2hhbm5lbENsb3NlID0ge1xuICBpZDogMTMxMDc2MCxcbiAgbmFtZTogXCJDaGFubmVsQ2xvc2VcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwicmVwbHlDb2RlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJlcGx5VGV4dFwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJjbGFzc0lkXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcIm1ldGhvZElkXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5DaGFubmVsQ2xvc2VPayA9IDEzMTA3NjE7XG5cbnZhciBtZXRob2RJbmZvQ2hhbm5lbENsb3NlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ2hhbm5lbENsb3NlT2sgPSB7XG4gIGlkOiAxMzEwNzYxLFxuICBuYW1lOiBcIkNoYW5uZWxDbG9zZU9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5BY2Nlc3NSZXF1ZXN0ID0gMTk2NjA5MDtcblxudmFyIG1ldGhvZEluZm9BY2Nlc3NSZXF1ZXN0ID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0FjY2Vzc1JlcXVlc3QgPSB7XG4gIGlkOiAxOTY2MDkwLFxuICBuYW1lOiBcIkFjY2Vzc1JlcXVlc3RcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicmVhbG1cIixcbiAgICBcImRlZmF1bHRcIjogXCIvZGF0YVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiZXhjbHVzaXZlXCIsXG4gICAgXCJkZWZhdWx0XCI6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicGFzc2l2ZVwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMFxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImFjdGl2ZVwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMFxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIndyaXRlXCIsXG4gICAgXCJkZWZhdWx0XCI6ICEwXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicmVhZFwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMFxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkFjY2Vzc1JlcXVlc3RPayA9IDE5NjYwOTE7XG5cbnZhciBtZXRob2RJbmZvQWNjZXNzUmVxdWVzdE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0FjY2Vzc1JlcXVlc3RPayA9IHtcbiAgaWQ6IDE5NjYwOTEsXG4gIG5hbWU6IFwiQWNjZXNzUmVxdWVzdE9rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIFwiZGVmYXVsdFwiOiAxXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuRXhjaGFuZ2VEZWNsYXJlID0gMjYyMTQ1MDtcblxudmFyIG1ldGhvZEluZm9FeGNoYW5nZURlY2xhcmUgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvRXhjaGFuZ2VEZWNsYXJlID0ge1xuICBpZDogMjYyMTQ1MCxcbiAgbmFtZTogXCJFeGNoYW5nZURlY2xhcmVcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgXCJkZWZhdWx0XCI6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInR5cGVcIixcbiAgICBcImRlZmF1bHRcIjogXCJkaXJlY3RcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcInBhc3NpdmVcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJkdXJhYmxlXCIsXG4gICAgXCJkZWZhdWx0XCI6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiYXV0b0RlbGV0ZVwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImludGVybmFsXCIsXG4gICAgXCJkZWZhdWx0XCI6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgXCJkZWZhdWx0XCI6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJhcmd1bWVudHNcIixcbiAgICBcImRlZmF1bHRcIjoge31cbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZURlY2xhcmVPayA9IDI2MjE0NTE7XG5cbnZhciBtZXRob2RJbmZvRXhjaGFuZ2VEZWNsYXJlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvRXhjaGFuZ2VEZWNsYXJlT2sgPSB7XG4gIGlkOiAyNjIxNDUxLFxuICBuYW1lOiBcIkV4Y2hhbmdlRGVjbGFyZU9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZURlbGV0ZSA9IDI2MjE0NjA7XG5cbnZhciBtZXRob2RJbmZvRXhjaGFuZ2VEZWxldGUgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvRXhjaGFuZ2VEZWxldGUgPSB7XG4gIGlkOiAyNjIxNDYwLFxuICBuYW1lOiBcIkV4Y2hhbmdlRGVsZXRlXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIFwiZGVmYXVsdFwiOiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJleGNoYW5nZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiaWZVbnVzZWRcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZURlbGV0ZU9rID0gMjYyMTQ2MTtcblxudmFyIG1ldGhvZEluZm9FeGNoYW5nZURlbGV0ZU9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0V4Y2hhbmdlRGVsZXRlT2sgPSB7XG4gIGlkOiAyNjIxNDYxLFxuICBuYW1lOiBcIkV4Y2hhbmdlRGVsZXRlT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkV4Y2hhbmdlQmluZCA9IDI2MjE0NzA7XG5cbnZhciBtZXRob2RJbmZvRXhjaGFuZ2VCaW5kID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0V4Y2hhbmdlQmluZCA9IHtcbiAgaWQ6IDI2MjE0NzAsXG4gIG5hbWU6IFwiRXhjaGFuZ2VCaW5kXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIFwiZGVmYXVsdFwiOiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJkZXN0aW5hdGlvblwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJzb3VyY2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicm91dGluZ0tleVwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgXCJkZWZhdWx0XCI6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJhcmd1bWVudHNcIixcbiAgICBcImRlZmF1bHRcIjoge31cbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZUJpbmRPayA9IDI2MjE0NzE7XG5cbnZhciBtZXRob2RJbmZvRXhjaGFuZ2VCaW5kT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvRXhjaGFuZ2VCaW5kT2sgPSB7XG4gIGlkOiAyNjIxNDcxLFxuICBuYW1lOiBcIkV4Y2hhbmdlQmluZE9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZVVuYmluZCA9IDI2MjE0ODA7XG5cbnZhciBtZXRob2RJbmZvRXhjaGFuZ2VVbmJpbmQgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvRXhjaGFuZ2VVbmJpbmQgPSB7XG4gIGlkOiAyNjIxNDgwLFxuICBuYW1lOiBcIkV4Y2hhbmdlVW5iaW5kXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIFwiZGVmYXVsdFwiOiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJkZXN0aW5hdGlvblwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJzb3VyY2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicm91dGluZ0tleVwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgXCJkZWZhdWx0XCI6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJhcmd1bWVudHNcIixcbiAgICBcImRlZmF1bHRcIjoge31cbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZVVuYmluZE9rID0gMjYyMTQ5MTtcblxudmFyIG1ldGhvZEluZm9FeGNoYW5nZVVuYmluZE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0V4Y2hhbmdlVW5iaW5kT2sgPSB7XG4gIGlkOiAyNjIxNDkxLFxuICBuYW1lOiBcIkV4Y2hhbmdlVW5iaW5kT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlRGVjbGFyZSA9IDMyNzY4MTA7XG5cbnZhciBtZXRob2RJbmZvUXVldWVEZWNsYXJlID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1F1ZXVlRGVjbGFyZSA9IHtcbiAgaWQ6IDMyNzY4MTAsXG4gIG5hbWU6IFwiUXVldWVEZWNsYXJlXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIFwiZGVmYXVsdFwiOiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJxdWV1ZVwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicGFzc2l2ZVwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImR1cmFibGVcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJleGNsdXNpdmVcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJhdXRvRGVsZXRlXCIsXG4gICAgXCJkZWZhdWx0XCI6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgXCJkZWZhdWx0XCI6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJhcmd1bWVudHNcIixcbiAgICBcImRlZmF1bHRcIjoge31cbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZURlY2xhcmVPayA9IDMyNzY4MTE7XG5cbnZhciBtZXRob2RJbmZvUXVldWVEZWNsYXJlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvUXVldWVEZWNsYXJlT2sgPSB7XG4gIGlkOiAzMjc2ODExLFxuICBuYW1lOiBcIlF1ZXVlRGVjbGFyZU9rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ1wiLFxuICAgIG5hbWU6IFwibWVzc2FnZUNvdW50XCJcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ1wiLFxuICAgIG5hbWU6IFwiY29uc3VtZXJDb3VudFwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVCaW5kID0gMzI3NjgyMDtcblxudmFyIG1ldGhvZEluZm9RdWV1ZUJpbmQgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvUXVldWVCaW5kID0ge1xuICBpZDogMzI3NjgyMCxcbiAgbmFtZTogXCJRdWV1ZUJpbmRcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgXCJkZWZhdWx0XCI6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIixcbiAgICBcImRlZmF1bHRcIjogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vd2FpdFwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgIG5hbWU6IFwiYXJndW1lbnRzXCIsXG4gICAgXCJkZWZhdWx0XCI6IHt9XG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVCaW5kT2sgPSAzMjc2ODIxO1xuXG52YXIgbWV0aG9kSW5mb1F1ZXVlQmluZE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1F1ZXVlQmluZE9rID0ge1xuICBpZDogMzI3NjgyMSxcbiAgbmFtZTogXCJRdWV1ZUJpbmRPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVQdXJnZSA9IDMyNzY4MzA7XG5cbnZhciBtZXRob2RJbmZvUXVldWVQdXJnZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZVB1cmdlID0ge1xuICBpZDogMzI3NjgzMCxcbiAgbmFtZTogXCJRdWV1ZVB1cmdlXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIFwiZGVmYXVsdFwiOiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJxdWV1ZVwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgXCJkZWZhdWx0XCI6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVQdXJnZU9rID0gMzI3NjgzMTtcblxudmFyIG1ldGhvZEluZm9RdWV1ZVB1cmdlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvUXVldWVQdXJnZU9rID0ge1xuICBpZDogMzI3NjgzMSxcbiAgbmFtZTogXCJRdWV1ZVB1cmdlT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJsb25nXCIsXG4gICAgbmFtZTogXCJtZXNzYWdlQ291bnRcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlRGVsZXRlID0gMzI3Njg0MDtcblxudmFyIG1ldGhvZEluZm9RdWV1ZURlbGV0ZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZURlbGV0ZSA9IHtcbiAgaWQ6IDMyNzY4NDAsXG4gIG5hbWU6IFwiUXVldWVEZWxldGVcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgXCJkZWZhdWx0XCI6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJpZlVudXNlZFwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImlmRW1wdHlcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZURlbGV0ZU9rID0gMzI3Njg0MTtcblxudmFyIG1ldGhvZEluZm9RdWV1ZURlbGV0ZU9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1F1ZXVlRGVsZXRlT2sgPSB7XG4gIGlkOiAzMjc2ODQxLFxuICBuYW1lOiBcIlF1ZXVlRGVsZXRlT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJsb25nXCIsXG4gICAgbmFtZTogXCJtZXNzYWdlQ291bnRcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlVW5iaW5kID0gMzI3Njg1MDtcblxudmFyIG1ldGhvZEluZm9RdWV1ZVVuYmluZCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZVVuYmluZCA9IHtcbiAgaWQ6IDMyNzY4NTAsXG4gIG5hbWU6IFwiUXVldWVVbmJpbmRcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgXCJkZWZhdWx0XCI6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIixcbiAgICBcImRlZmF1bHRcIjogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgIG5hbWU6IFwiYXJndW1lbnRzXCIsXG4gICAgXCJkZWZhdWx0XCI6IHt9XG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVVbmJpbmRPayA9IDMyNzY4NTE7XG5cbnZhciBtZXRob2RJbmZvUXVldWVVbmJpbmRPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZVVuYmluZE9rID0ge1xuICBpZDogMzI3Njg1MSxcbiAgbmFtZTogXCJRdWV1ZVVuYmluZE9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY1FvcyA9IDM5MzIxNzA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNRb3MgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNRb3MgPSB7XG4gIGlkOiAzOTMyMTcwLFxuICBuYW1lOiBcIkJhc2ljUW9zXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwibG9uZ1wiLFxuICAgIG5hbWU6IFwicHJlZmV0Y2hTaXplXCIsXG4gICAgXCJkZWZhdWx0XCI6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInByZWZldGNoQ291bnRcIixcbiAgICBcImRlZmF1bHRcIjogMFxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImdsb2JhbFwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljUW9zT2sgPSAzOTMyMTcxO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljUW9zT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNRb3NPayA9IHtcbiAgaWQ6IDM5MzIxNzEsXG4gIG5hbWU6IFwiQmFzaWNRb3NPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNDb25zdW1lID0gMzkzMjE4MDtcblxudmFyIG1ldGhvZEluZm9CYXNpY0NvbnN1bWUgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNDb25zdW1lID0ge1xuICBpZDogMzkzMjE4MCxcbiAgbmFtZTogXCJCYXNpY0NvbnN1bWVcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgXCJkZWZhdWx0XCI6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNvbnN1bWVyVGFnXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub0xvY2FsXCIsXG4gICAgXCJkZWZhdWx0XCI6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm9BY2tcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJleGNsdXNpdmVcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSwge1xuICAgIHR5cGU6IFwidGFibGVcIixcbiAgICBuYW1lOiBcImFyZ3VtZW50c1wiLFxuICAgIFwiZGVmYXVsdFwiOiB7fVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljQ29uc3VtZU9rID0gMzkzMjE4MTtcblxudmFyIG1ldGhvZEluZm9CYXNpY0NvbnN1bWVPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY0NvbnN1bWVPayA9IHtcbiAgaWQ6IDM5MzIxODEsXG4gIG5hbWU6IFwiQmFzaWNDb25zdW1lT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29uc3VtZXJUYWdcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljQ2FuY2VsID0gMzkzMjE5MDtcblxudmFyIG1ldGhvZEluZm9CYXNpY0NhbmNlbCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY0NhbmNlbCA9IHtcbiAgaWQ6IDM5MzIxOTAsXG4gIG5hbWU6IFwiQmFzaWNDYW5jZWxcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29uc3VtZXJUYWdcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vd2FpdFwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljQ2FuY2VsT2sgPSAzOTMyMTkxO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljQ2FuY2VsT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNDYW5jZWxPayA9IHtcbiAgaWQ6IDM5MzIxOTEsXG4gIG5hbWU6IFwiQmFzaWNDYW5jZWxPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjb25zdW1lclRhZ1wiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNQdWJsaXNoID0gMzkzMjIwMDtcblxudmFyIG1ldGhvZEluZm9CYXNpY1B1Ymxpc2ggPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNQdWJsaXNoID0ge1xuICBpZDogMzkzMjIwMCxcbiAgbmFtZTogXCJCYXNpY1B1Ymxpc2hcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgXCJkZWZhdWx0XCI6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIixcbiAgICBcImRlZmF1bHRcIjogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm1hbmRhdG9yeVwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImltbWVkaWF0ZVwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljUmV0dXJuID0gMzkzMjIxMDtcblxudmFyIG1ldGhvZEluZm9CYXNpY1JldHVybiA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY1JldHVybiA9IHtcbiAgaWQ6IDM5MzIyMTAsXG4gIG5hbWU6IFwiQmFzaWNSZXR1cm5cIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwicmVwbHlDb2RlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJlcGx5VGV4dFwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJleGNoYW5nZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJyb3V0aW5nS2V5XCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY0RlbGl2ZXIgPSAzOTMyMjIwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljRGVsaXZlciA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY0RlbGl2ZXIgPSB7XG4gIGlkOiAzOTMyMjIwLFxuICBuYW1lOiBcIkJhc2ljRGVsaXZlclwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjb25zdW1lclRhZ1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcImxvbmdsb25nXCIsXG4gICAgbmFtZTogXCJkZWxpdmVyeVRhZ1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicmVkZWxpdmVyZWRcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljR2V0ID0gMzkzMjIzMDtcblxudmFyIG1ldGhvZEluZm9CYXNpY0dldCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY0dldCA9IHtcbiAgaWQ6IDM5MzIyMzAsXG4gIG5hbWU6IFwiQmFzaWNHZXRcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgXCJkZWZhdWx0XCI6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub0Fja1wiLFxuICAgIFwiZGVmYXVsdFwiOiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljR2V0T2sgPSAzOTMyMjMxO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljR2V0T2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNHZXRPayA9IHtcbiAgaWQ6IDM5MzIyMzEsXG4gIG5hbWU6IFwiQmFzaWNHZXRPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdsb25nXCIsXG4gICAgbmFtZTogXCJkZWxpdmVyeVRhZ1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicmVkZWxpdmVyZWRcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIlxuICB9LCB7XG4gICAgdHlwZTogXCJsb25nXCIsXG4gICAgbmFtZTogXCJtZXNzYWdlQ291bnRcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljR2V0RW1wdHkgPSAzOTMyMjMyO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljR2V0RW1wdHkgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNHZXRFbXB0eSA9IHtcbiAgaWQ6IDM5MzIyMzIsXG4gIG5hbWU6IFwiQmFzaWNHZXRFbXB0eVwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjbHVzdGVySWRcIixcbiAgICBcImRlZmF1bHRcIjogXCJcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljQWNrID0gMzkzMjI0MDtcblxudmFyIG1ldGhvZEluZm9CYXNpY0FjayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY0FjayA9IHtcbiAgaWQ6IDM5MzIyNDAsXG4gIG5hbWU6IFwiQmFzaWNBY2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJsb25nbG9uZ1wiLFxuICAgIG5hbWU6IFwiZGVsaXZlcnlUYWdcIixcbiAgICBcImRlZmF1bHRcIjogMFxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm11bHRpcGxlXCIsXG4gICAgXCJkZWZhdWx0XCI6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNSZWplY3QgPSAzOTMyMjUwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljUmVqZWN0ID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljUmVqZWN0ID0ge1xuICBpZDogMzkzMjI1MCxcbiAgbmFtZTogXCJCYXNpY1JlamVjdFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdsb25nXCIsXG4gICAgbmFtZTogXCJkZWxpdmVyeVRhZ1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicmVxdWV1ZVwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMFxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljUmVjb3ZlckFzeW5jID0gMzkzMjI2MDtcblxudmFyIG1ldGhvZEluZm9CYXNpY1JlY292ZXJBc3luYyA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY1JlY292ZXJBc3luYyA9IHtcbiAgaWQ6IDM5MzIyNjAsXG4gIG5hbWU6IFwiQmFzaWNSZWNvdmVyQXN5bmNcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcInJlcXVldWVcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY1JlY292ZXIgPSAzOTMyMjcwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljUmVjb3ZlciA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY1JlY292ZXIgPSB7XG4gIGlkOiAzOTMyMjcwLFxuICBuYW1lOiBcIkJhc2ljUmVjb3ZlclwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicmVxdWV1ZVwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljUmVjb3Zlck9rID0gMzkzMjI3MTtcblxudmFyIG1ldGhvZEluZm9CYXNpY1JlY292ZXJPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY1JlY292ZXJPayA9IHtcbiAgaWQ6IDM5MzIyNzEsXG4gIG5hbWU6IFwiQmFzaWNSZWNvdmVyT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljTmFjayA9IDM5MzIyODA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNOYWNrID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljTmFjayA9IHtcbiAgaWQ6IDM5MzIyODAsXG4gIG5hbWU6IFwiQmFzaWNOYWNrXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwibG9uZ2xvbmdcIixcbiAgICBuYW1lOiBcImRlbGl2ZXJ5VGFnXCIsXG4gICAgXCJkZWZhdWx0XCI6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJtdWx0aXBsZVwiLFxuICAgIFwiZGVmYXVsdFwiOiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcInJlcXVldWVcIixcbiAgICBcImRlZmF1bHRcIjogITBcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UeFNlbGVjdCA9IDU4OTgyNTA7XG5cbnZhciBtZXRob2RJbmZvVHhTZWxlY3QgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvVHhTZWxlY3QgPSB7XG4gIGlkOiA1ODk4MjUwLFxuICBuYW1lOiBcIlR4U2VsZWN0XCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UeFNlbGVjdE9rID0gNTg5ODI1MTtcblxudmFyIG1ldGhvZEluZm9UeFNlbGVjdE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1R4U2VsZWN0T2sgPSB7XG4gIGlkOiA1ODk4MjUxLFxuICBuYW1lOiBcIlR4U2VsZWN0T2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLlR4Q29tbWl0ID0gNTg5ODI2MDtcblxudmFyIG1ldGhvZEluZm9UeENvbW1pdCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9UeENvbW1pdCA9IHtcbiAgaWQ6IDU4OTgyNjAsXG4gIG5hbWU6IFwiVHhDb21taXRcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLlR4Q29tbWl0T2sgPSA1ODk4MjYxO1xuXG52YXIgbWV0aG9kSW5mb1R4Q29tbWl0T2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvVHhDb21taXRPayA9IHtcbiAgaWQ6IDU4OTgyNjEsXG4gIG5hbWU6IFwiVHhDb21taXRPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuVHhSb2xsYmFjayA9IDU4OTgyNzA7XG5cbnZhciBtZXRob2RJbmZvVHhSb2xsYmFjayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9UeFJvbGxiYWNrID0ge1xuICBpZDogNTg5ODI3MCxcbiAgbmFtZTogXCJUeFJvbGxiYWNrXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UeFJvbGxiYWNrT2sgPSA1ODk4MjcxO1xuXG52YXIgbWV0aG9kSW5mb1R4Um9sbGJhY2tPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9UeFJvbGxiYWNrT2sgPSB7XG4gIGlkOiA1ODk4MjcxLFxuICBuYW1lOiBcIlR4Um9sbGJhY2tPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29uZmlybVNlbGVjdCA9IDU1NzA1NzA7XG5cbnZhciBtZXRob2RJbmZvQ29uZmlybVNlbGVjdCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25maXJtU2VsZWN0ID0ge1xuICBpZDogNTU3MDU3MCxcbiAgbmFtZTogXCJDb25maXJtU2VsZWN0XCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBcImRlZmF1bHRcIjogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25maXJtU2VsZWN0T2sgPSA1NTcwNTcxO1xuXG52YXIgbWV0aG9kSW5mb0NvbmZpcm1TZWxlY3RPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25maXJtU2VsZWN0T2sgPSB7XG4gIGlkOiA1NTcwNTcxLFxuICBuYW1lOiBcIkNvbmZpcm1TZWxlY3RPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNQcm9wZXJ0aWVzID0gNjA7XG5cbnZhciBwcm9wZXJ0aWVzSW5mb0Jhc2ljUHJvcGVydGllcyA9IG1vZHVsZS5leHBvcnRzLnByb3BlcnRpZXNJbmZvQmFzaWNQcm9wZXJ0aWVzID0ge1xuICBpZDogNjAsXG4gIG5hbWU6IFwiQmFzaWNQcm9wZXJ0aWVzXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNvbnRlbnRUeXBlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNvbnRlbnRFbmNvZGluZ1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJoZWFkZXJzXCJcbiAgfSwge1xuICAgIHR5cGU6IFwib2N0ZXRcIixcbiAgICBuYW1lOiBcImRlbGl2ZXJ5TW9kZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcIm9jdGV0XCIsXG4gICAgbmFtZTogXCJwcmlvcml0eVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjb3JyZWxhdGlvbklkXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJlcGx5VG9cIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiZXhwaXJhdGlvblwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJtZXNzYWdlSWRcIlxuICB9LCB7XG4gICAgdHlwZTogXCJ0aW1lc3RhbXBcIixcbiAgICBuYW1lOiBcInRpbWVzdGFtcFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJ0eXBlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInVzZXJJZFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJhcHBJZFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjbHVzdGVySWRcIlxuICB9IF1cbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/defs.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/error.js":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/lib/error.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var inherits = __webpack_require__(/*! util */ \"util\").inherits;\n\nfunction trimStack(stack, num) {\n  return stack && stack.split('\\n').slice(num).join('\\n');\n}\n\nfunction IllegalOperationError(msg, stack) {\n  var tmp = new Error();\n  this.message = msg;\n  this.stack = this.toString() + '\\n' + trimStack(tmp.stack, 2);\n  this.stackAtStateChange = stack;\n}\ninherits(IllegalOperationError, Error);\n\nIllegalOperationError.prototype.name = 'IllegalOperationError';\n\nfunction stackCapture(reason) {\n  var e = new Error();\n  return 'Stack capture: ' + reason + '\\n' +\n    trimStack(e.stack, 2);\n}\n\nmodule.exports.IllegalOperationError = IllegalOperationError;\nmodule.exports.stackCapture = stackCapture;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZXJyb3IuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZXJyb3IuanM/ZWU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG5cbmZ1bmN0aW9uIHRyaW1TdGFjayhzdGFjaywgbnVtKSB7XG4gIHJldHVybiBzdGFjayAmJiBzdGFjay5zcGxpdCgnXFxuJykuc2xpY2UobnVtKS5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gSWxsZWdhbE9wZXJhdGlvbkVycm9yKG1zZywgc3RhY2spIHtcbiAgdmFyIHRtcCA9IG5ldyBFcnJvcigpO1xuICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gIHRoaXMuc3RhY2sgPSB0aGlzLnRvU3RyaW5nKCkgKyAnXFxuJyArIHRyaW1TdGFjayh0bXAuc3RhY2ssIDIpO1xuICB0aGlzLnN0YWNrQXRTdGF0ZUNoYW5nZSA9IHN0YWNrO1xufVxuaW5oZXJpdHMoSWxsZWdhbE9wZXJhdGlvbkVycm9yLCBFcnJvcik7XG5cbklsbGVnYWxPcGVyYXRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdJbGxlZ2FsT3BlcmF0aW9uRXJyb3InO1xuXG5mdW5jdGlvbiBzdGFja0NhcHR1cmUocmVhc29uKSB7XG4gIHZhciBlID0gbmV3IEVycm9yKCk7XG4gIHJldHVybiAnU3RhY2sgY2FwdHVyZTogJyArIHJlYXNvbiArICdcXG4nICtcbiAgICB0cmltU3RhY2soZS5zdGFjaywgMik7XG59XG5cbm1vZHVsZS5leHBvcnRzLklsbGVnYWxPcGVyYXRpb25FcnJvciA9IElsbGVnYWxPcGVyYXRpb25FcnJvcjtcbm1vZHVsZS5leHBvcnRzLnN0YWNrQ2FwdHVyZSA9IHN0YWNrQ2FwdHVyZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/error.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/format.js":
/*!********************************************!*\
  !*** ./node_modules/amqplib/lib/format.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//\n//\n//\n\n// Stringifying various things\n\n\n\nvar defs = __webpack_require__(/*! ./defs */ \"./node_modules/amqplib/lib/defs.js\");\nvar format = __webpack_require__(/*! util */ \"util\").format;\nvar inherits = __webpack_require__(/*! util */ \"util\").inherits;\nvar HEARTBEAT = __webpack_require__(/*! ./frame */ \"./node_modules/amqplib/lib/frame.js\").HEARTBEAT;\n\nmodule.exports.closeMessage = function(close) {\n  var code = close.fields.replyCode;\n  return format('%d (%s) with message \"%s\"',\n                code, defs.constant_strs[code],\n                close.fields.replyText);\n}\n\nmodule.exports.methodName = function(id) {\n  return defs.info(id).name;\n};\n\nmodule.exports.inspect = function(frame, showFields) {\n  if (frame === HEARTBEAT) {\n    return '<Heartbeat>';\n  }\n  else if (!frame.id) {\n    return format('<Content channel:%d size:%d>',\n                  frame.channel, frame.size);\n  }\n  else {\n    var info = defs.info(frame.id);\n    return format('<%s channel:%d%s>', info.name, frame.channel,\n                  (showFields)\n                  ? ' ' + JSON.stringify(frame.fields, undefined, 2)\n                  : '');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZm9ybWF0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2Zvcm1hdC5qcz8zZTcwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vL1xuLy9cblxuLy8gU3RyaW5naWZ5aW5nIHZhcmlvdXMgdGhpbmdzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZnMgPSByZXF1aXJlKCcuL2RlZnMnKTtcbnZhciBmb3JtYXQgPSByZXF1aXJlKCd1dGlsJykuZm9ybWF0O1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIEhFQVJUQkVBVCA9IHJlcXVpcmUoJy4vZnJhbWUnKS5IRUFSVEJFQVQ7XG5cbm1vZHVsZS5leHBvcnRzLmNsb3NlTWVzc2FnZSA9IGZ1bmN0aW9uKGNsb3NlKSB7XG4gIHZhciBjb2RlID0gY2xvc2UuZmllbGRzLnJlcGx5Q29kZTtcbiAgcmV0dXJuIGZvcm1hdCgnJWQgKCVzKSB3aXRoIG1lc3NhZ2UgXCIlc1wiJyxcbiAgICAgICAgICAgICAgICBjb2RlLCBkZWZzLmNvbnN0YW50X3N0cnNbY29kZV0sXG4gICAgICAgICAgICAgICAgY2xvc2UuZmllbGRzLnJlcGx5VGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLm1ldGhvZE5hbWUgPSBmdW5jdGlvbihpZCkge1xuICByZXR1cm4gZGVmcy5pbmZvKGlkKS5uYW1lO1xufTtcblxubW9kdWxlLmV4cG9ydHMuaW5zcGVjdCA9IGZ1bmN0aW9uKGZyYW1lLCBzaG93RmllbGRzKSB7XG4gIGlmIChmcmFtZSA9PT0gSEVBUlRCRUFUKSB7XG4gICAgcmV0dXJuICc8SGVhcnRiZWF0Pic7XG4gIH1cbiAgZWxzZSBpZiAoIWZyYW1lLmlkKSB7XG4gICAgcmV0dXJuIGZvcm1hdCgnPENvbnRlbnQgY2hhbm5lbDolZCBzaXplOiVkPicsXG4gICAgICAgICAgICAgICAgICBmcmFtZS5jaGFubmVsLCBmcmFtZS5zaXplKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgaW5mbyA9IGRlZnMuaW5mbyhmcmFtZS5pZCk7XG4gICAgcmV0dXJuIGZvcm1hdCgnPCVzIGNoYW5uZWw6JWQlcz4nLCBpbmZvLm5hbWUsIGZyYW1lLmNoYW5uZWwsXG4gICAgICAgICAgICAgICAgICAoc2hvd0ZpZWxkcylcbiAgICAgICAgICAgICAgICAgID8gJyAnICsgSlNPTi5zdHJpbmdpZnkoZnJhbWUuZmllbGRzLCB1bmRlZmluZWQsIDIpXG4gICAgICAgICAgICAgICAgICA6ICcnKTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/format.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/frame.js":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/lib/frame.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// The river sweeps through\n// Silt and twigs, gravel and leaves\n// Driving the wheel on\n\n\n\nvar defs = __webpack_require__(/*! ./defs */ \"./node_modules/amqplib/lib/defs.js\");\nvar constants = defs.constants;\nvar decode = defs.decode;\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer\n\nvar Bits = __webpack_require__(/*! bitsyntax */ \"./node_modules/bitsyntax/index.js\");\n\nmodule.exports.PROTOCOL_HEADER = \"AMQP\" + String.fromCharCode(0, 0, 9, 1);\n\n/*\n  Frame format:\n\n  0      1         3             7                size+7 size+8\n  +------+---------+-------------+ +------------+ +-----------+\n  | type | channel | size        | | payload    | | frame-end |\n  +------+---------+-------------+ +------------+ +-----------+\n  octet   short     long            size octets    octet\n\n  In general I want to know those first three things straight away, so I\n  can discard frames early.\n\n*/\n\n// framing constants\nvar FRAME_METHOD = constants.FRAME_METHOD,\nFRAME_HEARTBEAT = constants.FRAME_HEARTBEAT,\nFRAME_HEADER = constants.FRAME_HEADER,\nFRAME_BODY = constants.FRAME_BODY,\nFRAME_END = constants.FRAME_END;\n\nvar bodyCons =\n  Bits.builder(FRAME_BODY,\n               'channel:16, size:32, payload:size/binary',\n               FRAME_END);\n\n// %%% TESTME possibly better to cons the first bit and write the\n// second directly, in the absence of IO lists\nmodule.exports.makeBodyFrame = function(channel, payload) {\n  return bodyCons({channel: channel, size: payload.length, payload: payload});\n};\n\nvar frameHeaderPattern = Bits.matcher('type:8', 'channel:16',\n                                      'size:32', 'rest/binary');\n\nfunction parseFrame(bin, max) {\n  var fh = frameHeaderPattern(bin);\n  if (fh) {\n    var size = fh.size, rest = fh.rest;\n    if (size > max) {\n      throw new Error('Frame size exceeds frame max');\n    }\n    else if (rest.length > size) {\n      if (rest[size] !== FRAME_END)\n        throw new Error('Invalid frame');\n\n      return {\n        type: fh.type,\n        channel: fh.channel,\n        size: size,\n        payload: rest.slice(0, size),\n        rest: rest.slice(size + 1)\n      };\n    }\n  }\n  return false;\n}\n\nmodule.exports.parseFrame = parseFrame;\n\nvar headerPattern = Bits.matcher('class:16',\n                                 '_weight:16',\n                                 'size:64',\n                                 'flagsAndfields/binary');\n\nvar methodPattern = Bits.matcher('id:32, args/binary');\n\nvar HEARTBEAT = {channel: 0};\n\nmodule.exports.decodeFrame = function(frame) {\n  var payload = frame.payload;\n  switch (frame.type) {\n  case FRAME_METHOD:\n    var idAndArgs = methodPattern(payload);\n    var id = idAndArgs.id;\n    var fields = decode(id, idAndArgs.args);\n    return {id: id, channel: frame.channel, fields: fields};\n  case FRAME_HEADER:\n    var parts = headerPattern(payload);\n    var id = parts['class'];\n    var fields = decode(id, parts.flagsAndfields);\n    return {id: id, channel: frame.channel,\n            size: parts.size, fields: fields};\n  case FRAME_BODY:\n    return {channel: frame.channel, content: frame.payload};\n  case FRAME_HEARTBEAT:\n    return HEARTBEAT;\n  default:\n    throw new Error('Unknown frame type ' + frame.type);\n  }\n}\n\n// encoded heartbeat\nmodule.exports.HEARTBEAT_BUF = Buffer.from([constants.FRAME_HEARTBEAT,\n                                           0, 0, 0, 0, // size = 0\n                                           0, 0, // channel = 0\n                                           constants.FRAME_END]);\n\nmodule.exports.HEARTBEAT = HEARTBEAT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZnJhbWUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZnJhbWUuanM/ODA2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGUgcml2ZXIgc3dlZXBzIHRocm91Z2hcbi8vIFNpbHQgYW5kIHR3aWdzLCBncmF2ZWwgYW5kIGxlYXZlc1xuLy8gRHJpdmluZyB0aGUgd2hlZWwgb25cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmcyA9IHJlcXVpcmUoJy4vZGVmcycpO1xudmFyIGNvbnN0YW50cyA9IGRlZnMuY29uc3RhbnRzO1xudmFyIGRlY29kZSA9IGRlZnMuZGVjb2RlO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBCaXRzID0gcmVxdWlyZSgnYml0c3ludGF4Jyk7XG5cbm1vZHVsZS5leHBvcnRzLlBST1RPQ09MX0hFQURFUiA9IFwiQU1RUFwiICsgU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAwLCA5LCAxKTtcblxuLypcbiAgRnJhbWUgZm9ybWF0OlxuXG4gIDAgICAgICAxICAgICAgICAgMyAgICAgICAgICAgICA3ICAgICAgICAgICAgICAgIHNpemUrNyBzaXplKzhcbiAgKy0tLS0tLSstLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSsgKy0tLS0tLS0tLS0tLSsgKy0tLS0tLS0tLS0tK1xuICB8IHR5cGUgfCBjaGFubmVsIHwgc2l6ZSAgICAgICAgfCB8IHBheWxvYWQgICAgfCB8IGZyYW1lLWVuZCB8XG4gICstLS0tLS0rLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rICstLS0tLS0tLS0tLS0rICstLS0tLS0tLS0tLStcbiAgb2N0ZXQgICBzaG9ydCAgICAgbG9uZyAgICAgICAgICAgIHNpemUgb2N0ZXRzICAgIG9jdGV0XG5cbiAgSW4gZ2VuZXJhbCBJIHdhbnQgdG8ga25vdyB0aG9zZSBmaXJzdCB0aHJlZSB0aGluZ3Mgc3RyYWlnaHQgYXdheSwgc28gSVxuICBjYW4gZGlzY2FyZCBmcmFtZXMgZWFybHkuXG5cbiovXG5cbi8vIGZyYW1pbmcgY29uc3RhbnRzXG52YXIgRlJBTUVfTUVUSE9EID0gY29uc3RhbnRzLkZSQU1FX01FVEhPRCxcbkZSQU1FX0hFQVJUQkVBVCA9IGNvbnN0YW50cy5GUkFNRV9IRUFSVEJFQVQsXG5GUkFNRV9IRUFERVIgPSBjb25zdGFudHMuRlJBTUVfSEVBREVSLFxuRlJBTUVfQk9EWSA9IGNvbnN0YW50cy5GUkFNRV9CT0RZLFxuRlJBTUVfRU5EID0gY29uc3RhbnRzLkZSQU1FX0VORDtcblxudmFyIGJvZHlDb25zID1cbiAgQml0cy5idWlsZGVyKEZSQU1FX0JPRFksXG4gICAgICAgICAgICAgICAnY2hhbm5lbDoxNiwgc2l6ZTozMiwgcGF5bG9hZDpzaXplL2JpbmFyeScsXG4gICAgICAgICAgICAgICBGUkFNRV9FTkQpO1xuXG4vLyAlJSUgVEVTVE1FIHBvc3NpYmx5IGJldHRlciB0byBjb25zIHRoZSBmaXJzdCBiaXQgYW5kIHdyaXRlIHRoZVxuLy8gc2Vjb25kIGRpcmVjdGx5LCBpbiB0aGUgYWJzZW5jZSBvZiBJTyBsaXN0c1xubW9kdWxlLmV4cG9ydHMubWFrZUJvZHlGcmFtZSA9IGZ1bmN0aW9uKGNoYW5uZWwsIHBheWxvYWQpIHtcbiAgcmV0dXJuIGJvZHlDb25zKHtjaGFubmVsOiBjaGFubmVsLCBzaXplOiBwYXlsb2FkLmxlbmd0aCwgcGF5bG9hZDogcGF5bG9hZH0pO1xufTtcblxudmFyIGZyYW1lSGVhZGVyUGF0dGVybiA9IEJpdHMubWF0Y2hlcigndHlwZTo4JywgJ2NoYW5uZWw6MTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTozMicsICdyZXN0L2JpbmFyeScpO1xuXG5mdW5jdGlvbiBwYXJzZUZyYW1lKGJpbiwgbWF4KSB7XG4gIHZhciBmaCA9IGZyYW1lSGVhZGVyUGF0dGVybihiaW4pO1xuICBpZiAoZmgpIHtcbiAgICB2YXIgc2l6ZSA9IGZoLnNpemUsIHJlc3QgPSBmaC5yZXN0O1xuICAgIGlmIChzaXplID4gbWF4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYW1lIHNpemUgZXhjZWVkcyBmcmFtZSBtYXgnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdC5sZW5ndGggPiBzaXplKSB7XG4gICAgICBpZiAocmVzdFtzaXplXSAhPT0gRlJBTUVfRU5EKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZnJhbWUnKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogZmgudHlwZSxcbiAgICAgICAgY2hhbm5lbDogZmguY2hhbm5lbCxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgcGF5bG9hZDogcmVzdC5zbGljZSgwLCBzaXplKSxcbiAgICAgICAgcmVzdDogcmVzdC5zbGljZShzaXplICsgMSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMucGFyc2VGcmFtZSA9IHBhcnNlRnJhbWU7XG5cbnZhciBoZWFkZXJQYXR0ZXJuID0gQml0cy5tYXRjaGVyKCdjbGFzczoxNicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnX3dlaWdodDoxNicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTo2NCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmxhZ3NBbmRmaWVsZHMvYmluYXJ5Jyk7XG5cbnZhciBtZXRob2RQYXR0ZXJuID0gQml0cy5tYXRjaGVyKCdpZDozMiwgYXJncy9iaW5hcnknKTtcblxudmFyIEhFQVJUQkVBVCA9IHtjaGFubmVsOiAwfTtcblxubW9kdWxlLmV4cG9ydHMuZGVjb2RlRnJhbWUgPSBmdW5jdGlvbihmcmFtZSkge1xuICB2YXIgcGF5bG9hZCA9IGZyYW1lLnBheWxvYWQ7XG4gIHN3aXRjaCAoZnJhbWUudHlwZSkge1xuICBjYXNlIEZSQU1FX01FVEhPRDpcbiAgICB2YXIgaWRBbmRBcmdzID0gbWV0aG9kUGF0dGVybihwYXlsb2FkKTtcbiAgICB2YXIgaWQgPSBpZEFuZEFyZ3MuaWQ7XG4gICAgdmFyIGZpZWxkcyA9IGRlY29kZShpZCwgaWRBbmRBcmdzLmFyZ3MpO1xuICAgIHJldHVybiB7aWQ6IGlkLCBjaGFubmVsOiBmcmFtZS5jaGFubmVsLCBmaWVsZHM6IGZpZWxkc307XG4gIGNhc2UgRlJBTUVfSEVBREVSOlxuICAgIHZhciBwYXJ0cyA9IGhlYWRlclBhdHRlcm4ocGF5bG9hZCk7XG4gICAgdmFyIGlkID0gcGFydHNbJ2NsYXNzJ107XG4gICAgdmFyIGZpZWxkcyA9IGRlY29kZShpZCwgcGFydHMuZmxhZ3NBbmRmaWVsZHMpO1xuICAgIHJldHVybiB7aWQ6IGlkLCBjaGFubmVsOiBmcmFtZS5jaGFubmVsLFxuICAgICAgICAgICAgc2l6ZTogcGFydHMuc2l6ZSwgZmllbGRzOiBmaWVsZHN9O1xuICBjYXNlIEZSQU1FX0JPRFk6XG4gICAgcmV0dXJuIHtjaGFubmVsOiBmcmFtZS5jaGFubmVsLCBjb250ZW50OiBmcmFtZS5wYXlsb2FkfTtcbiAgY2FzZSBGUkFNRV9IRUFSVEJFQVQ6XG4gICAgcmV0dXJuIEhFQVJUQkVBVDtcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZnJhbWUgdHlwZSAnICsgZnJhbWUudHlwZSk7XG4gIH1cbn1cblxuLy8gZW5jb2RlZCBoZWFydGJlYXRcbm1vZHVsZS5leHBvcnRzLkhFQVJUQkVBVF9CVUYgPSBCdWZmZXIuZnJvbShbY29uc3RhbnRzLkZSQU1FX0hFQVJUQkVBVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAvLyBzaXplID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIC8vIGNoYW5uZWwgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLkZSQU1FX0VORF0pO1xuXG5tb2R1bGUuZXhwb3J0cy5IRUFSVEJFQVQgPSBIRUFSVEJFQVQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/frame.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/heartbeat.js":
/*!***********************************************!*\
  !*** ./node_modules/amqplib/lib/heartbeat.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//\n//\n//\n\n// Heartbeats. In AMQP both clients and servers may expect a heartbeat\n// frame if there is no activity on the connection for a negotiated\n// period of time. If there's no activity for two such intervals, the\n// server or client is allowed to close the connection on the\n// presumption that the other party is dead.\n//\n// The client has two jobs here: the first is to send a heartbeat\n// frame if it's not sent any frames for a while, so that the server\n// doesn't think it's dead; the second is to check periodically that\n// it's seen activity from the server, and to advise if there doesn't\n// appear to have been any for over two intervals.\n//\n// Node.JS timers are a bit unreliable, in that they endeavour only to\n// fire at some indeterminate point *after* the given time (rather\n// gives the lie to 'realtime', dunnit). Because the scheduler is just\n// an event loop, it's quite easy to delay timers indefinitely by\n// reacting to some I/O with a lot of computation.\n//\n// To mitigate this I need a bit of creative interpretation:\n//\n//  - I'll schedule a server activity check for every `interval`, and\n//    check just how much time has passed. It will overshoot by at\n//    least a small margin; modulo missing timer deadlines, it'll\n//    notice between two and three intervals after activity actually\n//    stops (otherwise, at some point after two intervals).\n//\n//  - Every `interval / 2` I'll check that we've sent something since\n//    the last check, and if not, send a heartbeat frame. If we're\n//    really too busy to even run the check for two whole heartbeat\n//    intervals, there must be a lot of I (but not O, at least not on\n//    the connection), or computation, in which case perhaps it's best\n//    the server cuts us off anyway. Why `interval / 2`? Because the\n//    edge case is that the client sent a frame just after a\n//    heartbeat, which would mean I only send one after almost two\n//    intervals. (NB a heartbeat counts as a send, so it'll be checked\n//    at least twice before sending another)\n//\n// This design is based largely on RabbitMQ's heartbeating:\n// https://github.com/rabbitmq/rabbitmq-common/blob/master/src/rabbit_heartbeat.erl\n\n// %% Yes, I could apply the same 'actually passage of time' thing to\n// %% send as well as to recv.\n\n\n\nvar inherits = __webpack_require__(/*! util */ \"util\").inherits;\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\n\n// Exported so that we can mess with it in tests\nmodule.exports.UNITS_TO_MS = 1000;\n\nfunction Heart(interval, checkSend, checkRecv) {\n  EventEmitter.call(this);\n  this.interval = interval;\n\n  var intervalMs = interval * module.exports.UNITS_TO_MS;\n  // Function#bind is my new best friend\n  var beat = this.emit.bind(this, 'beat');\n  var timeout = this.emit.bind(this, 'timeout');\n\n  this.sendTimer = setInterval(\n    this.runHeartbeat.bind(this, checkSend, beat), intervalMs / 2);\n\n  // A timeout occurs if I see nothing for *two consecutive* intervals\n  var recvMissed = 0;\n  function missedTwo() {\n    if (!checkRecv()) return (++recvMissed < 2);\n    else { recvMissed = 0; return true; }\n  }\n  this.recvTimer = setInterval(\n    this.runHeartbeat.bind(this, missedTwo, timeout), intervalMs);\n}\ninherits(Heart, EventEmitter);\n\nmodule.exports.Heart = Heart;\n\nHeart.prototype.clear = function() {\n  clearInterval(this.sendTimer);\n  clearInterval(this.recvTimer);\n};\n\nHeart.prototype.runHeartbeat = function(check, fail) {\n  // Have we seen activity?\n  if (!check()) fail();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvaGVhcnRiZWF0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2hlYXJ0YmVhdC5qcz8wOWUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vL1xuLy9cblxuLy8gSGVhcnRiZWF0cy4gSW4gQU1RUCBib3RoIGNsaWVudHMgYW5kIHNlcnZlcnMgbWF5IGV4cGVjdCBhIGhlYXJ0YmVhdFxuLy8gZnJhbWUgaWYgdGhlcmUgaXMgbm8gYWN0aXZpdHkgb24gdGhlIGNvbm5lY3Rpb24gZm9yIGEgbmVnb3RpYXRlZFxuLy8gcGVyaW9kIG9mIHRpbWUuIElmIHRoZXJlJ3Mgbm8gYWN0aXZpdHkgZm9yIHR3byBzdWNoIGludGVydmFscywgdGhlXG4vLyBzZXJ2ZXIgb3IgY2xpZW50IGlzIGFsbG93ZWQgdG8gY2xvc2UgdGhlIGNvbm5lY3Rpb24gb24gdGhlXG4vLyBwcmVzdW1wdGlvbiB0aGF0IHRoZSBvdGhlciBwYXJ0eSBpcyBkZWFkLlxuLy9cbi8vIFRoZSBjbGllbnQgaGFzIHR3byBqb2JzIGhlcmU6IHRoZSBmaXJzdCBpcyB0byBzZW5kIGEgaGVhcnRiZWF0XG4vLyBmcmFtZSBpZiBpdCdzIG5vdCBzZW50IGFueSBmcmFtZXMgZm9yIGEgd2hpbGUsIHNvIHRoYXQgdGhlIHNlcnZlclxuLy8gZG9lc24ndCB0aGluayBpdCdzIGRlYWQ7IHRoZSBzZWNvbmQgaXMgdG8gY2hlY2sgcGVyaW9kaWNhbGx5IHRoYXRcbi8vIGl0J3Mgc2VlbiBhY3Rpdml0eSBmcm9tIHRoZSBzZXJ2ZXIsIGFuZCB0byBhZHZpc2UgaWYgdGhlcmUgZG9lc24ndFxuLy8gYXBwZWFyIHRvIGhhdmUgYmVlbiBhbnkgZm9yIG92ZXIgdHdvIGludGVydmFscy5cbi8vXG4vLyBOb2RlLkpTIHRpbWVycyBhcmUgYSBiaXQgdW5yZWxpYWJsZSwgaW4gdGhhdCB0aGV5IGVuZGVhdm91ciBvbmx5IHRvXG4vLyBmaXJlIGF0IHNvbWUgaW5kZXRlcm1pbmF0ZSBwb2ludCAqYWZ0ZXIqIHRoZSBnaXZlbiB0aW1lIChyYXRoZXJcbi8vIGdpdmVzIHRoZSBsaWUgdG8gJ3JlYWx0aW1lJywgZHVubml0KS4gQmVjYXVzZSB0aGUgc2NoZWR1bGVyIGlzIGp1c3Rcbi8vIGFuIGV2ZW50IGxvb3AsIGl0J3MgcXVpdGUgZWFzeSB0byBkZWxheSB0aW1lcnMgaW5kZWZpbml0ZWx5IGJ5XG4vLyByZWFjdGluZyB0byBzb21lIEkvTyB3aXRoIGEgbG90IG9mIGNvbXB1dGF0aW9uLlxuLy9cbi8vIFRvIG1pdGlnYXRlIHRoaXMgSSBuZWVkIGEgYml0IG9mIGNyZWF0aXZlIGludGVycHJldGF0aW9uOlxuLy9cbi8vICAtIEknbGwgc2NoZWR1bGUgYSBzZXJ2ZXIgYWN0aXZpdHkgY2hlY2sgZm9yIGV2ZXJ5IGBpbnRlcnZhbGAsIGFuZFxuLy8gICAgY2hlY2sganVzdCBob3cgbXVjaCB0aW1lIGhhcyBwYXNzZWQuIEl0IHdpbGwgb3ZlcnNob290IGJ5IGF0XG4vLyAgICBsZWFzdCBhIHNtYWxsIG1hcmdpbjsgbW9kdWxvIG1pc3NpbmcgdGltZXIgZGVhZGxpbmVzLCBpdCdsbFxuLy8gICAgbm90aWNlIGJldHdlZW4gdHdvIGFuZCB0aHJlZSBpbnRlcnZhbHMgYWZ0ZXIgYWN0aXZpdHkgYWN0dWFsbHlcbi8vICAgIHN0b3BzIChvdGhlcndpc2UsIGF0IHNvbWUgcG9pbnQgYWZ0ZXIgdHdvIGludGVydmFscykuXG4vL1xuLy8gIC0gRXZlcnkgYGludGVydmFsIC8gMmAgSSdsbCBjaGVjayB0aGF0IHdlJ3ZlIHNlbnQgc29tZXRoaW5nIHNpbmNlXG4vLyAgICB0aGUgbGFzdCBjaGVjaywgYW5kIGlmIG5vdCwgc2VuZCBhIGhlYXJ0YmVhdCBmcmFtZS4gSWYgd2UncmVcbi8vICAgIHJlYWxseSB0b28gYnVzeSB0byBldmVuIHJ1biB0aGUgY2hlY2sgZm9yIHR3byB3aG9sZSBoZWFydGJlYXRcbi8vICAgIGludGVydmFscywgdGhlcmUgbXVzdCBiZSBhIGxvdCBvZiBJIChidXQgbm90IE8sIGF0IGxlYXN0IG5vdCBvblxuLy8gICAgdGhlIGNvbm5lY3Rpb24pLCBvciBjb21wdXRhdGlvbiwgaW4gd2hpY2ggY2FzZSBwZXJoYXBzIGl0J3MgYmVzdFxuLy8gICAgdGhlIHNlcnZlciBjdXRzIHVzIG9mZiBhbnl3YXkuIFdoeSBgaW50ZXJ2YWwgLyAyYD8gQmVjYXVzZSB0aGVcbi8vICAgIGVkZ2UgY2FzZSBpcyB0aGF0IHRoZSBjbGllbnQgc2VudCBhIGZyYW1lIGp1c3QgYWZ0ZXIgYVxuLy8gICAgaGVhcnRiZWF0LCB3aGljaCB3b3VsZCBtZWFuIEkgb25seSBzZW5kIG9uZSBhZnRlciBhbG1vc3QgdHdvXG4vLyAgICBpbnRlcnZhbHMuIChOQiBhIGhlYXJ0YmVhdCBjb3VudHMgYXMgYSBzZW5kLCBzbyBpdCdsbCBiZSBjaGVja2VkXG4vLyAgICBhdCBsZWFzdCB0d2ljZSBiZWZvcmUgc2VuZGluZyBhbm90aGVyKVxuLy9cbi8vIFRoaXMgZGVzaWduIGlzIGJhc2VkIGxhcmdlbHkgb24gUmFiYml0TVEncyBoZWFydGJlYXRpbmc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcmFiYml0bXEvcmFiYml0bXEtY29tbW9uL2Jsb2IvbWFzdGVyL3NyYy9yYWJiaXRfaGVhcnRiZWF0LmVybFxuXG4vLyAlJSBZZXMsIEkgY291bGQgYXBwbHkgdGhlIHNhbWUgJ2FjdHVhbGx5IHBhc3NhZ2Ugb2YgdGltZScgdGhpbmcgdG9cbi8vICUlIHNlbmQgYXMgd2VsbCBhcyB0byByZWN2LlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8vIEV4cG9ydGVkIHNvIHRoYXQgd2UgY2FuIG1lc3Mgd2l0aCBpdCBpbiB0ZXN0c1xubW9kdWxlLmV4cG9ydHMuVU5JVFNfVE9fTVMgPSAxMDAwO1xuXG5mdW5jdGlvbiBIZWFydChpbnRlcnZhbCwgY2hlY2tTZW5kLCBjaGVja1JlY3YpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcblxuICB2YXIgaW50ZXJ2YWxNcyA9IGludGVydmFsICogbW9kdWxlLmV4cG9ydHMuVU5JVFNfVE9fTVM7XG4gIC8vIEZ1bmN0aW9uI2JpbmQgaXMgbXkgbmV3IGJlc3QgZnJpZW5kXG4gIHZhciBiZWF0ID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2JlYXQnKTtcbiAgdmFyIHRpbWVvdXQgPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAndGltZW91dCcpO1xuXG4gIHRoaXMuc2VuZFRpbWVyID0gc2V0SW50ZXJ2YWwoXG4gICAgdGhpcy5ydW5IZWFydGJlYXQuYmluZCh0aGlzLCBjaGVja1NlbmQsIGJlYXQpLCBpbnRlcnZhbE1zIC8gMik7XG5cbiAgLy8gQSB0aW1lb3V0IG9jY3VycyBpZiBJIHNlZSBub3RoaW5nIGZvciAqdHdvIGNvbnNlY3V0aXZlKiBpbnRlcnZhbHNcbiAgdmFyIHJlY3ZNaXNzZWQgPSAwO1xuICBmdW5jdGlvbiBtaXNzZWRUd28oKSB7XG4gICAgaWYgKCFjaGVja1JlY3YoKSkgcmV0dXJuICgrK3JlY3ZNaXNzZWQgPCAyKTtcbiAgICBlbHNlIHsgcmVjdk1pc3NlZCA9IDA7IHJldHVybiB0cnVlOyB9XG4gIH1cbiAgdGhpcy5yZWN2VGltZXIgPSBzZXRJbnRlcnZhbChcbiAgICB0aGlzLnJ1bkhlYXJ0YmVhdC5iaW5kKHRoaXMsIG1pc3NlZFR3bywgdGltZW91dCksIGludGVydmFsTXMpO1xufVxuaW5oZXJpdHMoSGVhcnQsIEV2ZW50RW1pdHRlcik7XG5cbm1vZHVsZS5leHBvcnRzLkhlYXJ0ID0gSGVhcnQ7XG5cbkhlYXJ0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICBjbGVhckludGVydmFsKHRoaXMuc2VuZFRpbWVyKTtcbiAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlY3ZUaW1lcik7XG59O1xuXG5IZWFydC5wcm90b3R5cGUucnVuSGVhcnRiZWF0ID0gZnVuY3Rpb24oY2hlY2ssIGZhaWwpIHtcbiAgLy8gSGF2ZSB3ZSBzZWVuIGFjdGl2aXR5P1xuICBpZiAoIWNoZWNrKCkpIGZhaWwoKTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/heartbeat.js\n");

/***/ }),

/***/ "./node_modules/amqplib/lib/mux.js":
/*!*****************************************!*\
  !*** ./node_modules/amqplib/lib/mux.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//\n//\n//\n\n\n\n// A Mux is an object into which other readable streams may be piped;\n// it then writes 'packets' from the upstreams to the given\n// downstream.\n\nvar inherits = __webpack_require__(/*! util */ \"util\").inherits;\nvar assert = __webpack_require__(/*! assert */ \"assert\");\n\nvar schedule = (typeof setImmediate === 'function') ?\n  setImmediate : process.nextTick;\n\nfunction Mux(downstream) {\n  this.newStreams = [];\n  this.oldStreams = [];\n  this.blocked = false;\n  this.scheduledRead = false;\n\n  this.out = downstream;\n  var self = this;\n  downstream.on('drain', function() {\n    self.blocked = false;\n    self._readIncoming();\n  });\n}\n\n// There are 2 states we can be in:\n\n// - waiting for outbound capacity, which will be signalled by a\n// - 'drain' event on the downstream; or,\n\n// - no packets to send, waiting for an inbound buffer to have\n//   packets, which will be signalled by a 'readable' event\n\n// If we write all packets available whenever there is outbound\n// capacity, we will either run out of outbound capacity (`#write`\n// returns false), or run out of packets (all calls to an\n// `inbound.read()` have returned null).\n\nMux.prototype._readIncoming = function() {\n\n  // We may be sent here speculatively, if an incoming stream has\n  // become readable\n  if (this.blocked) return;\n\n  var self = this;\n  var accepting = true;\n  var out = this.out;\n\n  // Try to read a chunk from each stream in turn, until all streams\n  // are empty, or we exhaust our ability to accept chunks.\n  function roundrobin(streams) {\n    var s;\n    // if there's just one incoming stream we don't have to\n    // go through all the dequeue/enqueueing\n    if (streams.length === 1) {\n      s = streams.shift();\n      while (accepting) {\n        var chunk = s.read();\n        if (chunk !== null) {\n          accepting = out.write(chunk);\n        }\n        else break;\n      }\n      if (!accepting) streams.push(s);\n    }\n    else {\n      while (accepting && (s = streams.shift())) {\n        var chunk = s.read();\n        if (chunk !== null) {\n          accepting = out.write(chunk);\n          streams.push(s);\n        }\n      }\n    }\n  }\n\n  roundrobin(this.newStreams);\n\n  // Either we exhausted the new queues, or we ran out of capacity. If\n  // we ran out of capacity, all the remaining new streams (i.e.,\n  // those with packets left) become old streams. This effectively\n  // prioritises streams that keep their buffers close to empty over\n  // those that are constantly near full.\n\n  if (accepting) { // all new queues are exhausted, write as many as\n                   // we can from the old streams\n    assert.equal(0, this.newStreams.length);\n    roundrobin(this.oldStreams);\n  }\n  else { // ran out of room\n    assert(this.newStreams.length > 0, \"Expect some new streams to remain\");\n    this.oldStreams = this.oldStreams.concat(this.newStreams);\n    this.newStreams = [];\n  }\n  // We may have exhausted all the old queues, or run out of room;\n  // either way, all we need to do is record whether we have capacity\n  // or not, so any speculative reads will know\n  this.blocked = !accepting;\n};\n\nMux.prototype._scheduleRead = function() {\n  var self = this;\n  \n  if (!self.scheduledRead) {\n    schedule(function() {\n      self.scheduledRead = false;\n      self._readIncoming();\n    });\n    self.scheduledRead = true;\n  }\n};\n\nMux.prototype.pipeFrom = function(readable) {\n  var self = this;\n\n  function enqueue() {\n    self.newStreams.push(readable);\n    self._scheduleRead();\n  }\n\n  function cleanup() {\n    readable.removeListener('readable', enqueue);\n    readable.removeListener('error', cleanup);\n    readable.removeListener('end', cleanup);\n    readable.removeListener('unpipeFrom', cleanupIfMe);\n  }\n  function cleanupIfMe(dest) {\n    if (dest === self) cleanup();\n  }\n\n  readable.on('unpipeFrom', cleanupIfMe);\n  readable.on('end', cleanup);\n  readable.on('error', cleanup);\n  readable.on('readable', enqueue);\n};\n\nMux.prototype.unpipeFrom = function(readable) {\n  readable.emit('unpipeFrom', this);\n};\n\nmodule.exports.Mux = Mux;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvbXV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL211eC5qcz80MTA4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vL1xuLy9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBBIE11eCBpcyBhbiBvYmplY3QgaW50byB3aGljaCBvdGhlciByZWFkYWJsZSBzdHJlYW1zIG1heSBiZSBwaXBlZDtcbi8vIGl0IHRoZW4gd3JpdGVzICdwYWNrZXRzJyBmcm9tIHRoZSB1cHN0cmVhbXMgdG8gdGhlIGdpdmVuXG4vLyBkb3duc3RyZWFtLlxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbnZhciBzY2hlZHVsZSA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSA/XG4gIHNldEltbWVkaWF0ZSA6IHByb2Nlc3MubmV4dFRpY2s7XG5cbmZ1bmN0aW9uIE11eChkb3duc3RyZWFtKSB7XG4gIHRoaXMubmV3U3RyZWFtcyA9IFtdO1xuICB0aGlzLm9sZFN0cmVhbXMgPSBbXTtcbiAgdGhpcy5ibG9ja2VkID0gZmFsc2U7XG4gIHRoaXMuc2NoZWR1bGVkUmVhZCA9IGZhbHNlO1xuXG4gIHRoaXMub3V0ID0gZG93bnN0cmVhbTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBkb3duc3RyZWFtLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuYmxvY2tlZCA9IGZhbHNlO1xuICAgIHNlbGYuX3JlYWRJbmNvbWluZygpO1xuICB9KTtcbn1cblxuLy8gVGhlcmUgYXJlIDIgc3RhdGVzIHdlIGNhbiBiZSBpbjpcblxuLy8gLSB3YWl0aW5nIGZvciBvdXRib3VuZCBjYXBhY2l0eSwgd2hpY2ggd2lsbCBiZSBzaWduYWxsZWQgYnkgYVxuLy8gLSAnZHJhaW4nIGV2ZW50IG9uIHRoZSBkb3duc3RyZWFtOyBvcixcblxuLy8gLSBubyBwYWNrZXRzIHRvIHNlbmQsIHdhaXRpbmcgZm9yIGFuIGluYm91bmQgYnVmZmVyIHRvIGhhdmVcbi8vICAgcGFja2V0cywgd2hpY2ggd2lsbCBiZSBzaWduYWxsZWQgYnkgYSAncmVhZGFibGUnIGV2ZW50XG5cbi8vIElmIHdlIHdyaXRlIGFsbCBwYWNrZXRzIGF2YWlsYWJsZSB3aGVuZXZlciB0aGVyZSBpcyBvdXRib3VuZFxuLy8gY2FwYWNpdHksIHdlIHdpbGwgZWl0aGVyIHJ1biBvdXQgb2Ygb3V0Ym91bmQgY2FwYWNpdHkgKGAjd3JpdGVgXG4vLyByZXR1cm5zIGZhbHNlKSwgb3IgcnVuIG91dCBvZiBwYWNrZXRzIChhbGwgY2FsbHMgdG8gYW5cbi8vIGBpbmJvdW5kLnJlYWQoKWAgaGF2ZSByZXR1cm5lZCBudWxsKS5cblxuTXV4LnByb3RvdHlwZS5fcmVhZEluY29taW5nID0gZnVuY3Rpb24oKSB7XG5cbiAgLy8gV2UgbWF5IGJlIHNlbnQgaGVyZSBzcGVjdWxhdGl2ZWx5LCBpZiBhbiBpbmNvbWluZyBzdHJlYW0gaGFzXG4gIC8vIGJlY29tZSByZWFkYWJsZVxuICBpZiAodGhpcy5ibG9ja2VkKSByZXR1cm47XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYWNjZXB0aW5nID0gdHJ1ZTtcbiAgdmFyIG91dCA9IHRoaXMub3V0O1xuXG4gIC8vIFRyeSB0byByZWFkIGEgY2h1bmsgZnJvbSBlYWNoIHN0cmVhbSBpbiB0dXJuLCB1bnRpbCBhbGwgc3RyZWFtc1xuICAvLyBhcmUgZW1wdHksIG9yIHdlIGV4aGF1c3Qgb3VyIGFiaWxpdHkgdG8gYWNjZXB0IGNodW5rcy5cbiAgZnVuY3Rpb24gcm91bmRyb2JpbihzdHJlYW1zKSB7XG4gICAgdmFyIHM7XG4gICAgLy8gaWYgdGhlcmUncyBqdXN0IG9uZSBpbmNvbWluZyBzdHJlYW0gd2UgZG9uJ3QgaGF2ZSB0b1xuICAgIC8vIGdvIHRocm91Z2ggYWxsIHRoZSBkZXF1ZXVlL2VucXVldWVpbmdcbiAgICBpZiAoc3RyZWFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHMgPSBzdHJlYW1zLnNoaWZ0KCk7XG4gICAgICB3aGlsZSAoYWNjZXB0aW5nKSB7XG4gICAgICAgIHZhciBjaHVuayA9IHMucmVhZCgpO1xuICAgICAgICBpZiAoY2h1bmsgIT09IG51bGwpIHtcbiAgICAgICAgICBhY2NlcHRpbmcgPSBvdXQud3JpdGUoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIWFjY2VwdGluZykgc3RyZWFtcy5wdXNoKHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlIChhY2NlcHRpbmcgJiYgKHMgPSBzdHJlYW1zLnNoaWZ0KCkpKSB7XG4gICAgICAgIHZhciBjaHVuayA9IHMucmVhZCgpO1xuICAgICAgICBpZiAoY2h1bmsgIT09IG51bGwpIHtcbiAgICAgICAgICBhY2NlcHRpbmcgPSBvdXQud3JpdGUoY2h1bmspO1xuICAgICAgICAgIHN0cmVhbXMucHVzaChzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJvdW5kcm9iaW4odGhpcy5uZXdTdHJlYW1zKTtcblxuICAvLyBFaXRoZXIgd2UgZXhoYXVzdGVkIHRoZSBuZXcgcXVldWVzLCBvciB3ZSByYW4gb3V0IG9mIGNhcGFjaXR5LiBJZlxuICAvLyB3ZSByYW4gb3V0IG9mIGNhcGFjaXR5LCBhbGwgdGhlIHJlbWFpbmluZyBuZXcgc3RyZWFtcyAoaS5lLixcbiAgLy8gdGhvc2Ugd2l0aCBwYWNrZXRzIGxlZnQpIGJlY29tZSBvbGQgc3RyZWFtcy4gVGhpcyBlZmZlY3RpdmVseVxuICAvLyBwcmlvcml0aXNlcyBzdHJlYW1zIHRoYXQga2VlcCB0aGVpciBidWZmZXJzIGNsb3NlIHRvIGVtcHR5IG92ZXJcbiAgLy8gdGhvc2UgdGhhdCBhcmUgY29uc3RhbnRseSBuZWFyIGZ1bGwuXG5cbiAgaWYgKGFjY2VwdGluZykgeyAvLyBhbGwgbmV3IHF1ZXVlcyBhcmUgZXhoYXVzdGVkLCB3cml0ZSBhcyBtYW55IGFzXG4gICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGZyb20gdGhlIG9sZCBzdHJlYW1zXG4gICAgYXNzZXJ0LmVxdWFsKDAsIHRoaXMubmV3U3RyZWFtcy5sZW5ndGgpO1xuICAgIHJvdW5kcm9iaW4odGhpcy5vbGRTdHJlYW1zKTtcbiAgfVxuICBlbHNlIHsgLy8gcmFuIG91dCBvZiByb29tXG4gICAgYXNzZXJ0KHRoaXMubmV3U3RyZWFtcy5sZW5ndGggPiAwLCBcIkV4cGVjdCBzb21lIG5ldyBzdHJlYW1zIHRvIHJlbWFpblwiKTtcbiAgICB0aGlzLm9sZFN0cmVhbXMgPSB0aGlzLm9sZFN0cmVhbXMuY29uY2F0KHRoaXMubmV3U3RyZWFtcyk7XG4gICAgdGhpcy5uZXdTdHJlYW1zID0gW107XG4gIH1cbiAgLy8gV2UgbWF5IGhhdmUgZXhoYXVzdGVkIGFsbCB0aGUgb2xkIHF1ZXVlcywgb3IgcnVuIG91dCBvZiByb29tO1xuICAvLyBlaXRoZXIgd2F5LCBhbGwgd2UgbmVlZCB0byBkbyBpcyByZWNvcmQgd2hldGhlciB3ZSBoYXZlIGNhcGFjaXR5XG4gIC8vIG9yIG5vdCwgc28gYW55IHNwZWN1bGF0aXZlIHJlYWRzIHdpbGwga25vd1xuICB0aGlzLmJsb2NrZWQgPSAhYWNjZXB0aW5nO1xufTtcblxuTXV4LnByb3RvdHlwZS5fc2NoZWR1bGVSZWFkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgXG4gIGlmICghc2VsZi5zY2hlZHVsZWRSZWFkKSB7XG4gICAgc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnNjaGVkdWxlZFJlYWQgPSBmYWxzZTtcbiAgICAgIHNlbGYuX3JlYWRJbmNvbWluZygpO1xuICAgIH0pO1xuICAgIHNlbGYuc2NoZWR1bGVkUmVhZCA9IHRydWU7XG4gIH1cbn07XG5cbk11eC5wcm90b3R5cGUucGlwZUZyb20gPSBmdW5jdGlvbihyZWFkYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gZW5xdWV1ZSgpIHtcbiAgICBzZWxmLm5ld1N0cmVhbXMucHVzaChyZWFkYWJsZSk7XG4gICAgc2VsZi5fc2NoZWR1bGVSZWFkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHJlYWRhYmxlLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIGVucXVldWUpO1xuICAgIHJlYWRhYmxlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGNsZWFudXApO1xuICAgIHJlYWRhYmxlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICByZWFkYWJsZS5yZW1vdmVMaXN0ZW5lcigndW5waXBlRnJvbScsIGNsZWFudXBJZk1lKTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhbnVwSWZNZShkZXN0KSB7XG4gICAgaWYgKGRlc3QgPT09IHNlbGYpIGNsZWFudXAoKTtcbiAgfVxuXG4gIHJlYWRhYmxlLm9uKCd1bnBpcGVGcm9tJywgY2xlYW51cElmTWUpO1xuICByZWFkYWJsZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHJlYWRhYmxlLm9uKCdlcnJvcicsIGNsZWFudXApO1xuICByZWFkYWJsZS5vbigncmVhZGFibGUnLCBlbnF1ZXVlKTtcbn07XG5cbk11eC5wcm90b3R5cGUudW5waXBlRnJvbSA9IGZ1bmN0aW9uKHJlYWRhYmxlKSB7XG4gIHJlYWRhYmxlLmVtaXQoJ3VucGlwZUZyb20nLCB0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLk11eCA9IE11eDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/amqplib/lib/mux.js\n");

/***/ }),

/***/ "./node_modules/amqplib/package.json":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/package.json ***!
  \*******************************************/
/*! exports provided: _args, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, bugs, dependencies, description, devDependencies, engines, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = {\"_args\":[[\"amqplib@0.5.2\",\"/home/saintiago/repositories/ecommerce\"]],\"_from\":\"amqplib@0.5.2\",\"_id\":\"amqplib@0.5.2\",\"_inBundle\":false,\"_integrity\":\"sha512-l9mCs6LbydtHqRniRwYkKdqxVa6XMz3Vw1fh+2gJaaVgTM6Jk3o8RccAKWKtlhT1US5sWrFh+KKxsVUALURSIA==\",\"_location\":\"/amqplib\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"version\",\"registry\":true,\"raw\":\"amqplib@0.5.2\",\"name\":\"amqplib\",\"escapedName\":\"amqplib\",\"rawSpec\":\"0.5.2\",\"saveSpec\":null,\"fetchSpec\":\"0.5.2\"},\"_requiredBy\":[\"/\"],\"_resolved\":\"https://registry.npmjs.org/amqplib/-/amqplib-0.5.2.tgz\",\"_spec\":\"0.5.2\",\"_where\":\"/home/saintiago/repositories/ecommerce\",\"author\":{\"name\":\"Michael Bridgen\",\"email\":\"mikeb@squaremobius.net\"},\"bugs\":{\"url\":\"https://github.com/squaremo/amqp.node/issues\"},\"dependencies\":{\"bitsyntax\":\"~0.0.4\",\"bluebird\":\"^3.4.6\",\"buffer-more-ints\":\"0.0.2\",\"readable-stream\":\"1.x >=1.1.9\",\"safe-buffer\":\"^5.0.1\"},\"description\":\"An AMQP 0-9-1 (e.g., RabbitMQ) library and client.\",\"devDependencies\":{\"claire\":\"0.4.1\",\"istanbul\":\"0.1.x\",\"mocha\":\"~1\",\"uglify-js\":\"2.4.x\"},\"engines\":{\"node\":\">=0.8 <=9\"},\"homepage\":\"http://squaremo.github.io/amqp.node/\",\"keywords\":[\"AMQP\",\"AMQP 0-9-1\",\"RabbitMQ\"],\"license\":\"MIT\",\"main\":\"./channel_api.js\",\"name\":\"amqplib\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/squaremo/amqp.node.git\"},\"scripts\":{\"prepublish\":\"make\",\"test\":\"make test\"},\"version\":\"0.5.2\"};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9wYWNrYWdlLmpzb24uanMiLCJzb3VyY2VzIjpbXSwibWFwcGluZ3MiOiIiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/amqplib/package.json\n");

/***/ }),

/***/ "./node_modules/bitsyntax/index.js":
/*!*****************************************!*\
  !*** ./node_modules/bitsyntax/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports.parse = __webpack_require__(/*! ./lib/parse */ \"./node_modules/bitsyntax/lib/parse.js\").parse;\nmodule.exports.match = __webpack_require__(/*! ./lib/interp */ \"./node_modules/bitsyntax/lib/interp.js\").match;\nmodule.exports.build = __webpack_require__(/*! ./lib/constructor */ \"./node_modules/bitsyntax/lib/constructor.js\").build;\nmodule.exports.write = __webpack_require__(/*! ./lib/constructor */ \"./node_modules/bitsyntax/lib/constructor.js\").write;\n\nmodule.exports.matcher = module.exports.compile =\n  __webpack_require__(/*! ./lib/compile */ \"./node_modules/bitsyntax/lib/compile.js\").compile;\nmodule.exports.builder = __webpack_require__(/*! ./lib/compile */ \"./node_modules/bitsyntax/lib/compile.js\").compile_builder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0c3ludGF4L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JpdHN5bnRheC9pbmRleC5qcz9lMjgwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2xpYi9wYXJzZScpLnBhcnNlO1xubW9kdWxlLmV4cG9ydHMubWF0Y2ggPSByZXF1aXJlKCcuL2xpYi9pbnRlcnAnKS5tYXRjaDtcbm1vZHVsZS5leHBvcnRzLmJ1aWxkID0gcmVxdWlyZSgnLi9saWIvY29uc3RydWN0b3InKS5idWlsZDtcbm1vZHVsZS5leHBvcnRzLndyaXRlID0gcmVxdWlyZSgnLi9saWIvY29uc3RydWN0b3InKS53cml0ZTtcblxubW9kdWxlLmV4cG9ydHMubWF0Y2hlciA9IG1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPVxuICByZXF1aXJlKCcuL2xpYi9jb21waWxlJykuY29tcGlsZTtcbm1vZHVsZS5leHBvcnRzLmJ1aWxkZXIgPSByZXF1aXJlKCcuL2xpYi9jb21waWxlJykuY29tcGlsZV9idWlsZGVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bitsyntax/index.js\n");

/***/ }),

/***/ "./node_modules/bitsyntax/lib/compile.js":
/*!***********************************************!*\
  !*** ./node_modules/bitsyntax/lib/compile.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Compile patterns to recognisers and constructors\n\n\n\n__webpack_require__(/*! buffer-more-ints */ \"./node_modules/buffer-more-ints/buffer-more-ints.js\");\nvar $ = __webpack_require__(/*! util */ \"util\").format;\n\nvar parse = __webpack_require__(/*! ./parse */ \"./node_modules/bitsyntax/lib/parse.js\").parse;\nvar interp = __webpack_require__(/*! ./interp */ \"./node_modules/bitsyntax/lib/interp.js\"),\n  parse_int = interp.parse_int,\n  parse_float = interp.parse_float;\nvar construct = __webpack_require__(/*! ./constructor */ \"./node_modules/bitsyntax/lib/constructor.js\"),\n  write_int = construct.write_int,\n  write_float = construct.write_float;\n\nvar lines = [];\nfunction $start() {\n  lines = [];\n}\nfunction $line(/* format , args */) {\n  lines.push($.apply(null, arguments));\n}\nfunction $result() {\n  return lines.join('\\n');\n}\n\nfunction bits_expr(segment) {\n  if (typeof segment.size === 'string') {\n    return $('%s * %d', var_name(segment.size), segment.unit);\n  }\n  else {\n    return (segment.size * segment.unit).toString();\n  }\n}\n\nfunction get_number(segment) {\n  $line('bits = %s;\\n', bits_expr(segment));\n  var parser = (segment.type === 'integer') ?\n    'parse_int' : 'parse_float';\n  var be = segment.bigendian, sg = segment.signed;\n  $line(\"byteoffset = offset / 8; offset += bits\");\n  $line(\"if (offset > binsize) { return false; }\");\n  $line(\"else { result = %s(bin, byteoffset, bits / 8, %s, %s); }\",\n        parser, be, sg);\n}\n\nfunction get_binary(segment) {\n  $line(\"byteoffset = offset / 8;\");\n  if (segment.size === true) {\n    $line(\"offset = binsize;\");\n    $line(\"result = bin.slice(byteoffset);\");\n  }\n  else {\n    $line(\"bits = %s;\", bits_expr(segment));\n    $line(\"offset += bits;\");\n    $line(\"if (offset > binsize) { return false; }\");\n    $line(\"else { result = bin.slice(byteoffset,\",\n          \"byteoffset + bits / 8); }\");\n  }\n}\n\nfunction get_string(segment) {\n  $line(\"byteoffset = offset / 8;\");\n  var strlen = segment.value.length;\n  var strlenbits = strlen * 8;\n  $line(\"offset += %d;\", strlenbits);\n  $line(\"if (offset > binsize) { return false; }\");\n  $line(\"else { result = bin.toString(byteoffset,\",\n        $(\"byteoffset + %d); }\", strlen));\n}\n\nfunction skip_bits(segment) {\n  if (typeof segment.size === 'string') {\n    // Damn. Have to look up the size.\n    $line(\"var skipbits = %s * %d;\",\n          var_name(segment.size), segment.unit);\n    $line(\"if (offset + skipbits > binsize) { return false; }\");\n    $line(\"else { offset += skipbits; }\");\n  }\n  else if (segment.size === true) {\n    $line(\"if (offset % 8 === 0) { offset = binsize; }\");\n    $line(\"else { return false; }\");\n  }\n  else {\n    var bits = segment.unit * segment.size;\n    $line(\"if (offset + %d > binsize) { return false; }\", bits);\n    $line(\"else { offset += %d; }\", bits);\n  }\n}\n\nfunction match_seg(segment) {\n  if (segment.name === '_') {\n    skip_bits(segment);\n  }\n  else {\n    var assign_result;\n    switch (segment.type) {\n    case 'integer':\n    case 'float':\n      get_number(segment);\n      break;\n    case 'binary':\n      get_binary(segment);\n      break;\n    case 'string':\n      get_string(segment);\n      break;\n    }\n    $line(\"if (result === false) return false;\");\n    if (segment.name) {\n      // variable is given a value in the environment\n      $line(\"else if (%s !== undefined) {\", var_name(segment.name));\n      // .. and it is not the same as that matched\n      $line(\"if (%s != result) return false;\",\n            var_name(segment.name));\n      $line(\"}\");\n      // variable is free\n      $line('else %s = result;', var_name(segment.name));\n    }\n    else {\n      var repr = JSON.stringify(segment.value);\n      $line(\"else if (result != %s) return false;\", repr);\n    }\n  }\n}\n\nfunction var_name(name) {\n  return  'var_' + name;\n}\n\nfunction variables(segments) {\n  var names = {};\n  for (var i = 0; i < segments.length; i++) {\n    var name = segments[i].name;\n    if (name && name !== '_') {\n      names[name] = true;\n    }\n    name = segments[i].size;\n    if (typeof name === 'string') {\n      names[name] = true;\n    }\n  }\n  return Object.keys(names);\n}\n\nfunction compile_pattern(segments) {\n  $start();\n  $line(\"return function(binary, env) {\");\n  $line(\"'use strict';\");\n  $line(\"var bin = binary, env = env || {};\");\n  $line(\"var offset = 0, binsize = bin.length * 8;\");\n  $line(\"var bits, result, byteoffset;\");\n  var varnames = variables(segments);\n  for (var v = 0; v < varnames.length; v++) {\n    var name = varnames[v];\n    $line(\"var %s = env['%s'];\", var_name(name), name);\n  }\n\n  var len = segments.length;\n  for (var i = 0; i < len; i++) {\n    var segment = segments[i];\n    $line(\"// \" + JSON.stringify(segment));\n    match_seg(segment);\n  }\n\n  $line(\"if (offset == binsize) {\");\n  $line(\"return {\");\n  for (var v = 0; v < varnames.length; v++) {\n    var name = varnames[v];\n    $line(\"%s: %s,\", name, var_name(name));\n  }\n  $line('};');\n  $line('}'); // if offset == binsize\n  $line(\"else return false;\");\n  $line(\"}\"); // end function\n\n  var fn = new Function('parse_int', 'parse_float', $result());\n  return fn(parse_int, parse_float);\n}\n\n\nfunction write_seg(segment) {\n  switch (segment.type) {\n  case 'string':\n    $line(\"offset += buf.write(%s, offset, 'utf8');\",\n          JSON.stringify(segment.value));\n    break;\n  case 'binary':\n    $line(\"val = bindings['%s'];\", segment.name);\n    if (segment.size === true) {\n      $line('size = val.length;');\n    }\n    else if (typeof segment.size === 'string') {\n      $line(\"size = (bindings['%s'] * %d) / 8;\",\n            segment.size, segment.unit);\n    }\n    else {\n      $line(\"size = %d;\", (segment.size * segment.unit) / 8);\n    }\n    $line('val.copy(buf, offset, 0, size);');\n    $line('offset += size;');\n    break;\n  case 'integer':\n  case 'float':\n    write_number(segment);\n    break;\n  }\n}\n\nfunction write_number(segment) {\n  if (segment.name) {\n    $line(\"val = bindings['%s'];\", segment.name);\n  }\n  else {\n    $line(\"val = %d\", segment.value);\n  }\n  var writer = (segment.type === 'integer') ?\n    'write_int' : 'write_float';\n  if (typeof segment.size === 'string') {\n    $line(\"size = (bindings['%s'] * %d) / 8;\",\n          segment.size, segment.unit);\n  }\n  else {\n    $line('size = %d;', (segment.size * segment.unit) / 8);\n  }\n  $line('%s(buf, val, offset, size, %s);',\n        writer, segment.bigendian);\n  $line('offset += size;');\n}\n\nfunction size_of(segments) {\n  var variable = [];\n  var fixed = 0;\n\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (typeof segment.size === 'string' ||\n        segment.size === true) {\n      variable.push(segment);\n    }\n    else if (segment.type === 'string') {\n      fixed += Buffer.byteLength(segment.value);\n    }\n    else {\n      fixed += (segment.size * segment.unit) / 8;\n    }\n  }\n\n  $line('var buffersize = %d;', fixed);\n\n  if (variable.length > 0) {\n    for (var j = 0; j < variable.length; j++) {\n      var segment = variable[j];\n      if (segment.size === true) {\n        $line(\"buffersize += bindings['%s'].length;\", segment.name);\n      }\n      else {\n        $line(\"buffersize += (bindings['%s'] * %d) / 8;\",\n              segment.size, segment.unit);\n      }\n    }\n  }\n}\n\nfunction emit_write(segments) {\n  $line('var val, size;');\n\n  var len = segments.length;\n  for (var i = 0; i < len; i++) {\n    var segment = segments[i];\n    $line('// %s', JSON.stringify(segment));\n    write_seg(segment);\n  }\n}\n\nfunction compile_ctor(segments) {\n  $start();\n  $line('return function(bindings) {');\n  $line(\"'use strict';\");\n  size_of(segments);\n  $line('var buf = new Buffer(buffersize);');\n  $line('var offset = 0;');\n  emit_write(segments);\n  $line('return buf;');\n  $line('}'); // end function\n\n  return new Function('write_int', 'write_float',\n                      $result())(write_int, write_float);\n}\n\nmodule.exports.compile_pattern = compile_pattern;\nmodule.exports.compile = function() {\n  var str = [].join.call(arguments, ',');\n  var p = parse(str);\n  return compile_pattern(p);\n};\nmodule.exports.compile_builder = function() {\n  var str = [].join.call(arguments, ',');\n  var p = parse(str);\n  return compile_ctor(p);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0c3ludGF4L2xpYi9jb21waWxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JpdHN5bnRheC9saWIvY29tcGlsZS5qcz82MzQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbXBpbGUgcGF0dGVybnMgdG8gcmVjb2duaXNlcnMgYW5kIGNvbnN0cnVjdG9yc1xuXG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJ2J1ZmZlci1tb3JlLWludHMnKTtcbnZhciAkID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcblxudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpLnBhcnNlO1xudmFyIGludGVycCA9IHJlcXVpcmUoJy4vaW50ZXJwJyksXG4gIHBhcnNlX2ludCA9IGludGVycC5wYXJzZV9pbnQsXG4gIHBhcnNlX2Zsb2F0ID0gaW50ZXJwLnBhcnNlX2Zsb2F0O1xudmFyIGNvbnN0cnVjdCA9IHJlcXVpcmUoJy4vY29uc3RydWN0b3InKSxcbiAgd3JpdGVfaW50ID0gY29uc3RydWN0LndyaXRlX2ludCxcbiAgd3JpdGVfZmxvYXQgPSBjb25zdHJ1Y3Qud3JpdGVfZmxvYXQ7XG5cbnZhciBsaW5lcyA9IFtdO1xuZnVuY3Rpb24gJHN0YXJ0KCkge1xuICBsaW5lcyA9IFtdO1xufVxuZnVuY3Rpb24gJGxpbmUoLyogZm9ybWF0ICwgYXJncyAqLykge1xuICBsaW5lcy5wdXNoKCQuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG59XG5mdW5jdGlvbiAkcmVzdWx0KCkge1xuICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIGJpdHNfZXhwcihzZWdtZW50KSB7XG4gIGlmICh0eXBlb2Ygc2VnbWVudC5zaXplID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAkKCclcyAqICVkJywgdmFyX25hbWUoc2VnbWVudC5zaXplKSwgc2VnbWVudC51bml0KTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gKHNlZ21lbnQuc2l6ZSAqIHNlZ21lbnQudW5pdCkudG9TdHJpbmcoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRfbnVtYmVyKHNlZ21lbnQpIHtcbiAgJGxpbmUoJ2JpdHMgPSAlcztcXG4nLCBiaXRzX2V4cHIoc2VnbWVudCkpO1xuICB2YXIgcGFyc2VyID0gKHNlZ21lbnQudHlwZSA9PT0gJ2ludGVnZXInKSA/XG4gICAgJ3BhcnNlX2ludCcgOiAncGFyc2VfZmxvYXQnO1xuICB2YXIgYmUgPSBzZWdtZW50LmJpZ2VuZGlhbiwgc2cgPSBzZWdtZW50LnNpZ25lZDtcbiAgJGxpbmUoXCJieXRlb2Zmc2V0ID0gb2Zmc2V0IC8gODsgb2Zmc2V0ICs9IGJpdHNcIik7XG4gICRsaW5lKFwiaWYgKG9mZnNldCA+IGJpbnNpemUpIHsgcmV0dXJuIGZhbHNlOyB9XCIpO1xuICAkbGluZShcImVsc2UgeyByZXN1bHQgPSAlcyhiaW4sIGJ5dGVvZmZzZXQsIGJpdHMgLyA4LCAlcywgJXMpOyB9XCIsXG4gICAgICAgIHBhcnNlciwgYmUsIHNnKTtcbn1cblxuZnVuY3Rpb24gZ2V0X2JpbmFyeShzZWdtZW50KSB7XG4gICRsaW5lKFwiYnl0ZW9mZnNldCA9IG9mZnNldCAvIDg7XCIpO1xuICBpZiAoc2VnbWVudC5zaXplID09PSB0cnVlKSB7XG4gICAgJGxpbmUoXCJvZmZzZXQgPSBiaW5zaXplO1wiKTtcbiAgICAkbGluZShcInJlc3VsdCA9IGJpbi5zbGljZShieXRlb2Zmc2V0KTtcIik7XG4gIH1cbiAgZWxzZSB7XG4gICAgJGxpbmUoXCJiaXRzID0gJXM7XCIsIGJpdHNfZXhwcihzZWdtZW50KSk7XG4gICAgJGxpbmUoXCJvZmZzZXQgKz0gYml0cztcIik7XG4gICAgJGxpbmUoXCJpZiAob2Zmc2V0ID4gYmluc2l6ZSkgeyByZXR1cm4gZmFsc2U7IH1cIik7XG4gICAgJGxpbmUoXCJlbHNlIHsgcmVzdWx0ID0gYmluLnNsaWNlKGJ5dGVvZmZzZXQsXCIsXG4gICAgICAgICAgXCJieXRlb2Zmc2V0ICsgYml0cyAvIDgpOyB9XCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldF9zdHJpbmcoc2VnbWVudCkge1xuICAkbGluZShcImJ5dGVvZmZzZXQgPSBvZmZzZXQgLyA4O1wiKTtcbiAgdmFyIHN0cmxlbiA9IHNlZ21lbnQudmFsdWUubGVuZ3RoO1xuICB2YXIgc3RybGVuYml0cyA9IHN0cmxlbiAqIDg7XG4gICRsaW5lKFwib2Zmc2V0ICs9ICVkO1wiLCBzdHJsZW5iaXRzKTtcbiAgJGxpbmUoXCJpZiAob2Zmc2V0ID4gYmluc2l6ZSkgeyByZXR1cm4gZmFsc2U7IH1cIik7XG4gICRsaW5lKFwiZWxzZSB7IHJlc3VsdCA9IGJpbi50b1N0cmluZyhieXRlb2Zmc2V0LFwiLFxuICAgICAgICAkKFwiYnl0ZW9mZnNldCArICVkKTsgfVwiLCBzdHJsZW4pKTtcbn1cblxuZnVuY3Rpb24gc2tpcF9iaXRzKHNlZ21lbnQpIHtcbiAgaWYgKHR5cGVvZiBzZWdtZW50LnNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gRGFtbi4gSGF2ZSB0byBsb29rIHVwIHRoZSBzaXplLlxuICAgICRsaW5lKFwidmFyIHNraXBiaXRzID0gJXMgKiAlZDtcIixcbiAgICAgICAgICB2YXJfbmFtZShzZWdtZW50LnNpemUpLCBzZWdtZW50LnVuaXQpO1xuICAgICRsaW5lKFwiaWYgKG9mZnNldCArIHNraXBiaXRzID4gYmluc2l6ZSkgeyByZXR1cm4gZmFsc2U7IH1cIik7XG4gICAgJGxpbmUoXCJlbHNlIHsgb2Zmc2V0ICs9IHNraXBiaXRzOyB9XCIpO1xuICB9XG4gIGVsc2UgaWYgKHNlZ21lbnQuc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICRsaW5lKFwiaWYgKG9mZnNldCAlIDggPT09IDApIHsgb2Zmc2V0ID0gYmluc2l6ZTsgfVwiKTtcbiAgICAkbGluZShcImVsc2UgeyByZXR1cm4gZmFsc2U7IH1cIik7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGJpdHMgPSBzZWdtZW50LnVuaXQgKiBzZWdtZW50LnNpemU7XG4gICAgJGxpbmUoXCJpZiAob2Zmc2V0ICsgJWQgPiBiaW5zaXplKSB7IHJldHVybiBmYWxzZTsgfVwiLCBiaXRzKTtcbiAgICAkbGluZShcImVsc2UgeyBvZmZzZXQgKz0gJWQ7IH1cIiwgYml0cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hfc2VnKHNlZ21lbnQpIHtcbiAgaWYgKHNlZ21lbnQubmFtZSA9PT0gJ18nKSB7XG4gICAgc2tpcF9iaXRzKHNlZ21lbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBhc3NpZ25fcmVzdWx0O1xuICAgIHN3aXRjaCAoc2VnbWVudC50eXBlKSB7XG4gICAgY2FzZSAnaW50ZWdlcic6XG4gICAgY2FzZSAnZmxvYXQnOlxuICAgICAgZ2V0X251bWJlcihzZWdtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICBnZXRfYmluYXJ5KHNlZ21lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGdldF9zdHJpbmcoc2VnbWVudCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgJGxpbmUoXCJpZiAocmVzdWx0ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1wiKTtcbiAgICBpZiAoc2VnbWVudC5uYW1lKSB7XG4gICAgICAvLyB2YXJpYWJsZSBpcyBnaXZlbiBhIHZhbHVlIGluIHRoZSBlbnZpcm9ubWVudFxuICAgICAgJGxpbmUoXCJlbHNlIGlmICglcyAhPT0gdW5kZWZpbmVkKSB7XCIsIHZhcl9uYW1lKHNlZ21lbnQubmFtZSkpO1xuICAgICAgLy8gLi4gYW5kIGl0IGlzIG5vdCB0aGUgc2FtZSBhcyB0aGF0IG1hdGNoZWRcbiAgICAgICRsaW5lKFwiaWYgKCVzICE9IHJlc3VsdCkgcmV0dXJuIGZhbHNlO1wiLFxuICAgICAgICAgICAgdmFyX25hbWUoc2VnbWVudC5uYW1lKSk7XG4gICAgICAkbGluZShcIn1cIik7XG4gICAgICAvLyB2YXJpYWJsZSBpcyBmcmVlXG4gICAgICAkbGluZSgnZWxzZSAlcyA9IHJlc3VsdDsnLCB2YXJfbmFtZShzZWdtZW50Lm5hbWUpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcmVwciA9IEpTT04uc3RyaW5naWZ5KHNlZ21lbnQudmFsdWUpO1xuICAgICAgJGxpbmUoXCJlbHNlIGlmIChyZXN1bHQgIT0gJXMpIHJldHVybiBmYWxzZTtcIiwgcmVwcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhcl9uYW1lKG5hbWUpIHtcbiAgcmV0dXJuICAndmFyXycgKyBuYW1lO1xufVxuXG5mdW5jdGlvbiB2YXJpYWJsZXMoc2VnbWVudHMpIHtcbiAgdmFyIG5hbWVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IHNlZ21lbnRzW2ldLm5hbWU7XG4gICAgaWYgKG5hbWUgJiYgbmFtZSAhPT0gJ18nKSB7XG4gICAgICBuYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgfVxuICAgIG5hbWUgPSBzZWdtZW50c1tpXS5zaXplO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG5hbWVzKTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZV9wYXR0ZXJuKHNlZ21lbnRzKSB7XG4gICRzdGFydCgpO1xuICAkbGluZShcInJldHVybiBmdW5jdGlvbihiaW5hcnksIGVudikge1wiKTtcbiAgJGxpbmUoXCIndXNlIHN0cmljdCc7XCIpO1xuICAkbGluZShcInZhciBiaW4gPSBiaW5hcnksIGVudiA9IGVudiB8fCB7fTtcIik7XG4gICRsaW5lKFwidmFyIG9mZnNldCA9IDAsIGJpbnNpemUgPSBiaW4ubGVuZ3RoICogODtcIik7XG4gICRsaW5lKFwidmFyIGJpdHMsIHJlc3VsdCwgYnl0ZW9mZnNldDtcIik7XG4gIHZhciB2YXJuYW1lcyA9IHZhcmlhYmxlcyhzZWdtZW50cyk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwgdmFybmFtZXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbmFtZSA9IHZhcm5hbWVzW3ZdO1xuICAgICRsaW5lKFwidmFyICVzID0gZW52WyclcyddO1wiLCB2YXJfbmFtZShuYW1lKSwgbmFtZSk7XG4gIH1cblxuICB2YXIgbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAkbGluZShcIi8vIFwiICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkpO1xuICAgIG1hdGNoX3NlZyhzZWdtZW50KTtcbiAgfVxuXG4gICRsaW5lKFwiaWYgKG9mZnNldCA9PSBiaW5zaXplKSB7XCIpO1xuICAkbGluZShcInJldHVybiB7XCIpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IHZhcm5hbWVzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG5hbWUgPSB2YXJuYW1lc1t2XTtcbiAgICAkbGluZShcIiVzOiAlcyxcIiwgbmFtZSwgdmFyX25hbWUobmFtZSkpO1xuICB9XG4gICRsaW5lKCd9OycpO1xuICAkbGluZSgnfScpOyAvLyBpZiBvZmZzZXQgPT0gYmluc2l6ZVxuICAkbGluZShcImVsc2UgcmV0dXJuIGZhbHNlO1wiKTtcbiAgJGxpbmUoXCJ9XCIpOyAvLyBlbmQgZnVuY3Rpb25cblxuICB2YXIgZm4gPSBuZXcgRnVuY3Rpb24oJ3BhcnNlX2ludCcsICdwYXJzZV9mbG9hdCcsICRyZXN1bHQoKSk7XG4gIHJldHVybiBmbihwYXJzZV9pbnQsIHBhcnNlX2Zsb2F0KTtcbn1cblxuXG5mdW5jdGlvbiB3cml0ZV9zZWcoc2VnbWVudCkge1xuICBzd2l0Y2ggKHNlZ21lbnQudHlwZSkge1xuICBjYXNlICdzdHJpbmcnOlxuICAgICRsaW5lKFwib2Zmc2V0ICs9IGJ1Zi53cml0ZSglcywgb2Zmc2V0LCAndXRmOCcpO1wiLFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQudmFsdWUpKTtcbiAgICBicmVhaztcbiAgY2FzZSAnYmluYXJ5JzpcbiAgICAkbGluZShcInZhbCA9IGJpbmRpbmdzWyclcyddO1wiLCBzZWdtZW50Lm5hbWUpO1xuICAgIGlmIChzZWdtZW50LnNpemUgPT09IHRydWUpIHtcbiAgICAgICRsaW5lKCdzaXplID0gdmFsLmxlbmd0aDsnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNlZ21lbnQuc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICRsaW5lKFwic2l6ZSA9IChiaW5kaW5nc1snJXMnXSAqICVkKSAvIDg7XCIsXG4gICAgICAgICAgICBzZWdtZW50LnNpemUsIHNlZ21lbnQudW5pdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgJGxpbmUoXCJzaXplID0gJWQ7XCIsIChzZWdtZW50LnNpemUgKiBzZWdtZW50LnVuaXQpIC8gOCk7XG4gICAgfVxuICAgICRsaW5lKCd2YWwuY29weShidWYsIG9mZnNldCwgMCwgc2l6ZSk7Jyk7XG4gICAgJGxpbmUoJ29mZnNldCArPSBzaXplOycpO1xuICAgIGJyZWFrO1xuICBjYXNlICdpbnRlZ2VyJzpcbiAgY2FzZSAnZmxvYXQnOlxuICAgIHdyaXRlX251bWJlcihzZWdtZW50KTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZV9udW1iZXIoc2VnbWVudCkge1xuICBpZiAoc2VnbWVudC5uYW1lKSB7XG4gICAgJGxpbmUoXCJ2YWwgPSBiaW5kaW5nc1snJXMnXTtcIiwgc2VnbWVudC5uYW1lKTtcbiAgfVxuICBlbHNlIHtcbiAgICAkbGluZShcInZhbCA9ICVkXCIsIHNlZ21lbnQudmFsdWUpO1xuICB9XG4gIHZhciB3cml0ZXIgPSAoc2VnbWVudC50eXBlID09PSAnaW50ZWdlcicpID9cbiAgICAnd3JpdGVfaW50JyA6ICd3cml0ZV9mbG9hdCc7XG4gIGlmICh0eXBlb2Ygc2VnbWVudC5zaXplID09PSAnc3RyaW5nJykge1xuICAgICRsaW5lKFwic2l6ZSA9IChiaW5kaW5nc1snJXMnXSAqICVkKSAvIDg7XCIsXG4gICAgICAgICAgc2VnbWVudC5zaXplLCBzZWdtZW50LnVuaXQpO1xuICB9XG4gIGVsc2Uge1xuICAgICRsaW5lKCdzaXplID0gJWQ7JywgKHNlZ21lbnQuc2l6ZSAqIHNlZ21lbnQudW5pdCkgLyA4KTtcbiAgfVxuICAkbGluZSgnJXMoYnVmLCB2YWwsIG9mZnNldCwgc2l6ZSwgJXMpOycsXG4gICAgICAgIHdyaXRlciwgc2VnbWVudC5iaWdlbmRpYW4pO1xuICAkbGluZSgnb2Zmc2V0ICs9IHNpemU7Jyk7XG59XG5cbmZ1bmN0aW9uIHNpemVfb2Yoc2VnbWVudHMpIHtcbiAgdmFyIHZhcmlhYmxlID0gW107XG4gIHZhciBmaXhlZCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50LnNpemUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHNlZ21lbnQuc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyaWFibGUucHVzaChzZWdtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VnbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgZml4ZWQgKz0gQnVmZmVyLmJ5dGVMZW5ndGgoc2VnbWVudC52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZml4ZWQgKz0gKHNlZ21lbnQuc2l6ZSAqIHNlZ21lbnQudW5pdCkgLyA4O1xuICAgIH1cbiAgfVxuXG4gICRsaW5lKCd2YXIgYnVmZmVyc2l6ZSA9ICVkOycsIGZpeGVkKTtcblxuICBpZiAodmFyaWFibGUubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFyaWFibGUubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBzZWdtZW50ID0gdmFyaWFibGVbal07XG4gICAgICBpZiAoc2VnbWVudC5zaXplID09PSB0cnVlKSB7XG4gICAgICAgICRsaW5lKFwiYnVmZmVyc2l6ZSArPSBiaW5kaW5nc1snJXMnXS5sZW5ndGg7XCIsIHNlZ21lbnQubmFtZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgJGxpbmUoXCJidWZmZXJzaXplICs9IChiaW5kaW5nc1snJXMnXSAqICVkKSAvIDg7XCIsXG4gICAgICAgICAgICAgIHNlZ21lbnQuc2l6ZSwgc2VnbWVudC51bml0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdF93cml0ZShzZWdtZW50cykge1xuICAkbGluZSgndmFyIHZhbCwgc2l6ZTsnKTtcblxuICB2YXIgbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAkbGluZSgnLy8gJXMnLCBKU09OLnN0cmluZ2lmeShzZWdtZW50KSk7XG4gICAgd3JpdGVfc2VnKHNlZ21lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVfY3RvcihzZWdtZW50cykge1xuICAkc3RhcnQoKTtcbiAgJGxpbmUoJ3JldHVybiBmdW5jdGlvbihiaW5kaW5ncykgeycpO1xuICAkbGluZShcIid1c2Ugc3RyaWN0JztcIik7XG4gIHNpemVfb2Yoc2VnbWVudHMpO1xuICAkbGluZSgndmFyIGJ1ZiA9IG5ldyBCdWZmZXIoYnVmZmVyc2l6ZSk7Jyk7XG4gICRsaW5lKCd2YXIgb2Zmc2V0ID0gMDsnKTtcbiAgZW1pdF93cml0ZShzZWdtZW50cyk7XG4gICRsaW5lKCdyZXR1cm4gYnVmOycpO1xuICAkbGluZSgnfScpOyAvLyBlbmQgZnVuY3Rpb25cblxuICByZXR1cm4gbmV3IEZ1bmN0aW9uKCd3cml0ZV9pbnQnLCAnd3JpdGVfZmxvYXQnLFxuICAgICAgICAgICAgICAgICAgICAgICRyZXN1bHQoKSkod3JpdGVfaW50LCB3cml0ZV9mbG9hdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmNvbXBpbGVfcGF0dGVybiA9IGNvbXBpbGVfcGF0dGVybjtcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0ciA9IFtdLmpvaW4uY2FsbChhcmd1bWVudHMsICcsJyk7XG4gIHZhciBwID0gcGFyc2Uoc3RyKTtcbiAgcmV0dXJuIGNvbXBpbGVfcGF0dGVybihwKTtcbn07XG5tb2R1bGUuZXhwb3J0cy5jb21waWxlX2J1aWxkZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0ciA9IFtdLmpvaW4uY2FsbChhcmd1bWVudHMsICcsJyk7XG4gIHZhciBwID0gcGFyc2Uoc3RyKTtcbiAgcmV0dXJuIGNvbXBpbGVfY3RvcihwKTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bitsyntax/lib/compile.js\n");

/***/ }),

/***/ "./node_modules/bitsyntax/lib/constructor.js":
/*!***************************************************!*\
  !*** ./node_modules/bitsyntax/lib/constructor.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// -*- js-indent-level: 2 -*-\n\n// Constructors given patterns\n\n\n\nvar ints = __webpack_require__(/*! buffer-more-ints */ \"./node_modules/buffer-more-ints/buffer-more-ints.js\");\n\n// Interpret the pattern, writing values into a buffer\nfunction write(buf, offset, pattern, bindings) {\n  for (var i=0, len = pattern.length; i < len; i++) {\n    var segment = pattern[i];\n    \n    switch (segment.type) {\n    case 'string':\n      offset += buf.write(segment.value, offset, 'utf8');\n      break;\n    case 'binary':\n      offset += writeBinary(segment, buf, offset, bindings);\n      break;\n    case 'integer':\n      offset += writeInteger(segment, buf, offset, bindings);\n      break;\n    case 'float':\n      offset += writeFloat(segment, buf, offset, bindings);\n      break;\n    }\n  }\n  return offset;\n}\n\nfunction build(pattern, bindings) {\n  var bufsize = size_of(pattern, bindings);\n  var buf = new Buffer(bufsize);\n  write(buf, 0, pattern, bindings);\n  return buf;\n}\n\n// In bytes\nfunction size_of_segment(segment, bindings) {\n  // size refers to a variable\n  if (typeof segment.size === 'string') {\n    return (bindings[segment.size] * segment.unit) / 8;\n  }\n  if (segment.type === 'string') {\n    return Buffer.byteLength(segment.value, 'utf8');\n  }\n  if (segment.type === 'binary' && segment.size === true) {\n    var val = bindings[segment.name];\n    return val.length;\n  }\n  return (segment.size * segment.unit) / 8;\n}\n\n// size of the to-be-constructed binary, in bytes\nfunction size_of(segments, bindings) {\n  var size = 0;\n  for (var i=0, len = segments.length; i < len; i++) {\n    size += size_of_segment(segments[i], bindings);\n  }\n  return size;\n}\n\nfunction writeBinary(segment, buf, offset, bindings) {\n  var bin = bindings[segment.name];\n  var size = size_of_segment(segment, bindings);\n  bin.copy(buf, offset, 0, size);\n  return size;\n}\n\n// TODO in ff might use the noAssert argument to Buffer.write*() but\n// need to check that it does the right thing wrt little-endian\n\nfunction writeInteger(segment, buf, offset, bindings) {\n  var value = (segment.name) ? bindings[segment.name] : segment.value;\n  var size = size_of_segment(segment, bindings);\n  return write_int(buf, value, offset, size, segment.bigendian);\n}\n\nfunction write_int(buf, value, offset, size, bigendian) {\n  switch (size) {\n  case 1:\n    buf.writeUInt8(value, offset);\n    break;\n  case 2:\n    (bigendian) ?\n      buf.writeUInt16BE(value, offset) :\n      buf.writeUInt16LE(value, offset);\n    break;\n  case 4:\n    (bigendian) ?\n      buf.writeUInt32BE(value, offset) :\n      buf.writeUInt32LE(value, offset);\n    break;\n  case 8:\n    (bigendian) ?\n      ints.writeUInt64BE(buf, value, offset) :\n      ints.writeUInt64LE(buf, value, offset);\n    break;\n  default:\n    throw new Error(\"integer size * unit must be 8, 16, 32 or 64\");\n  }\n  return size;\n}\n\nfunction writeFloat(segment, buf, offset, bindings) {\n  var value = (segment.name) ? bindings[segment.name] : segment.value;\n  var size = size_of_segment(segment, bindings);\n  return write_float(buf, value, offset, size, segment.bigendian);\n}\n\nfunction write_float(buf, value, offset, size, bigendian) {\n  if (size === 4) {\n    (bigendian) ?\n      buf.writeFloatBE(value, offset) :\n      buf.writeFloatLE(value, offset);\n  }\n  else if (size === 8) {\n    (bigendian) ?\n      buf.writeDoubleBE(value, offset) :\n      buf.writeDoubleLE(value, offset);\n  }\n  else {\n    throw new Error(\"float size * unit must be 32 or 64\");\n  }\n  return size;\n}\n\nvar parse = __webpack_require__(/*! ./parse */ \"./node_modules/bitsyntax/lib/parse.js\").parse;\n\nmodule.exports.write = write;\nmodule.exports.build = build;\nmodule.exports.write_int = write_int;\nmodule.exports.write_float = write_float;\n\nmodule.exports.builder = function(pstr) {\n  pstr = (arguments.length > 1) ? [].join.call(arguments, ',') : pstr;\n  var pattern = parse(pstr);\n  return function(vars) {\n    return build(pattern, vars);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0c3ludGF4L2xpYi9jb25zdHJ1Y3Rvci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iaXRzeW50YXgvbGliL2NvbnN0cnVjdG9yLmpzPzc4OWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gLSotIGpzLWluZGVudC1sZXZlbDogMiAtKi1cblxuLy8gQ29uc3RydWN0b3JzIGdpdmVuIHBhdHRlcm5zXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludHMgPSByZXF1aXJlKCdidWZmZXItbW9yZS1pbnRzJyk7XG5cbi8vIEludGVycHJldCB0aGUgcGF0dGVybiwgd3JpdGluZyB2YWx1ZXMgaW50byBhIGJ1ZmZlclxuZnVuY3Rpb24gd3JpdGUoYnVmLCBvZmZzZXQsIHBhdHRlcm4sIGJpbmRpbmdzKSB7XG4gIGZvciAodmFyIGk9MCwgbGVuID0gcGF0dGVybi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gcGF0dGVybltpXTtcbiAgICBcbiAgICBzd2l0Y2ggKHNlZ21lbnQudHlwZSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBvZmZzZXQgKz0gYnVmLndyaXRlKHNlZ21lbnQudmFsdWUsIG9mZnNldCwgJ3V0ZjgnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICBvZmZzZXQgKz0gd3JpdGVCaW5hcnkoc2VnbWVudCwgYnVmLCBvZmZzZXQsIGJpbmRpbmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgb2Zmc2V0ICs9IHdyaXRlSW50ZWdlcihzZWdtZW50LCBidWYsIG9mZnNldCwgYmluZGluZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZmxvYXQnOlxuICAgICAgb2Zmc2V0ICs9IHdyaXRlRmxvYXQoc2VnbWVudCwgYnVmLCBvZmZzZXQsIGJpbmRpbmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBidWlsZChwYXR0ZXJuLCBiaW5kaW5ncykge1xuICB2YXIgYnVmc2l6ZSA9IHNpemVfb2YocGF0dGVybiwgYmluZGluZ3MpO1xuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihidWZzaXplKTtcbiAgd3JpdGUoYnVmLCAwLCBwYXR0ZXJuLCBiaW5kaW5ncyk7XG4gIHJldHVybiBidWY7XG59XG5cbi8vIEluIGJ5dGVzXG5mdW5jdGlvbiBzaXplX29mX3NlZ21lbnQoc2VnbWVudCwgYmluZGluZ3MpIHtcbiAgLy8gc2l6ZSByZWZlcnMgdG8gYSB2YXJpYWJsZVxuICBpZiAodHlwZW9mIHNlZ21lbnQuc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gKGJpbmRpbmdzW3NlZ21lbnQuc2l6ZV0gKiBzZWdtZW50LnVuaXQpIC8gODtcbiAgfVxuICBpZiAoc2VnbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzZWdtZW50LnZhbHVlLCAndXRmOCcpO1xuICB9XG4gIGlmIChzZWdtZW50LnR5cGUgPT09ICdiaW5hcnknICYmIHNlZ21lbnQuc2l6ZSA9PT0gdHJ1ZSkge1xuICAgIHZhciB2YWwgPSBiaW5kaW5nc1tzZWdtZW50Lm5hbWVdO1xuICAgIHJldHVybiB2YWwubGVuZ3RoO1xuICB9XG4gIHJldHVybiAoc2VnbWVudC5zaXplICogc2VnbWVudC51bml0KSAvIDg7XG59XG5cbi8vIHNpemUgb2YgdGhlIHRvLWJlLWNvbnN0cnVjdGVkIGJpbmFyeSwgaW4gYnl0ZXNcbmZ1bmN0aW9uIHNpemVfb2Yoc2VnbWVudHMsIGJpbmRpbmdzKSB7XG4gIHZhciBzaXplID0gMDtcbiAgZm9yICh2YXIgaT0wLCBsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNpemUgKz0gc2l6ZV9vZl9zZWdtZW50KHNlZ21lbnRzW2ldLCBiaW5kaW5ncyk7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmluYXJ5KHNlZ21lbnQsIGJ1Ziwgb2Zmc2V0LCBiaW5kaW5ncykge1xuICB2YXIgYmluID0gYmluZGluZ3Nbc2VnbWVudC5uYW1lXTtcbiAgdmFyIHNpemUgPSBzaXplX29mX3NlZ21lbnQoc2VnbWVudCwgYmluZGluZ3MpO1xuICBiaW4uY29weShidWYsIG9mZnNldCwgMCwgc2l6ZSk7XG4gIHJldHVybiBzaXplO1xufVxuXG4vLyBUT0RPIGluIGZmIG1pZ2h0IHVzZSB0aGUgbm9Bc3NlcnQgYXJndW1lbnQgdG8gQnVmZmVyLndyaXRlKigpIGJ1dFxuLy8gbmVlZCB0byBjaGVjayB0aGF0IGl0IGRvZXMgdGhlIHJpZ2h0IHRoaW5nIHdydCBsaXR0bGUtZW5kaWFuXG5cbmZ1bmN0aW9uIHdyaXRlSW50ZWdlcihzZWdtZW50LCBidWYsIG9mZnNldCwgYmluZGluZ3MpIHtcbiAgdmFyIHZhbHVlID0gKHNlZ21lbnQubmFtZSkgPyBiaW5kaW5nc1tzZWdtZW50Lm5hbWVdIDogc2VnbWVudC52YWx1ZTtcbiAgdmFyIHNpemUgPSBzaXplX29mX3NlZ21lbnQoc2VnbWVudCwgYmluZGluZ3MpO1xuICByZXR1cm4gd3JpdGVfaW50KGJ1ZiwgdmFsdWUsIG9mZnNldCwgc2l6ZSwgc2VnbWVudC5iaWdlbmRpYW4pO1xufVxuXG5mdW5jdGlvbiB3cml0ZV9pbnQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBzaXplLCBiaWdlbmRpYW4pIHtcbiAgc3dpdGNoIChzaXplKSB7XG4gIGNhc2UgMTpcbiAgICBidWYud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSAyOlxuICAgIChiaWdlbmRpYW4pID9cbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKHZhbHVlLCBvZmZzZXQpIDpcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkxFKHZhbHVlLCBvZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlIDQ6XG4gICAgKGJpZ2VuZGlhbikgP1xuICAgICAgYnVmLndyaXRlVUludDMyQkUodmFsdWUsIG9mZnNldCkgOlxuICAgICAgYnVmLndyaXRlVUludDMyTEUodmFsdWUsIG9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgODpcbiAgICAoYmlnZW5kaWFuKSA/XG4gICAgICBpbnRzLndyaXRlVUludDY0QkUoYnVmLCB2YWx1ZSwgb2Zmc2V0KSA6XG4gICAgICBpbnRzLndyaXRlVUludDY0TEUoYnVmLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnRlZ2VyIHNpemUgKiB1bml0IG11c3QgYmUgOCwgMTYsIDMyIG9yIDY0XCIpO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0KHNlZ21lbnQsIGJ1Ziwgb2Zmc2V0LCBiaW5kaW5ncykge1xuICB2YXIgdmFsdWUgPSAoc2VnbWVudC5uYW1lKSA/IGJpbmRpbmdzW3NlZ21lbnQubmFtZV0gOiBzZWdtZW50LnZhbHVlO1xuICB2YXIgc2l6ZSA9IHNpemVfb2Zfc2VnbWVudChzZWdtZW50LCBiaW5kaW5ncyk7XG4gIHJldHVybiB3cml0ZV9mbG9hdChidWYsIHZhbHVlLCBvZmZzZXQsIHNpemUsIHNlZ21lbnQuYmlnZW5kaWFuKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVfZmxvYXQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBzaXplLCBiaWdlbmRpYW4pIHtcbiAgaWYgKHNpemUgPT09IDQpIHtcbiAgICAoYmlnZW5kaWFuKSA/XG4gICAgICBidWYud3JpdGVGbG9hdEJFKHZhbHVlLCBvZmZzZXQpIDpcbiAgICAgIGJ1Zi53cml0ZUZsb2F0TEUodmFsdWUsIG9mZnNldCk7XG4gIH1cbiAgZWxzZSBpZiAoc2l6ZSA9PT0gOCkge1xuICAgIChiaWdlbmRpYW4pID9cbiAgICAgIGJ1Zi53cml0ZURvdWJsZUJFKHZhbHVlLCBvZmZzZXQpIDpcbiAgICAgIGJ1Zi53cml0ZURvdWJsZUxFKHZhbHVlLCBvZmZzZXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZsb2F0IHNpemUgKiB1bml0IG11c3QgYmUgMzIgb3IgNjRcIik7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbnZhciBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKS5wYXJzZTtcblxubW9kdWxlLmV4cG9ydHMud3JpdGUgPSB3cml0ZTtcbm1vZHVsZS5leHBvcnRzLmJ1aWxkID0gYnVpbGQ7XG5tb2R1bGUuZXhwb3J0cy53cml0ZV9pbnQgPSB3cml0ZV9pbnQ7XG5tb2R1bGUuZXhwb3J0cy53cml0ZV9mbG9hdCA9IHdyaXRlX2Zsb2F0O1xuXG5tb2R1bGUuZXhwb3J0cy5idWlsZGVyID0gZnVuY3Rpb24ocHN0cikge1xuICBwc3RyID0gKGFyZ3VtZW50cy5sZW5ndGggPiAxKSA/IFtdLmpvaW4uY2FsbChhcmd1bWVudHMsICcsJykgOiBwc3RyO1xuICB2YXIgcGF0dGVybiA9IHBhcnNlKHBzdHIpO1xuICByZXR1cm4gZnVuY3Rpb24odmFycykge1xuICAgIHJldHVybiBidWlsZChwYXR0ZXJuLCB2YXJzKTtcbiAgfTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bitsyntax/lib/constructor.js\n");

/***/ }),

/***/ "./node_modules/bitsyntax/lib/interp.js":
/*!**********************************************!*\
  !*** ./node_modules/bitsyntax/lib/interp.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// -*- js-indent: 2 -*-\n// Interpreter for bit syntax AST.\n// Grammar:\n//\n// pattern   := segment (\",\" segment)*\n// segment   := (value | var) (\":\" size)? (\"/\" specifier (\"-\" specifier)*)? | string\n// var       := \"_\" | identifier\n// size      := integer | var\n// specifier := \"little\" | \"big\" | \"signed\" | \"unsigned\" | \"unit\" \":\" 0..256 | type\n// type      := \"integer\" | \"binary\" | \"float\"\n//\n// where integer has the obvious meaning, and identifier is anything\n// other than \"_\" that fits the JavaScript identifier specification.\n//\n\n// We'll use an object to represent each segment, and an array of\n// segments for a pattern. We won't try to optimise for groups of\n// patterns; we'll just step through each to see if it works. We rely\n// a hypothetical prior step to check that it's a valid pattern.\n\n// ? compile to intermediate instructions ?\n\n// A segment looks like\n// {\n//    type: string, // 'string' is special case\n//    size: integer | true, // true means 'all remaining'\n//    name: string | null, // (may be '_')\n//    value: value | null, // either name OR value\n//    unit: integer,\n//    signed: boolean,\n//    bigendian: boolean\n// }\n\n\n\nvar ints = __webpack_require__(/*! buffer-more-ints */ \"./node_modules/buffer-more-ints/buffer-more-ints.js\");\n\nvar debug = (process.env.DEBUG) ?\n  function(s) { console.log(s); } : function () {};\n\nfunction parse_int(bin, off, sizeInBytes, bigendian, signed) {\n  switch (sizeInBytes) {\n  case 1:\n    return (signed) ? bin.readInt8(off) : bin.readUInt8(off);\n  case 2:\n    return (bigendian) ?\n      (signed) ? bin.readInt16BE(off) : bin.readUInt16BE(off) :\n      (signed) ? bin.readInt16LE(off) : bin.readUInt16LE(off);\n  case 4:\n    return (bigendian) ?\n      (signed) ? bin.readInt32BE(off) : bin.readUInt32BE(off) :\n      (signed) ? bin.readInt32LE(off) : bin.readUInt32LE(off);\n  case 8:\n    return (bigendian) ?\n      ((signed) ? ints.readInt64BE : ints.readUInt64BE)(bin, off) :\n      ((signed) ? ints.readInt64LE : ints.readUInt64LE)(bin, off);\n  default:\n    throw \"Integers must be 8-, 16-, 32- or 64-bit\";\n  }\n}\n\nfunction parse_float(bin, off, sizeInBytes, bigendian) {\n  switch (sizeInBytes) {\n  case 4:\n    return (bigendian) ? bin.readFloatBE(off) : bin.readFloatLE(off);\n  case 8:\n    return (bigendian) ? bin.readDoubleBE(off) : bin.readDoubleLE(off);\n  default:\n    throw \"Floats must be 32- or 64-bit\";\n  }\n}\n\nfunction size_of(segment, bound) {\n  var size = segment.size;\n  if (typeof size === 'string') {\n    return bound[size];\n  }\n  else {\n    return size;\n  }\n}\n\nfunction new_scope(env) {\n  function scope() {};\n  scope.prototype = env;\n  return new scope();\n}\n\nfunction bindings(scope) {\n  var s = {};\n  for (var k in scope) {\n    if (scope.hasOwnProperty(k)) {\n      s[k] = scope[k];\n    }\n  }\n  return s;\n}\n\nfunction match(pattern, binary, boundvars) {\n  var offset = 0, vars = new_scope(boundvars);\n  var binsize = binary.length * 8;\n\n  function skip_bits(segment) {\n    debug(\"skip bits\"); debug(segment);\n    var size = size_of(segment, vars);\n    if (size === true) {\n      if (offset % 8 === 0) {\n        offset = binsize;\n        return true;\n      }\n      else {\n        return false;\n      }\n    }\n\n    var bits = segment.unit * size;\n    if (offset + bits > binsize) {\n      return false;\n    }\n    else {\n      offset += bits;\n    }\n  }\n\n  function get_integer(segment) {\n    debug(\"get_integer\"); debug(segment);\n    // let's do only multiples of eight bits for now\n    var unit = segment.unit, size = size_of(segment, vars);\n    var bitsize = size * unit;\n    var byteoffset = offset / 8; // NB assumes aligned\n    offset += bitsize;\n    if (bitsize % 8 > 0 || (offset > binsize)) {\n      return false;\n    }\n    else {\n      return parse_int(binary, byteoffset, bitsize / 8,\n                       segment.bigendian, segment.signed);\n    }\n  }\n\n  function get_float(segment) {\n    debug(\"get_float\"); debug(segment);\n    var unit = segment.unit; var size = size_of(segment, vars);\n    var bitsize = size * unit;\n    var byteoffset = offset / 8; // assume aligned\n    offset += bitsize;\n    if (offset > binsize) {\n      return false;\n    }\n    else {\n      return parse_float(binary, byteoffset,\n                         bitsize / 8, segment.bigendian);\n    }\n  }\n\n  function get_binary(segment) {\n    debug(\"get_binary\"); debug(segment);\n    var unit = segment.unit, size = size_of(segment, vars);\n    var byteoffset = offset / 8; // NB alignment\n\n    if (size === true) {\n      offset = binsize;\n      return binary.slice(byteoffset);\n    }\n    else {\n      var bitsize = size * unit;\n      if (bitsize % 8 > 0 || (offset + bitsize) > binsize) {\n        return false;\n      }\n      else {\n        offset += bitsize;\n        return binary.slice(byteoffset, byteoffset + bitsize / 8);\n      }\n    }\n  }\n\n  function get_string(segment) {\n    debug(\"get_string\"); debug(segment);\n    var len = segment.value.length;\n    var byteoffset = offset / 8;\n\n    offset += len * 8;\n    if (offset > binsize) {\n      return false;\n    }\n    // FIXME bytes vs UTF8 characters\n    return binary.slice(byteoffset, byteoffset + len).toString('utf8');\n  }\n\n  var patternlen = pattern.length;\n  for (var i = 0;  i < patternlen; i++) {\n    var segment = pattern[i];\n    var result = false;\n    if (segment.name === '_') {\n      result = skip_bits(segment);\n    }\n    else {\n      switch (segment.type) {\n      case 'string':\n        result = get_string(segment);\n        break;\n      case 'integer':\n        result = get_integer(segment);\n        break;\n      case 'float':\n        result = get_float(segment);\n        break;\n      case 'binary':\n        result = get_binary(segment);\n        break;\n      }\n\n      if (result === false) {\n        return false;\n      }\n      else if (segment.name) {\n        vars[segment.name] = result;\n      }\n      else if (segment.value != result) {\n        return false;\n      }\n    }\n  }\n  if (offset == binsize) {\n    return bindings(vars);\n  }\n  else {\n    return false;\n  }\n}\n\nmodule.exports.match = match;\nmodule.exports.parse_int = parse_int;\nmodule.exports.parse_float = parse_float;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0c3ludGF4L2xpYi9pbnRlcnAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYml0c3ludGF4L2xpYi9pbnRlcnAuanM/NzI4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAtKi0ganMtaW5kZW50OiAyIC0qLVxuLy8gSW50ZXJwcmV0ZXIgZm9yIGJpdCBzeW50YXggQVNULlxuLy8gR3JhbW1hcjpcbi8vXG4vLyBwYXR0ZXJuICAgOj0gc2VnbWVudCAoXCIsXCIgc2VnbWVudCkqXG4vLyBzZWdtZW50ICAgOj0gKHZhbHVlIHwgdmFyKSAoXCI6XCIgc2l6ZSk/IChcIi9cIiBzcGVjaWZpZXIgKFwiLVwiIHNwZWNpZmllcikqKT8gfCBzdHJpbmdcbi8vIHZhciAgICAgICA6PSBcIl9cIiB8IGlkZW50aWZpZXJcbi8vIHNpemUgICAgICA6PSBpbnRlZ2VyIHwgdmFyXG4vLyBzcGVjaWZpZXIgOj0gXCJsaXR0bGVcIiB8IFwiYmlnXCIgfCBcInNpZ25lZFwiIHwgXCJ1bnNpZ25lZFwiIHwgXCJ1bml0XCIgXCI6XCIgMC4uMjU2IHwgdHlwZVxuLy8gdHlwZSAgICAgIDo9IFwiaW50ZWdlclwiIHwgXCJiaW5hcnlcIiB8IFwiZmxvYXRcIlxuLy9cbi8vIHdoZXJlIGludGVnZXIgaGFzIHRoZSBvYnZpb3VzIG1lYW5pbmcsIGFuZCBpZGVudGlmaWVyIGlzIGFueXRoaW5nXG4vLyBvdGhlciB0aGFuIFwiX1wiIHRoYXQgZml0cyB0aGUgSmF2YVNjcmlwdCBpZGVudGlmaWVyIHNwZWNpZmljYXRpb24uXG4vL1xuXG4vLyBXZSdsbCB1c2UgYW4gb2JqZWN0IHRvIHJlcHJlc2VudCBlYWNoIHNlZ21lbnQsIGFuZCBhbiBhcnJheSBvZlxuLy8gc2VnbWVudHMgZm9yIGEgcGF0dGVybi4gV2Ugd29uJ3QgdHJ5IHRvIG9wdGltaXNlIGZvciBncm91cHMgb2Zcbi8vIHBhdHRlcm5zOyB3ZSdsbCBqdXN0IHN0ZXAgdGhyb3VnaCBlYWNoIHRvIHNlZSBpZiBpdCB3b3Jrcy4gV2UgcmVseVxuLy8gYSBoeXBvdGhldGljYWwgcHJpb3Igc3RlcCB0byBjaGVjayB0aGF0IGl0J3MgYSB2YWxpZCBwYXR0ZXJuLlxuXG4vLyA/IGNvbXBpbGUgdG8gaW50ZXJtZWRpYXRlIGluc3RydWN0aW9ucyA/XG5cbi8vIEEgc2VnbWVudCBsb29rcyBsaWtlXG4vLyB7XG4vLyAgICB0eXBlOiBzdHJpbmcsIC8vICdzdHJpbmcnIGlzIHNwZWNpYWwgY2FzZVxuLy8gICAgc2l6ZTogaW50ZWdlciB8IHRydWUsIC8vIHRydWUgbWVhbnMgJ2FsbCByZW1haW5pbmcnXG4vLyAgICBuYW1lOiBzdHJpbmcgfCBudWxsLCAvLyAobWF5IGJlICdfJylcbi8vICAgIHZhbHVlOiB2YWx1ZSB8IG51bGwsIC8vIGVpdGhlciBuYW1lIE9SIHZhbHVlXG4vLyAgICB1bml0OiBpbnRlZ2VyLFxuLy8gICAgc2lnbmVkOiBib29sZWFuLFxuLy8gICAgYmlnZW5kaWFuOiBib29sZWFuXG4vLyB9XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludHMgPSByZXF1aXJlKCdidWZmZXItbW9yZS1pbnRzJyk7XG5cbnZhciBkZWJ1ZyA9IChwcm9jZXNzLmVudi5ERUJVRykgP1xuICBmdW5jdGlvbihzKSB7IGNvbnNvbGUubG9nKHMpOyB9IDogZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIHBhcnNlX2ludChiaW4sIG9mZiwgc2l6ZUluQnl0ZXMsIGJpZ2VuZGlhbiwgc2lnbmVkKSB7XG4gIHN3aXRjaCAoc2l6ZUluQnl0ZXMpIHtcbiAgY2FzZSAxOlxuICAgIHJldHVybiAoc2lnbmVkKSA/IGJpbi5yZWFkSW50OChvZmYpIDogYmluLnJlYWRVSW50OChvZmYpO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIChiaWdlbmRpYW4pID9cbiAgICAgIChzaWduZWQpID8gYmluLnJlYWRJbnQxNkJFKG9mZikgOiBiaW4ucmVhZFVJbnQxNkJFKG9mZikgOlxuICAgICAgKHNpZ25lZCkgPyBiaW4ucmVhZEludDE2TEUob2ZmKSA6IGJpbi5yZWFkVUludDE2TEUob2ZmKTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiAoYmlnZW5kaWFuKSA/XG4gICAgICAoc2lnbmVkKSA/IGJpbi5yZWFkSW50MzJCRShvZmYpIDogYmluLnJlYWRVSW50MzJCRShvZmYpIDpcbiAgICAgIChzaWduZWQpID8gYmluLnJlYWRJbnQzMkxFKG9mZikgOiBiaW4ucmVhZFVJbnQzMkxFKG9mZik7XG4gIGNhc2UgODpcbiAgICByZXR1cm4gKGJpZ2VuZGlhbikgP1xuICAgICAgKChzaWduZWQpID8gaW50cy5yZWFkSW50NjRCRSA6IGludHMucmVhZFVJbnQ2NEJFKShiaW4sIG9mZikgOlxuICAgICAgKChzaWduZWQpID8gaW50cy5yZWFkSW50NjRMRSA6IGludHMucmVhZFVJbnQ2NExFKShiaW4sIG9mZik7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgXCJJbnRlZ2VycyBtdXN0IGJlIDgtLCAxNi0sIDMyLSBvciA2NC1iaXRcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZV9mbG9hdChiaW4sIG9mZiwgc2l6ZUluQnl0ZXMsIGJpZ2VuZGlhbikge1xuICBzd2l0Y2ggKHNpemVJbkJ5dGVzKSB7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gKGJpZ2VuZGlhbikgPyBiaW4ucmVhZEZsb2F0QkUob2ZmKSA6IGJpbi5yZWFkRmxvYXRMRShvZmYpO1xuICBjYXNlIDg6XG4gICAgcmV0dXJuIChiaWdlbmRpYW4pID8gYmluLnJlYWREb3VibGVCRShvZmYpIDogYmluLnJlYWREb3VibGVMRShvZmYpO1xuICBkZWZhdWx0OlxuICAgIHRocm93IFwiRmxvYXRzIG11c3QgYmUgMzItIG9yIDY0LWJpdFwiO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNpemVfb2Yoc2VnbWVudCwgYm91bmQpIHtcbiAgdmFyIHNpemUgPSBzZWdtZW50LnNpemU7XG4gIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYm91bmRbc2l6ZV07XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmV3X3Njb3BlKGVudikge1xuICBmdW5jdGlvbiBzY29wZSgpIHt9O1xuICBzY29wZS5wcm90b3R5cGUgPSBlbnY7XG4gIHJldHVybiBuZXcgc2NvcGUoKTtcbn1cblxuZnVuY3Rpb24gYmluZGluZ3Moc2NvcGUpIHtcbiAgdmFyIHMgPSB7fTtcbiAgZm9yICh2YXIgayBpbiBzY29wZSkge1xuICAgIGlmIChzY29wZS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgc1trXSA9IHNjb3BlW2tdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gbWF0Y2gocGF0dGVybiwgYmluYXJ5LCBib3VuZHZhcnMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhcnMgPSBuZXdfc2NvcGUoYm91bmR2YXJzKTtcbiAgdmFyIGJpbnNpemUgPSBiaW5hcnkubGVuZ3RoICogODtcblxuICBmdW5jdGlvbiBza2lwX2JpdHMoc2VnbWVudCkge1xuICAgIGRlYnVnKFwic2tpcCBiaXRzXCIpOyBkZWJ1ZyhzZWdtZW50KTtcbiAgICB2YXIgc2l6ZSA9IHNpemVfb2Yoc2VnbWVudCwgdmFycyk7XG4gICAgaWYgKHNpemUgPT09IHRydWUpIHtcbiAgICAgIGlmIChvZmZzZXQgJSA4ID09PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IGJpbnNpemU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYml0cyA9IHNlZ21lbnQudW5pdCAqIHNpemU7XG4gICAgaWYgKG9mZnNldCArIGJpdHMgPiBiaW5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb2Zmc2V0ICs9IGJpdHM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0X2ludGVnZXIoc2VnbWVudCkge1xuICAgIGRlYnVnKFwiZ2V0X2ludGVnZXJcIik7IGRlYnVnKHNlZ21lbnQpO1xuICAgIC8vIGxldCdzIGRvIG9ubHkgbXVsdGlwbGVzIG9mIGVpZ2h0IGJpdHMgZm9yIG5vd1xuICAgIHZhciB1bml0ID0gc2VnbWVudC51bml0LCBzaXplID0gc2l6ZV9vZihzZWdtZW50LCB2YXJzKTtcbiAgICB2YXIgYml0c2l6ZSA9IHNpemUgKiB1bml0O1xuICAgIHZhciBieXRlb2Zmc2V0ID0gb2Zmc2V0IC8gODsgLy8gTkIgYXNzdW1lcyBhbGlnbmVkXG4gICAgb2Zmc2V0ICs9IGJpdHNpemU7XG4gICAgaWYgKGJpdHNpemUgJSA4ID4gMCB8fCAob2Zmc2V0ID4gYmluc2l6ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VfaW50KGJpbmFyeSwgYnl0ZW9mZnNldCwgYml0c2l6ZSAvIDgsXG4gICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQuYmlnZW5kaWFuLCBzZWdtZW50LnNpZ25lZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0X2Zsb2F0KHNlZ21lbnQpIHtcbiAgICBkZWJ1ZyhcImdldF9mbG9hdFwiKTsgZGVidWcoc2VnbWVudCk7XG4gICAgdmFyIHVuaXQgPSBzZWdtZW50LnVuaXQ7IHZhciBzaXplID0gc2l6ZV9vZihzZWdtZW50LCB2YXJzKTtcbiAgICB2YXIgYml0c2l6ZSA9IHNpemUgKiB1bml0O1xuICAgIHZhciBieXRlb2Zmc2V0ID0gb2Zmc2V0IC8gODsgLy8gYXNzdW1lIGFsaWduZWRcbiAgICBvZmZzZXQgKz0gYml0c2l6ZTtcbiAgICBpZiAob2Zmc2V0ID4gYmluc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJzZV9mbG9hdChiaW5hcnksIGJ5dGVvZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgYml0c2l6ZSAvIDgsIHNlZ21lbnQuYmlnZW5kaWFuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRfYmluYXJ5KHNlZ21lbnQpIHtcbiAgICBkZWJ1ZyhcImdldF9iaW5hcnlcIik7IGRlYnVnKHNlZ21lbnQpO1xuICAgIHZhciB1bml0ID0gc2VnbWVudC51bml0LCBzaXplID0gc2l6ZV9vZihzZWdtZW50LCB2YXJzKTtcbiAgICB2YXIgYnl0ZW9mZnNldCA9IG9mZnNldCAvIDg7IC8vIE5CIGFsaWdubWVudFxuXG4gICAgaWYgKHNpemUgPT09IHRydWUpIHtcbiAgICAgIG9mZnNldCA9IGJpbnNpemU7XG4gICAgICByZXR1cm4gYmluYXJ5LnNsaWNlKGJ5dGVvZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBiaXRzaXplID0gc2l6ZSAqIHVuaXQ7XG4gICAgICBpZiAoYml0c2l6ZSAlIDggPiAwIHx8IChvZmZzZXQgKyBiaXRzaXplKSA+IGJpbnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9mZnNldCArPSBiaXRzaXplO1xuICAgICAgICByZXR1cm4gYmluYXJ5LnNsaWNlKGJ5dGVvZmZzZXQsIGJ5dGVvZmZzZXQgKyBiaXRzaXplIC8gOCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0X3N0cmluZyhzZWdtZW50KSB7XG4gICAgZGVidWcoXCJnZXRfc3RyaW5nXCIpOyBkZWJ1ZyhzZWdtZW50KTtcbiAgICB2YXIgbGVuID0gc2VnbWVudC52YWx1ZS5sZW5ndGg7XG4gICAgdmFyIGJ5dGVvZmZzZXQgPSBvZmZzZXQgLyA4O1xuXG4gICAgb2Zmc2V0ICs9IGxlbiAqIDg7XG4gICAgaWYgKG9mZnNldCA+IGJpbnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRklYTUUgYnl0ZXMgdnMgVVRGOCBjaGFyYWN0ZXJzXG4gICAgcmV0dXJuIGJpbmFyeS5zbGljZShieXRlb2Zmc2V0LCBieXRlb2Zmc2V0ICsgbGVuKS50b1N0cmluZygndXRmOCcpO1xuICB9XG5cbiAgdmFyIHBhdHRlcm5sZW4gPSBwYXR0ZXJuLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7ICBpIDwgcGF0dGVybmxlbjsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBwYXR0ZXJuW2ldO1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAoc2VnbWVudC5uYW1lID09PSAnXycpIHtcbiAgICAgIHJlc3VsdCA9IHNraXBfYml0cyhzZWdtZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzd2l0Y2ggKHNlZ21lbnQudHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmVzdWx0ID0gZ2V0X3N0cmluZyhzZWdtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgcmVzdWx0ID0gZ2V0X2ludGVnZXIoc2VnbWVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICByZXN1bHQgPSBnZXRfZmxvYXQoc2VnbWVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmVzdWx0ID0gZ2V0X2JpbmFyeShzZWdtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlZ21lbnQubmFtZSkge1xuICAgICAgICB2YXJzW3NlZ21lbnQubmFtZV0gPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWdtZW50LnZhbHVlICE9IHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChvZmZzZXQgPT0gYmluc2l6ZSkge1xuICAgIHJldHVybiBiaW5kaW5ncyh2YXJzKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbm1vZHVsZS5leHBvcnRzLnBhcnNlX2ludCA9IHBhcnNlX2ludDtcbm1vZHVsZS5leHBvcnRzLnBhcnNlX2Zsb2F0ID0gcGFyc2VfZmxvYXQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bitsyntax/lib/interp.js\n");

/***/ }),

/***/ "./node_modules/bitsyntax/lib/parse.js":
/*!*********************************************!*\
  !*** ./node_modules/bitsyntax/lib/parse.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Parse patterns in string form into the form we use for interpreting\n// (and later, for compiling).\n\n\n\nvar ast = __webpack_require__(/*! ./pattern */ \"./node_modules/bitsyntax/lib/pattern.js\");\nvar parser = __webpack_require__(/*! ./parser */ \"./node_modules/bitsyntax/lib/parser.js\");\n\nfunction parse_pattern(string) {\n  var segments = parser.parse(string);\n  for (var i=0, len = segments.length; i < len; i++) {\n    var s = segments[i];\n    if (s.string != undefined) {\n      segments[i] = ast.string(s.string);\n    }\n    else if (s.value != undefined) {\n      segments[i] = ast.value(s.value, s.size, s.specifiers);\n    }\n    else if (s.name != undefined) {\n      segments[i] = ast.variable(s.name, s.size, s.specifiers);\n    }\n    else {\n      throw \"Unknown segment \" + s;\n    }\n  }\n  return segments;\n}\n\nmodule.exports.parse = function() {\n  var str = [].join.call(arguments, ',');\n  return parse_pattern(str);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0c3ludGF4L2xpYi9wYXJzZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iaXRzeW50YXgvbGliL3BhcnNlLmpzP2VlY2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUGFyc2UgcGF0dGVybnMgaW4gc3RyaW5nIGZvcm0gaW50byB0aGUgZm9ybSB3ZSB1c2UgZm9yIGludGVycHJldGluZ1xuLy8gKGFuZCBsYXRlciwgZm9yIGNvbXBpbGluZykuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzdCA9IHJlcXVpcmUoJy4vcGF0dGVybicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG5cbmZ1bmN0aW9uIHBhcnNlX3BhdHRlcm4oc3RyaW5nKSB7XG4gIHZhciBzZWdtZW50cyA9IHBhcnNlci5wYXJzZShzdHJpbmcpO1xuICBmb3IgKHZhciBpPTAsIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHMgPSBzZWdtZW50c1tpXTtcbiAgICBpZiAocy5zdHJpbmcgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZWdtZW50c1tpXSA9IGFzdC5zdHJpbmcocy5zdHJpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzLnZhbHVlICE9IHVuZGVmaW5lZCkge1xuICAgICAgc2VnbWVudHNbaV0gPSBhc3QudmFsdWUocy52YWx1ZSwgcy5zaXplLCBzLnNwZWNpZmllcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzLm5hbWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZWdtZW50c1tpXSA9IGFzdC52YXJpYWJsZShzLm5hbWUsIHMuc2l6ZSwgcy5zcGVjaWZpZXJzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBcIlVua25vd24gc2VnbWVudCBcIiArIHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWdtZW50cztcbn1cblxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0ciA9IFtdLmpvaW4uY2FsbChhcmd1bWVudHMsICcsJyk7XG4gIHJldHVybiBwYXJzZV9wYXR0ZXJuKHN0cik7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bitsyntax/lib/parse.js\n");

/***/ }),

/***/ "./node_modules/bitsyntax/lib/parser.js":
/*!**********************************************!*\
  !*** ./node_modules/bitsyntax/lib/parser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = (function(){\n  /*\n   * Generated by PEG.js 0.7.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n  \n  function quote(s) {\n    /*\n     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a\n     * string literal except for the closing quote character, backslash,\n     * carriage return, line separator, paragraph separator, and line feed.\n     * Any character may appear in the form of an escape sequence.\n     *\n     * For portability, we also escape escape all control and non-ASCII\n     * characters. Note that \"\\0\" and \"\\v\" escape sequences are not used\n     * because JSHint does not like the first and IE the second.\n     */\n     return '\"' + s\n      .replace(/\\\\/g, '\\\\\\\\')  // backslash\n      .replace(/\"/g, '\\\\\"')    // closing quote character\n      .replace(/\\x08/g, '\\\\b') // backspace\n      .replace(/\\t/g, '\\\\t')   // horizontal tab\n      .replace(/\\n/g, '\\\\n')   // line feed\n      .replace(/\\f/g, '\\\\f')   // form feed\n      .replace(/\\r/g, '\\\\r')   // carriage return\n      .replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape)\n      + '\"';\n  }\n  \n  var result = {\n    /*\n     * Parses the input with a generated parser. If the parsing is successfull,\n     * returns a value explicitly or implicitly specified by the grammar from\n     * which the parser was generated (see |PEG.buildParser|). If the parsing is\n     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.\n     */\n    parse: function(input, startRule) {\n      var parseFunctions = {\n        \"start\": parse_start,\n        \"segmentTail\": parse_segmentTail,\n        \"segment\": parse_segment,\n        \"string\": parse_string,\n        \"chars\": parse_chars,\n        \"char\": parse_char,\n        \"hexDigit\": parse_hexDigit,\n        \"identifier\": parse_identifier,\n        \"number\": parse_number,\n        \"size\": parse_size,\n        \"specifierList\": parse_specifierList,\n        \"specifierTail\": parse_specifierTail,\n        \"specifier\": parse_specifier,\n        \"unit\": parse_unit,\n        \"ws\": parse_ws\n      };\n      \n      if (startRule !== undefined) {\n        if (parseFunctions[startRule] === undefined) {\n          throw new Error(\"Invalid rule name: \" + quote(startRule) + \".\");\n        }\n      } else {\n        startRule = \"start\";\n      }\n      \n      var pos = 0;\n      var reportFailures = 0;\n      var rightmostFailuresPos = 0;\n      var rightmostFailuresExpected = [];\n      \n      function padLeft(input, padding, length) {\n        var result = input;\n        \n        var padLength = length - input.length;\n        for (var i = 0; i < padLength; i++) {\n          result = padding + result;\n        }\n        \n        return result;\n      }\n      \n      function escape(ch) {\n        var charCode = ch.charCodeAt(0);\n        var escapeChar;\n        var length;\n        \n        if (charCode <= 0xFF) {\n          escapeChar = 'x';\n          length = 2;\n        } else {\n          escapeChar = 'u';\n          length = 4;\n        }\n        \n        return '\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);\n      }\n      \n      function matchFailed(failure) {\n        if (pos < rightmostFailuresPos) {\n          return;\n        }\n        \n        if (pos > rightmostFailuresPos) {\n          rightmostFailuresPos = pos;\n          rightmostFailuresExpected = [];\n        }\n        \n        rightmostFailuresExpected.push(failure);\n      }\n      \n      function parse_start() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_ws();\n        if (result0 !== null) {\n          result1 = parse_segment();\n          if (result1 !== null) {\n            result2 = [];\n            result3 = parse_segmentTail();\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_segmentTail();\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, head, tail) { tail.unshift(head); return tail; })(pos0, result0[1], result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_segmentTail() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_ws();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 44) {\n            result1 = \",\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\",\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_ws();\n            if (result2 !== null) {\n              result3 = parse_segment();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, seg) { return seg; })(pos0, result0[3]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_segment() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        result0 = parse_string();\n        if (result0 !== null) {\n          result0 = (function(offset, str) { return {string: str}; })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          pos1 = pos;\n          result0 = parse_identifier();\n          if (result0 !== null) {\n            result1 = parse_size();\n            result1 = result1 !== null ? result1 : \"\";\n            if (result1 !== null) {\n              result2 = parse_specifierList();\n              result2 = result2 !== null ? result2 : \"\";\n              if (result2 !== null) {\n                result0 = [result0, result1, result2];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, v, size, specs) { return {name: v, size: size, specifiers: specs}; })(pos0, result0[0], result0[1], result0[2]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          if (result0 === null) {\n            pos0 = pos;\n            pos1 = pos;\n            result0 = parse_number();\n            if (result0 !== null) {\n              result1 = parse_size();\n              result1 = result1 !== null ? result1 : \"\";\n              if (result1 !== null) {\n                result2 = parse_specifierList();\n                result2 = result2 !== null ? result2 : \"\";\n                if (result2 !== null) {\n                  result0 = [result0, result1, result2];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n            if (result0 !== null) {\n              result0 = (function(offset, v, size, specs) { return {value: v, size: size, specifiers: specs}; })(pos0, result0[0], result0[1], result0[2]);\n            }\n            if (result0 === null) {\n              pos = pos0;\n            }\n          }\n        }\n        return result0;\n      }\n      \n      function parse_string() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 34) {\n          result0 = \"\\\"\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"\\\\\\\"\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 34) {\n            result1 = \"\\\"\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"\\\\\\\"\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) { return \"\";    })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 34) {\n            result0 = \"\\\"\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"\\\\\\\"\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            result1 = parse_chars();\n            if (result1 !== null) {\n              if (input.charCodeAt(pos) === 34) {\n                result2 = \"\\\"\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"\\\\\\\"\\\"\");\n                }\n              }\n              if (result2 !== null) {\n                result0 = [result0, result1, result2];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, chars) { return chars; })(pos0, result0[1]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n        }\n        return result0;\n      }\n      \n      function parse_chars() {\n        var result0, result1;\n        var pos0;\n        \n        pos0 = pos;\n        result1 = parse_char();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_char();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, chars) { return chars.join(\"\"); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_char() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1;\n        \n        if (/^[^\"\\\\\\0-\\x1F]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[^\\\"\\\\\\\\\\\\0-\\\\x1F]\");\n          }\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          if (input.substr(pos, 2) === \"\\\\\\\"\") {\n            result0 = \"\\\\\\\"\";\n            pos += 2;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"\\\\\\\\\\\\\\\"\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            result0 = (function(offset) { return '\"';  })(pos0);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          if (result0 === null) {\n            pos0 = pos;\n            if (input.substr(pos, 2) === \"\\\\\\\\\") {\n              result0 = \"\\\\\\\\\";\n              pos += 2;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"\\\\\\\\\\\\\\\\\\\"\");\n              }\n            }\n            if (result0 !== null) {\n              result0 = (function(offset) { return \"\\\\\"; })(pos0);\n            }\n            if (result0 === null) {\n              pos = pos0;\n            }\n            if (result0 === null) {\n              pos0 = pos;\n              if (input.substr(pos, 2) === \"\\\\/\") {\n                result0 = \"\\\\/\";\n                pos += 2;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"\\\\\\\\/\\\"\");\n                }\n              }\n              if (result0 !== null) {\n                result0 = (function(offset) { return \"/\";  })(pos0);\n              }\n              if (result0 === null) {\n                pos = pos0;\n              }\n              if (result0 === null) {\n                pos0 = pos;\n                if (input.substr(pos, 2) === \"\\\\b\") {\n                  result0 = \"\\\\b\";\n                  pos += 2;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"\\\\\\\\b\\\"\");\n                  }\n                }\n                if (result0 !== null) {\n                  result0 = (function(offset) { return \"\\b\"; })(pos0);\n                }\n                if (result0 === null) {\n                  pos = pos0;\n                }\n                if (result0 === null) {\n                  pos0 = pos;\n                  if (input.substr(pos, 2) === \"\\\\f\") {\n                    result0 = \"\\\\f\";\n                    pos += 2;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"\\\\\\\\f\\\"\");\n                    }\n                  }\n                  if (result0 !== null) {\n                    result0 = (function(offset) { return \"\\f\"; })(pos0);\n                  }\n                  if (result0 === null) {\n                    pos = pos0;\n                  }\n                  if (result0 === null) {\n                    pos0 = pos;\n                    if (input.substr(pos, 2) === \"\\\\n\") {\n                      result0 = \"\\\\n\";\n                      pos += 2;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"\\\\\\\\n\\\"\");\n                      }\n                    }\n                    if (result0 !== null) {\n                      result0 = (function(offset) { return \"\\n\"; })(pos0);\n                    }\n                    if (result0 === null) {\n                      pos = pos0;\n                    }\n                    if (result0 === null) {\n                      pos0 = pos;\n                      if (input.substr(pos, 2) === \"\\\\r\") {\n                        result0 = \"\\\\r\";\n                        pos += 2;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"\\\\\\\\r\\\"\");\n                        }\n                      }\n                      if (result0 !== null) {\n                        result0 = (function(offset) { return \"\\r\"; })(pos0);\n                      }\n                      if (result0 === null) {\n                        pos = pos0;\n                      }\n                      if (result0 === null) {\n                        pos0 = pos;\n                        if (input.substr(pos, 2) === \"\\\\t\") {\n                          result0 = \"\\\\t\";\n                          pos += 2;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"\\\\\\\\t\\\"\");\n                          }\n                        }\n                        if (result0 !== null) {\n                          result0 = (function(offset) { return \"\\t\"; })(pos0);\n                        }\n                        if (result0 === null) {\n                          pos = pos0;\n                        }\n                        if (result0 === null) {\n                          pos0 = pos;\n                          pos1 = pos;\n                          if (input.substr(pos, 2) === \"\\\\u\") {\n                            result0 = \"\\\\u\";\n                            pos += 2;\n                          } else {\n                            result0 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"\\\\\\\\u\\\"\");\n                            }\n                          }\n                          if (result0 !== null) {\n                            result1 = parse_hexDigit();\n                            if (result1 !== null) {\n                              result2 = parse_hexDigit();\n                              if (result2 !== null) {\n                                result3 = parse_hexDigit();\n                                if (result3 !== null) {\n                                  result4 = parse_hexDigit();\n                                  if (result4 !== null) {\n                                    result0 = [result0, result1, result2, result3, result4];\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                          if (result0 !== null) {\n                            result0 = (function(offset, h1, h2, h3, h4) {\n                                return String.fromCharCode(parseInt(\"0x\" + h1 + h2 + h3 + h4));\n                              })(pos0, result0[1], result0[2], result0[3], result0[4]);\n                          }\n                          if (result0 === null) {\n                            pos = pos0;\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      \n      function parse_hexDigit() {\n        var result0;\n        \n        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[0-9a-fA-F]\");\n          }\n        }\n        return result0;\n      }\n      \n      function parse_identifier() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        if (/^[_a-zA-Z]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[_a-zA-Z]\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = [];\n          if (/^[_a-zA-Z0-9]/.test(input.charAt(pos))) {\n            result2 = input.charAt(pos);\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[_a-zA-Z0-9]\");\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            if (/^[_a-zA-Z0-9]/.test(input.charAt(pos))) {\n              result2 = input.charAt(pos);\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[_a-zA-Z0-9]\");\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, head, tail) { return head + tail.join(''); })(pos0, result0[0], result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_number() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        if (input.charCodeAt(pos) === 48) {\n          result0 = \"0\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"0\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) { return 0; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          pos1 = pos;\n          if (/^[1-9]/.test(input.charAt(pos))) {\n            result0 = input.charAt(pos);\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[1-9]\");\n            }\n          }\n          if (result0 !== null) {\n            result1 = [];\n            if (/^[0-9]/.test(input.charAt(pos))) {\n              result2 = input.charAt(pos);\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[0-9]\");\n              }\n            }\n            while (result2 !== null) {\n              result1.push(result2);\n              if (/^[0-9]/.test(input.charAt(pos))) {\n                result2 = input.charAt(pos);\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"[0-9]\");\n                }\n              }\n            }\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, head, tail) { return parseInt(head + tail.join('')); })(pos0, result0[0], result0[1]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n        }\n        return result0;\n      }\n      \n      function parse_size() {\n        var result0, result1;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 58) {\n          result0 = \":\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\":\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_number();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, num) { return num; })(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 58) {\n            result0 = \":\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            result1 = parse_identifier();\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, id) { return id; })(pos0, result0[1]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n        }\n        return result0;\n      }\n      \n      function parse_specifierList() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 47) {\n          result0 = \"/\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"/\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_specifier();\n          if (result1 !== null) {\n            result2 = [];\n            result3 = parse_specifierTail();\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_specifierTail();\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, head, tail) { tail.unshift(head); return tail; })(pos0, result0[1], result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_specifierTail() {\n        var result0, result1;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 45) {\n          result0 = \"-\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"-\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_specifier();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, spec) { return spec; })(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_specifier() {\n        var result0;\n        \n        if (input.substr(pos, 6) === \"little\") {\n          result0 = \"little\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"little\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 3) === \"big\") {\n            result0 = \"big\";\n            pos += 3;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"big\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 6) === \"signed\") {\n              result0 = \"signed\";\n              pos += 6;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"signed\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 8) === \"unsigned\") {\n                result0 = \"unsigned\";\n                pos += 8;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"unsigned\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.substr(pos, 7) === \"integer\") {\n                  result0 = \"integer\";\n                  pos += 7;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"integer\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.substr(pos, 6) === \"binary\") {\n                    result0 = \"binary\";\n                    pos += 6;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"binary\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.substr(pos, 5) === \"float\") {\n                      result0 = \"float\";\n                      pos += 5;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"float\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      result0 = parse_unit();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      \n      function parse_unit() {\n        var result0, result1;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5) === \"unit:\") {\n          result0 = \"unit:\";\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"unit:\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_number();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, num) { return 'unit:' + num; })(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_ws() {\n        var result0, result1;\n        \n        result0 = [];\n        if (/^[ \\t\\n]/.test(input.charAt(pos))) {\n          result1 = input.charAt(pos);\n          pos++;\n        } else {\n          result1 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[ \\\\t\\\\n]\");\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          if (/^[ \\t\\n]/.test(input.charAt(pos))) {\n            result1 = input.charAt(pos);\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[ \\\\t\\\\n]\");\n            }\n          }\n        }\n        return result0;\n      }\n      \n      \n      function cleanupExpected(expected) {\n        expected.sort();\n        \n        var lastExpected = null;\n        var cleanExpected = [];\n        for (var i = 0; i < expected.length; i++) {\n          if (expected[i] !== lastExpected) {\n            cleanExpected.push(expected[i]);\n            lastExpected = expected[i];\n          }\n        }\n        return cleanExpected;\n      }\n      \n      function computeErrorPosition() {\n        /*\n         * The first idea was to use |String.split| to break the input up to the\n         * error position along newlines and derive the line and column from\n         * there. However IE's |split| implementation is so broken that it was\n         * enough to prevent it.\n         */\n        \n        var line = 1;\n        var column = 1;\n        var seenCR = false;\n        \n        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {\n          var ch = input.charAt(i);\n          if (ch === \"\\n\") {\n            if (!seenCR) { line++; }\n            column = 1;\n            seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            line++;\n            column = 1;\n            seenCR = true;\n          } else {\n            column++;\n            seenCR = false;\n          }\n        }\n        \n        return { line: line, column: column };\n      }\n      \n      \n      var result = parseFunctions[startRule]();\n      \n      /*\n       * The parser is now in one of the following three states:\n       *\n       * 1. The parser successfully parsed the whole input.\n       *\n       *    - |result !== null|\n       *    - |pos === input.length|\n       *    - |rightmostFailuresExpected| may or may not contain something\n       *\n       * 2. The parser successfully parsed only a part of the input.\n       *\n       *    - |result !== null|\n       *    - |pos < input.length|\n       *    - |rightmostFailuresExpected| may or may not contain something\n       *\n       * 3. The parser did not successfully parse any part of the input.\n       *\n       *   - |result === null|\n       *   - |pos === 0|\n       *   - |rightmostFailuresExpected| contains at least one failure\n       *\n       * All code following this comment (including called functions) must\n       * handle these states.\n       */\n      if (result === null || pos !== input.length) {\n        var offset = Math.max(pos, rightmostFailuresPos);\n        var found = offset < input.length ? input.charAt(offset) : null;\n        var errorPosition = computeErrorPosition();\n        \n        throw new this.SyntaxError(\n          cleanupExpected(rightmostFailuresExpected),\n          found,\n          offset,\n          errorPosition.line,\n          errorPosition.column\n        );\n      }\n      \n      return result;\n    },\n    \n    /* Returns the parser source code. */\n    toSource: function() { return this._source; }\n  };\n  \n  /* Thrown when a parser encounters a syntax error. */\n  \n  result.SyntaxError = function(expected, found, offset, line, column) {\n    function buildMessage(expected, found) {\n      var expectedHumanized, foundHumanized;\n      \n      switch (expected.length) {\n        case 0:\n          expectedHumanized = \"end of input\";\n          break;\n        case 1:\n          expectedHumanized = expected[0];\n          break;\n        default:\n          expectedHumanized = expected.slice(0, expected.length - 1).join(\", \")\n            + \" or \"\n            + expected[expected.length - 1];\n      }\n      \n      foundHumanized = found ? quote(found) : \"end of input\";\n      \n      return \"Expected \" + expectedHumanized + \" but \" + foundHumanized + \" found.\";\n    }\n    \n    this.name = \"SyntaxError\";\n    this.expected = expected;\n    this.found = found;\n    this.message = buildMessage(expected, found);\n    this.offset = offset;\n    this.line = line;\n    this.column = column;\n  };\n  \n  result.SyntaxError.prototype = Error.prototype;\n  \n  return result;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0c3ludGF4L2xpYi9wYXJzZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYml0c3ludGF4L2xpYi9wYXJzZXIuanM/ZDI2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpe1xuICAvKlxuICAgKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuNy4wLlxuICAgKlxuICAgKiBodHRwOi8vcGVnanMubWFqZGEuY3ovXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gcXVvdGUocykge1xuICAgIC8qXG4gICAgICogRUNNQS0yNjIsIDV0aCBlZC4sIDcuOC40OiBBbGwgY2hhcmFjdGVycyBtYXkgYXBwZWFyIGxpdGVyYWxseSBpbiBhXG4gICAgICogc3RyaW5nIGxpdGVyYWwgZXhjZXB0IGZvciB0aGUgY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXIsIGJhY2tzbGFzaCxcbiAgICAgKiBjYXJyaWFnZSByZXR1cm4sIGxpbmUgc2VwYXJhdG9yLCBwYXJhZ3JhcGggc2VwYXJhdG9yLCBhbmQgbGluZSBmZWVkLlxuICAgICAqIEFueSBjaGFyYWN0ZXIgbWF5IGFwcGVhciBpbiB0aGUgZm9ybSBvZiBhbiBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBGb3IgcG9ydGFiaWxpdHksIHdlIGFsc28gZXNjYXBlIGVzY2FwZSBhbGwgY29udHJvbCBhbmQgbm9uLUFTQ0lJXG4gICAgICogY2hhcmFjdGVycy4gTm90ZSB0aGF0IFwiXFwwXCIgYW5kIFwiXFx2XCIgZXNjYXBlIHNlcXVlbmNlcyBhcmUgbm90IHVzZWRcbiAgICAgKiBiZWNhdXNlIEpTSGludCBkb2VzIG5vdCBsaWtlIHRoZSBmaXJzdCBhbmQgSUUgdGhlIHNlY29uZC5cbiAgICAgKi9cbiAgICAgcmV0dXJuICdcIicgKyBzXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKSAgLy8gYmFja3NsYXNoXG4gICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICAgIC8vIGNsb3NpbmcgcXVvdGUgY2hhcmFjdGVyXG4gICAgICAucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFxiJykgLy8gYmFja3NwYWNlXG4gICAgICAucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpICAgLy8gaG9yaXpvbnRhbCB0YWJcbiAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgICAvLyBsaW5lIGZlZWRcbiAgICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJykgICAvLyBmb3JtIGZlZWRcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykgICAvLyBjYXJyaWFnZSByZXR1cm5cbiAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFLVxceDFGXFx4ODAtXFx1RkZGRl0vZywgZXNjYXBlKVxuICAgICAgKyAnXCInO1xuICB9XG4gIFxuICB2YXIgcmVzdWx0ID0ge1xuICAgIC8qXG4gICAgICogUGFyc2VzIHRoZSBpbnB1dCB3aXRoIGEgZ2VuZXJhdGVkIHBhcnNlci4gSWYgdGhlIHBhcnNpbmcgaXMgc3VjY2Vzc2Z1bGwsXG4gICAgICogcmV0dXJucyBhIHZhbHVlIGV4cGxpY2l0bHkgb3IgaW1wbGljaXRseSBzcGVjaWZpZWQgYnkgdGhlIGdyYW1tYXIgZnJvbVxuICAgICAqIHdoaWNoIHRoZSBwYXJzZXIgd2FzIGdlbmVyYXRlZCAoc2VlIHxQRUcuYnVpbGRQYXJzZXJ8KS4gSWYgdGhlIHBhcnNpbmcgaXNcbiAgICAgKiB1bnN1Y2Nlc3NmdWwsIHRocm93cyB8UEVHLnBhcnNlci5TeW50YXhFcnJvcnwgZGVzY3JpYmluZyB0aGUgZXJyb3IuXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0LCBzdGFydFJ1bGUpIHtcbiAgICAgIHZhciBwYXJzZUZ1bmN0aW9ucyA9IHtcbiAgICAgICAgXCJzdGFydFwiOiBwYXJzZV9zdGFydCxcbiAgICAgICAgXCJzZWdtZW50VGFpbFwiOiBwYXJzZV9zZWdtZW50VGFpbCxcbiAgICAgICAgXCJzZWdtZW50XCI6IHBhcnNlX3NlZ21lbnQsXG4gICAgICAgIFwic3RyaW5nXCI6IHBhcnNlX3N0cmluZyxcbiAgICAgICAgXCJjaGFyc1wiOiBwYXJzZV9jaGFycyxcbiAgICAgICAgXCJjaGFyXCI6IHBhcnNlX2NoYXIsXG4gICAgICAgIFwiaGV4RGlnaXRcIjogcGFyc2VfaGV4RGlnaXQsXG4gICAgICAgIFwiaWRlbnRpZmllclwiOiBwYXJzZV9pZGVudGlmaWVyLFxuICAgICAgICBcIm51bWJlclwiOiBwYXJzZV9udW1iZXIsXG4gICAgICAgIFwic2l6ZVwiOiBwYXJzZV9zaXplLFxuICAgICAgICBcInNwZWNpZmllckxpc3RcIjogcGFyc2Vfc3BlY2lmaWVyTGlzdCxcbiAgICAgICAgXCJzcGVjaWZpZXJUYWlsXCI6IHBhcnNlX3NwZWNpZmllclRhaWwsXG4gICAgICAgIFwic3BlY2lmaWVyXCI6IHBhcnNlX3NwZWNpZmllcixcbiAgICAgICAgXCJ1bml0XCI6IHBhcnNlX3VuaXQsXG4gICAgICAgIFwid3NcIjogcGFyc2Vfd3NcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGlmIChzdGFydFJ1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocGFyc2VGdW5jdGlvbnNbc3RhcnRSdWxlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBydWxlIG5hbWU6IFwiICsgcXVvdGUoc3RhcnRSdWxlKSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRSdWxlID0gXCJzdGFydFwiO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHZhciByZXBvcnRGYWlsdXJlcyA9IDA7XG4gICAgICB2YXIgcmlnaHRtb3N0RmFpbHVyZXNQb3MgPSAwO1xuICAgICAgdmFyIHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQgPSBbXTtcbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFkTGVmdChpbnB1dCwgcGFkZGluZywgbGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBpbnB1dDtcbiAgICAgICAgXG4gICAgICAgIHZhciBwYWRMZW5ndGggPSBsZW5ndGggLSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXN1bHQgPSBwYWRkaW5nICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBlc2NhcGUoY2gpIHtcbiAgICAgICAgdmFyIGNoYXJDb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgdmFyIGVzY2FwZUNoYXI7XG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2hhckNvZGUgPD0gMHhGRikge1xuICAgICAgICAgIGVzY2FwZUNoYXIgPSAneCc7XG4gICAgICAgICAgbGVuZ3RoID0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlc2NhcGVDaGFyID0gJ3UnO1xuICAgICAgICAgIGxlbmd0aCA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVDaGFyICsgcGFkTGVmdChjaGFyQ29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSwgJzAnLCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBtYXRjaEZhaWxlZChmYWlsdXJlKSB7XG4gICAgICAgIGlmIChwb3MgPCByaWdodG1vc3RGYWlsdXJlc1Bvcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHBvcyA+IHJpZ2h0bW9zdEZhaWx1cmVzUG9zKSB7XG4gICAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXNQb3MgPSBwb3M7XG4gICAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkLnB1c2goZmFpbHVyZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3N0YXJ0KCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MztcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2Vfd3MoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfc2VnbWVudCgpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gW107XG4gICAgICAgICAgICByZXN1bHQzID0gcGFyc2Vfc2VnbWVudFRhaWwoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaChyZXN1bHQzKTtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX3NlZ21lbnRUYWlsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBoZWFkLCB0YWlsKSB7IHRhaWwudW5zaGlmdChoZWFkKTsgcmV0dXJuIHRhaWw7IH0pKHBvczAsIHJlc3VsdDBbMV0sIHJlc3VsdDBbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2VnbWVudFRhaWwoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV93cygpO1xuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICByZXN1bHQxID0gXCIsXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiLFxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcGFyc2Vfd3MoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9zZWdtZW50KCk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIHNlZykgeyByZXR1cm4gc2VnOyB9KShwb3MwLCByZXN1bHQwWzNdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NlZ21lbnQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHJlc3VsdDAgPSBwYXJzZV9zdHJpbmcoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgc3RyKSB7IHJldHVybiB7c3RyaW5nOiBzdHJ9OyB9KShwb3MwLCByZXN1bHQwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX2lkZW50aWZpZXIoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3NpemUoKTtcbiAgICAgICAgICAgIHJlc3VsdDEgPSByZXN1bHQxICE9PSBudWxsID8gcmVzdWx0MSA6IFwiXCI7XG4gICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2Vfc3BlY2lmaWVyTGlzdCgpO1xuICAgICAgICAgICAgICByZXN1bHQyID0gcmVzdWx0MiAhPT0gbnVsbCA/IHJlc3VsdDIgOiBcIlwiO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCB2LCBzaXplLCBzcGVjcykgeyByZXR1cm4ge25hbWU6IHYsIHNpemU6IHNpemUsIHNwZWNpZmllcnM6IHNwZWNzfTsgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsxXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfbnVtYmVyKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfc2l6ZSgpO1xuICAgICAgICAgICAgICByZXN1bHQxID0gcmVzdWx0MSAhPT0gbnVsbCA/IHJlc3VsdDEgOiBcIlwiO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBwYXJzZV9zcGVjaWZpZXJMaXN0KCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IHJlc3VsdDIgIT09IG51bGwgPyByZXN1bHQyIDogXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCB2LCBzaXplLCBzcGVjcykgeyByZXR1cm4ge3ZhbHVlOiB2LCBzaXplOiBzaXplLCBzcGVjaWZpZXJzOiBzcGVjc307IH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0sIHJlc3VsdDBbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3N0cmluZygpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJcXFwiXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcIlxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBcIlxcXCJcIjtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcIlxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCJcIjsgICAgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM0KSB7XG4gICAgICAgICAgICByZXN1bHQwID0gXCJcXFwiXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXCJcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2NoYXJzKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzNCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBcIlxcXCJcIjtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgY2hhcnMpIHsgcmV0dXJuIGNoYXJzOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9jaGFycygpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2NoYXIoKTtcbiAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gW107XG4gICAgICAgICAgd2hpbGUgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAucHVzaChyZXN1bHQxKTtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9jaGFyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNoYXJzKSB7IHJldHVybiBjaGFycy5qb2luKFwiXCIpOyB9KShwb3MwLCByZXN1bHQwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2NoYXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzLCByZXN1bHQ0O1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIGlmICgvXlteXCJcXFxcXFwwLVxceDFGf10vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbXlxcXCJcXFxcXFxcXFxcXFwwLVxcXFx4MUZ/XVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcXFxcIlwiKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcXFxcIlwiO1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcXFxcXFxcXCJcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuICdcIic7ICB9KShwb3MwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFxcXFxcXCIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXFxcXFxcIjtcbiAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFxcXFxcXFxcXFxcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIlxcXFxcIjsgfSkocG9zMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFwvXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcL1wiO1xuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFwvXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCIvXCI7ICB9KShwb3MwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcYlwiKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcYlwiO1xuICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcYlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCJcXGJcIjsgfSkocG9zMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFxmXCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcZlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIlxcZlwiOyB9KShwb3MwKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXG5cXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIlxcblwiOyB9KShwb3MwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcclxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCJcXHJcIjsgfSkocG9zMCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFx0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcdFxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiBcIlxcdFwiOyB9KShwb3MwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXHVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFx1XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXHVcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2VfaGV4RGlnaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDQgPSBwYXJzZV9oZXhEaWdpdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDMsIHJlc3VsdDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaDEsIGgyLCBoMywgaDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoXCIweFwiICsgaDEgKyBoMiArIGgzICsgaDQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKHBvczAsIHJlc3VsdDBbMV0sIHJlc3VsdDBbMl0sIHJlc3VsdDBbM10sIHJlc3VsdDBbNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfaGV4RGlnaXQoKSB7XG4gICAgICAgIHZhciByZXN1bHQwO1xuICAgICAgICBcbiAgICAgICAgaWYgKC9eWzAtOWEtZkEtRl0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbMC05YS1mQS1GXVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2lkZW50aWZpZXIoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmICgvXltfYS16QS1aXS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICByZXN1bHQwID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIltfYS16QS1aXVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gW107XG4gICAgICAgICAgaWYgKC9eW19hLXpBLVowLTldLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW19hLXpBLVowLTldXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MS5wdXNoKHJlc3VsdDIpO1xuICAgICAgICAgICAgaWYgKC9eW19hLXpBLVowLTldLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW19hLXpBLVowLTldXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaGVhZCwgdGFpbCkgeyByZXR1cm4gaGVhZCArIHRhaWwuam9pbignJyk7IH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfbnVtYmVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0OCkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIjBcIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIjBcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiAwOyB9KShwb3MwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgICAgaWYgKC9eWzEtOV0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbMS05XVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBbXTtcbiAgICAgICAgICAgIGlmICgvXlswLTldLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiWzAtOV1cIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDEucHVzaChyZXN1bHQyKTtcbiAgICAgICAgICAgICAgaWYgKC9eWzAtOV0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbMC05XVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGhlYWQsIHRhaWwpIHsgcmV0dXJuIHBhcnNlSW50KGhlYWQgKyB0YWlsLmpvaW4oJycpKTsgfSkocG9zMCwgcmVzdWx0MFswXSwgcmVzdWx0MFsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc2l6ZSgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCI6XCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCI6XFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2VfbnVtYmVyKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBudW0pIHsgcmV0dXJuIG51bTsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDU4KSB7XG4gICAgICAgICAgICByZXN1bHQwID0gXCI6XCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiOlxcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfaWRlbnRpZmllcigpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaWQpIHsgcmV0dXJuIGlkOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zcGVjaWZpZXJMaXN0KCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MztcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0Nykge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIi9cIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIi9cXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9zcGVjaWZpZXIoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IFtdO1xuICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX3NwZWNpZmllclRhaWwoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZXN1bHQzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaChyZXN1bHQzKTtcbiAgICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX3NwZWNpZmllclRhaWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGhlYWQsIHRhaWwpIHsgdGFpbC51bnNoaWZ0KGhlYWQpOyByZXR1cm4gdGFpbDsgfSkocG9zMCwgcmVzdWx0MFsxXSwgcmVzdWx0MFsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zcGVjaWZpZXJUYWlsKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0NSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBcIi1cIjtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIi1cXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9zcGVjaWZpZXIoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIHNwZWMpIHsgcmV0dXJuIHNwZWM7IH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc3BlY2lmaWVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCA2KSA9PT0gXCJsaXR0bGVcIikge1xuICAgICAgICAgIHJlc3VsdDAgPSBcImxpdHRsZVwiO1xuICAgICAgICAgIHBvcyArPSA2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwibGl0dGxlXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMykgPT09IFwiYmlnXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBcImJpZ1wiO1xuICAgICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcImJpZ1xcXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgNikgPT09IFwic2lnbmVkXCIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFwic2lnbmVkXCI7XG4gICAgICAgICAgICAgIHBvcyArPSA2O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcInNpZ25lZFxcXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCA4KSA9PT0gXCJ1bnNpZ25lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwidW5zaWduZWRcIjtcbiAgICAgICAgICAgICAgICBwb3MgKz0gODtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcInVuc2lnbmVkXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgNykgPT09IFwiaW50ZWdlclwiKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJpbnRlZ2VyXCI7XG4gICAgICAgICAgICAgICAgICBwb3MgKz0gNztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiaW50ZWdlclxcXCJcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgNikgPT09IFwiYmluYXJ5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiYmluYXJ5XCI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyArPSA2O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcImJpbmFyeVxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCA1KSA9PT0gXCJmbG9hdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiZmxvYXRcIjtcbiAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcImZsb2F0XFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gcGFyc2VfdW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV91bml0KCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgNSkgPT09IFwidW5pdDpcIikge1xuICAgICAgICAgIHJlc3VsdDAgPSBcInVuaXQ6XCI7XG4gICAgICAgICAgcG9zICs9IDU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJ1bml0OlxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX251bWJlcigpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgbnVtKSB7IHJldHVybiAndW5pdDonICsgbnVtOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3dzKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MTtcbiAgICAgICAgXG4gICAgICAgIHJlc3VsdDAgPSBbXTtcbiAgICAgICAgaWYgKC9eWyBcXHRcXG5dLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHJlc3VsdDEgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiWyBcXFxcdFxcXFxuXVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwLnB1c2gocmVzdWx0MSk7XG4gICAgICAgICAgaWYgKC9eWyBcXHRcXG5dLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiWyBcXFxcdFxcXFxuXVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIFxuICAgICAgZnVuY3Rpb24gY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKSB7XG4gICAgICAgIGV4cGVjdGVkLnNvcnQoKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBsYXN0RXhwZWN0ZWQgPSBudWxsO1xuICAgICAgICB2YXIgY2xlYW5FeHBlY3RlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkW2ldICE9PSBsYXN0RXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIGNsZWFuRXhwZWN0ZWQucHVzaChleHBlY3RlZFtpXSk7XG4gICAgICAgICAgICBsYXN0RXhwZWN0ZWQgPSBleHBlY3RlZFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsZWFuRXhwZWN0ZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGNvbXB1dGVFcnJvclBvc2l0aW9uKCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBUaGUgZmlyc3QgaWRlYSB3YXMgdG8gdXNlIHxTdHJpbmcuc3BsaXR8IHRvIGJyZWFrIHRoZSBpbnB1dCB1cCB0byB0aGVcbiAgICAgICAgICogZXJyb3IgcG9zaXRpb24gYWxvbmcgbmV3bGluZXMgYW5kIGRlcml2ZSB0aGUgbGluZSBhbmQgY29sdW1uIGZyb21cbiAgICAgICAgICogdGhlcmUuIEhvd2V2ZXIgSUUncyB8c3BsaXR8IGltcGxlbWVudGF0aW9uIGlzIHNvIGJyb2tlbiB0aGF0IGl0IHdhc1xuICAgICAgICAgKiBlbm91Z2ggdG8gcHJldmVudCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIFxuICAgICAgICB2YXIgbGluZSA9IDE7XG4gICAgICAgIHZhciBjb2x1bW4gPSAxO1xuICAgICAgICB2YXIgc2VlbkNSID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWF4KHBvcywgcmlnaHRtb3N0RmFpbHVyZXNQb3MpOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2ggPSBpbnB1dC5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKGNoID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICBpZiAoIXNlZW5DUikgeyBsaW5lKys7IH1cbiAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICBzZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcclwiIHx8IGNoID09PSBcIlxcdTIwMjhcIiB8fCBjaCA9PT0gXCJcXHUyMDI5XCIpIHtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICBzZWVuQ1IgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4rKztcbiAgICAgICAgICAgIHNlZW5DUiA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgbGluZTogbGluZSwgY29sdW1uOiBjb2x1bW4gfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGdW5jdGlvbnNbc3RhcnRSdWxlXSgpO1xuICAgICAgXG4gICAgICAvKlxuICAgICAgICogVGhlIHBhcnNlciBpcyBub3cgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgdGhyZWUgc3RhdGVzOlxuICAgICAgICpcbiAgICAgICAqIDEuIFRoZSBwYXJzZXIgc3VjY2Vzc2Z1bGx5IHBhcnNlZCB0aGUgd2hvbGUgaW5wdXQuXG4gICAgICAgKlxuICAgICAgICogICAgLSB8cmVzdWx0ICE9PSBudWxsfFxuICAgICAgICogICAgLSB8cG9zID09PSBpbnB1dC5sZW5ndGh8XG4gICAgICAgKiAgICAtIHxyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkfCBtYXkgb3IgbWF5IG5vdCBjb250YWluIHNvbWV0aGluZ1xuICAgICAgICpcbiAgICAgICAqIDIuIFRoZSBwYXJzZXIgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBvbmx5IGEgcGFydCBvZiB0aGUgaW5wdXQuXG4gICAgICAgKlxuICAgICAgICogICAgLSB8cmVzdWx0ICE9PSBudWxsfFxuICAgICAgICogICAgLSB8cG9zIDwgaW5wdXQubGVuZ3RofFxuICAgICAgICogICAgLSB8cmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZHwgbWF5IG9yIG1heSBub3QgY29udGFpbiBzb21ldGhpbmdcbiAgICAgICAqXG4gICAgICAgKiAzLiBUaGUgcGFyc2VyIGRpZCBub3Qgc3VjY2Vzc2Z1bGx5IHBhcnNlIGFueSBwYXJ0IG9mIHRoZSBpbnB1dC5cbiAgICAgICAqXG4gICAgICAgKiAgIC0gfHJlc3VsdCA9PT0gbnVsbHxcbiAgICAgICAqICAgLSB8cG9zID09PSAwfFxuICAgICAgICogICAtIHxyaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkfCBjb250YWlucyBhdCBsZWFzdCBvbmUgZmFpbHVyZVxuICAgICAgICpcbiAgICAgICAqIEFsbCBjb2RlIGZvbGxvd2luZyB0aGlzIGNvbW1lbnQgKGluY2x1ZGluZyBjYWxsZWQgZnVuY3Rpb25zKSBtdXN0XG4gICAgICAgKiBoYW5kbGUgdGhlc2Ugc3RhdGVzLlxuICAgICAgICovXG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHBvcyAhPT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBNYXRoLm1heChwb3MsIHJpZ2h0bW9zdEZhaWx1cmVzUG9zKTtcbiAgICAgICAgdmFyIGZvdW5kID0gb2Zmc2V0IDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KG9mZnNldCkgOiBudWxsO1xuICAgICAgICB2YXIgZXJyb3JQb3NpdGlvbiA9IGNvbXB1dGVFcnJvclBvc2l0aW9uKCk7XG4gICAgICAgIFxuICAgICAgICB0aHJvdyBuZXcgdGhpcy5TeW50YXhFcnJvcihcbiAgICAgICAgICBjbGVhbnVwRXhwZWN0ZWQocmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZCksXG4gICAgICAgICAgZm91bmQsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIGVycm9yUG9zaXRpb24ubGluZSxcbiAgICAgICAgICBlcnJvclBvc2l0aW9uLmNvbHVtblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgXG4gICAgLyogUmV0dXJucyB0aGUgcGFyc2VyIHNvdXJjZSBjb2RlLiAqL1xuICAgIHRvU291cmNlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3NvdXJjZTsgfVxuICB9O1xuICBcbiAgLyogVGhyb3duIHdoZW4gYSBwYXJzZXIgZW5jb3VudGVycyBhIHN5bnRheCBlcnJvci4gKi9cbiAgXG4gIHJlc3VsdC5TeW50YXhFcnJvciA9IGZ1bmN0aW9uKGV4cGVjdGVkLCBmb3VuZCwgb2Zmc2V0LCBsaW5lLCBjb2x1bW4pIHtcbiAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7XG4gICAgICB2YXIgZXhwZWN0ZWRIdW1hbml6ZWQsIGZvdW5kSHVtYW5pemVkO1xuICAgICAgXG4gICAgICBzd2l0Y2ggKGV4cGVjdGVkLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgZXhwZWN0ZWRIdW1hbml6ZWQgPSBcImVuZCBvZiBpbnB1dFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgZXhwZWN0ZWRIdW1hbml6ZWQgPSBleHBlY3RlZFswXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBleHBlY3RlZEh1bWFuaXplZCA9IGV4cGVjdGVkLnNsaWNlKDAsIGV4cGVjdGVkLmxlbmd0aCAtIDEpLmpvaW4oXCIsIFwiKVxuICAgICAgICAgICAgKyBcIiBvciBcIlxuICAgICAgICAgICAgKyBleHBlY3RlZFtleHBlY3RlZC5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm91bmRIdW1hbml6ZWQgPSBmb3VuZCA/IHF1b3RlKGZvdW5kKSA6IFwiZW5kIG9mIGlucHV0XCI7XG4gICAgICBcbiAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWRIdW1hbml6ZWQgKyBcIiBidXQgXCIgKyBmb3VuZEh1bWFuaXplZCArIFwiIGZvdW5kLlwiO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLm5hbWUgPSBcIlN5bnRheEVycm9yXCI7XG4gICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgIHRoaXMuZm91bmQgPSBmb3VuZDtcbiAgICB0aGlzLm1lc3NhZ2UgPSBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICB9O1xuICBcbiAgcmVzdWx0LlN5bnRheEVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbiAgXG4gIHJldHVybiByZXN1bHQ7XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bitsyntax/lib/parser.js\n");

/***/ }),

/***/ "./node_modules/bitsyntax/lib/pattern.js":
/*!***********************************************!*\
  !*** ./node_modules/bitsyntax/lib/pattern.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// -*- js-indent-level: 2 -*-\n// Constructing patterns\n\n\n\nfunction set(values) {\n  var s = {};\n  for (var i in values) {\n    s[values[i]] = 1;\n  }\n  return s;\n}\n\n// Construct a segment bound to a variable, e.g., from a segment like\n// \"Len:32/unsigned-big\". `specifiers0` is an array.\nfunction variable(name, size, specifiers0) {\n  var specifiers = set(specifiers0);\n  var segment = {name: name};\n  segment.type = type_in(specifiers);\n  specs(segment, segment.type, specifiers);\n  segment.size = size_of(segment, segment.type, size, segment.unit);\n  return segment;\n}\n\nmodule.exports.variable = variable;\nmodule.exports.rest = function() {\n  return variable('_', true, ['binary']);\n}\n\n// Construct a segment with a literal value, e.g., from a segment like\n// \"206\". `specifiers0` is an array.\n\nfunction value(val, size, specifiers0) {\n  var specifiers = set(specifiers0);\n  var segment = {value: val};\n  segment.type = type_in(specifiers);\n  // TODO check type v. value ..\n  specs(segment, segment.type, specifiers);\n  segment.size = size_of(segment, segment.type, size, segment.unit);\n  return segment;\n}\n\nmodule.exports.value = value;\n\n// A string can appear as a literal, but it must appear without\n// specifiers.\nfunction string(val) {\n  return {value: val, type: 'string'};\n}\nmodule.exports.string = string;\n\nvar TYPES = {'integer': 1, 'binary': 1, 'float': 1};\nfunction type_in(specifiers) {\n  for (var t in specifiers) {\n    if (TYPES[t]) { return t; }\n  }\n  return 'integer';\n}\n\nfunction specs(segment, type, specifiers) {\n  switch (type) {\n  case 'integer':\n    segment.signed = signed_in(specifiers);\n    // fall through\n  case 'float':\n    segment.bigendian = endian_in(specifiers);\n    // fall through\n  default:\n    segment.unit = unit_in(specifiers, segment.type);\n  }\n  return segment;\n}\n\nfunction endian_in(specifiers) {\n  // default is big, but I have chosen true = bigendian\n  return !specifiers['little'];\n}\n\nfunction signed_in(specifiers) {\n  // this time I got it right; default is unsigned\n  return specifiers['signed'];\n}\n\nfunction unit_in(specifiers, type) {\n  for (var s in specifiers) {\n    if (s.substr(0, 5) == 'unit:') {\n      var unit = parseInt(s.substr(5));\n      // TODO check sane for type\n      return unit;\n    }\n  }\n  // OK defaults then\n  switch (type) {\n  case 'binary':\n    return 8;\n  case 'integer':\n  case 'float':\n    return 1;\n  }\n}\n\nfunction size_of(segment, type, size, unit) {\n  if (size !== undefined && size !== '') {\n    return size;\n  }\n  else {\n    switch (type) {\n    case 'integer':\n      return 8;\n    case 'float':\n      return 64;\n    case 'binary':\n      return true;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0c3ludGF4L2xpYi9wYXR0ZXJuLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JpdHN5bnRheC9saWIvcGF0dGVybi5qcz9hYTZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIC0qLSBqcy1pbmRlbnQtbGV2ZWw6IDIgLSotXG4vLyBDb25zdHJ1Y3RpbmcgcGF0dGVybnNcblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBzZXQodmFsdWVzKSB7XG4gIHZhciBzID0ge307XG4gIGZvciAodmFyIGkgaW4gdmFsdWVzKSB7XG4gICAgc1t2YWx1ZXNbaV1dID0gMTtcbiAgfVxuICByZXR1cm4gcztcbn1cblxuLy8gQ29uc3RydWN0IGEgc2VnbWVudCBib3VuZCB0byBhIHZhcmlhYmxlLCBlLmcuLCBmcm9tIGEgc2VnbWVudCBsaWtlXG4vLyBcIkxlbjozMi91bnNpZ25lZC1iaWdcIi4gYHNwZWNpZmllcnMwYCBpcyBhbiBhcnJheS5cbmZ1bmN0aW9uIHZhcmlhYmxlKG5hbWUsIHNpemUsIHNwZWNpZmllcnMwKSB7XG4gIHZhciBzcGVjaWZpZXJzID0gc2V0KHNwZWNpZmllcnMwKTtcbiAgdmFyIHNlZ21lbnQgPSB7bmFtZTogbmFtZX07XG4gIHNlZ21lbnQudHlwZSA9IHR5cGVfaW4oc3BlY2lmaWVycyk7XG4gIHNwZWNzKHNlZ21lbnQsIHNlZ21lbnQudHlwZSwgc3BlY2lmaWVycyk7XG4gIHNlZ21lbnQuc2l6ZSA9IHNpemVfb2Yoc2VnbWVudCwgc2VnbWVudC50eXBlLCBzaXplLCBzZWdtZW50LnVuaXQpO1xuICByZXR1cm4gc2VnbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMudmFyaWFibGUgPSB2YXJpYWJsZTtcbm1vZHVsZS5leHBvcnRzLnJlc3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHZhcmlhYmxlKCdfJywgdHJ1ZSwgWydiaW5hcnknXSk7XG59XG5cbi8vIENvbnN0cnVjdCBhIHNlZ21lbnQgd2l0aCBhIGxpdGVyYWwgdmFsdWUsIGUuZy4sIGZyb20gYSBzZWdtZW50IGxpa2Vcbi8vIFwiMjA2XCIuIGBzcGVjaWZpZXJzMGAgaXMgYW4gYXJyYXkuXG5cbmZ1bmN0aW9uIHZhbHVlKHZhbCwgc2l6ZSwgc3BlY2lmaWVyczApIHtcbiAgdmFyIHNwZWNpZmllcnMgPSBzZXQoc3BlY2lmaWVyczApO1xuICB2YXIgc2VnbWVudCA9IHt2YWx1ZTogdmFsfTtcbiAgc2VnbWVudC50eXBlID0gdHlwZV9pbihzcGVjaWZpZXJzKTtcbiAgLy8gVE9ETyBjaGVjayB0eXBlIHYuIHZhbHVlIC4uXG4gIHNwZWNzKHNlZ21lbnQsIHNlZ21lbnQudHlwZSwgc3BlY2lmaWVycyk7XG4gIHNlZ21lbnQuc2l6ZSA9IHNpemVfb2Yoc2VnbWVudCwgc2VnbWVudC50eXBlLCBzaXplLCBzZWdtZW50LnVuaXQpO1xuICByZXR1cm4gc2VnbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMudmFsdWUgPSB2YWx1ZTtcblxuLy8gQSBzdHJpbmcgY2FuIGFwcGVhciBhcyBhIGxpdGVyYWwsIGJ1dCBpdCBtdXN0IGFwcGVhciB3aXRob3V0XG4vLyBzcGVjaWZpZXJzLlxuZnVuY3Rpb24gc3RyaW5nKHZhbCkge1xuICByZXR1cm4ge3ZhbHVlOiB2YWwsIHR5cGU6ICdzdHJpbmcnfTtcbn1cbm1vZHVsZS5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcblxudmFyIFRZUEVTID0geydpbnRlZ2VyJzogMSwgJ2JpbmFyeSc6IDEsICdmbG9hdCc6IDF9O1xuZnVuY3Rpb24gdHlwZV9pbihzcGVjaWZpZXJzKSB7XG4gIGZvciAodmFyIHQgaW4gc3BlY2lmaWVycykge1xuICAgIGlmIChUWVBFU1t0XSkgeyByZXR1cm4gdDsgfVxuICB9XG4gIHJldHVybiAnaW50ZWdlcic7XG59XG5cbmZ1bmN0aW9uIHNwZWNzKHNlZ21lbnQsIHR5cGUsIHNwZWNpZmllcnMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gIGNhc2UgJ2ludGVnZXInOlxuICAgIHNlZ21lbnQuc2lnbmVkID0gc2lnbmVkX2luKHNwZWNpZmllcnMpO1xuICAgIC8vIGZhbGwgdGhyb3VnaFxuICBjYXNlICdmbG9hdCc6XG4gICAgc2VnbWVudC5iaWdlbmRpYW4gPSBlbmRpYW5faW4oc3BlY2lmaWVycyk7XG4gICAgLy8gZmFsbCB0aHJvdWdoXG4gIGRlZmF1bHQ6XG4gICAgc2VnbWVudC51bml0ID0gdW5pdF9pbihzcGVjaWZpZXJzLCBzZWdtZW50LnR5cGUpO1xuICB9XG4gIHJldHVybiBzZWdtZW50O1xufVxuXG5mdW5jdGlvbiBlbmRpYW5faW4oc3BlY2lmaWVycykge1xuICAvLyBkZWZhdWx0IGlzIGJpZywgYnV0IEkgaGF2ZSBjaG9zZW4gdHJ1ZSA9IGJpZ2VuZGlhblxuICByZXR1cm4gIXNwZWNpZmllcnNbJ2xpdHRsZSddO1xufVxuXG5mdW5jdGlvbiBzaWduZWRfaW4oc3BlY2lmaWVycykge1xuICAvLyB0aGlzIHRpbWUgSSBnb3QgaXQgcmlnaHQ7IGRlZmF1bHQgaXMgdW5zaWduZWRcbiAgcmV0dXJuIHNwZWNpZmllcnNbJ3NpZ25lZCddO1xufVxuXG5mdW5jdGlvbiB1bml0X2luKHNwZWNpZmllcnMsIHR5cGUpIHtcbiAgZm9yICh2YXIgcyBpbiBzcGVjaWZpZXJzKSB7XG4gICAgaWYgKHMuc3Vic3RyKDAsIDUpID09ICd1bml0OicpIHtcbiAgICAgIHZhciB1bml0ID0gcGFyc2VJbnQocy5zdWJzdHIoNSkpO1xuICAgICAgLy8gVE9ETyBjaGVjayBzYW5lIGZvciB0eXBlXG4gICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gIH1cbiAgLy8gT0sgZGVmYXVsdHMgdGhlblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnYmluYXJ5JzpcbiAgICByZXR1cm4gODtcbiAgY2FzZSAnaW50ZWdlcic6XG4gIGNhc2UgJ2Zsb2F0JzpcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaXplX29mKHNlZ21lbnQsIHR5cGUsIHNpemUsIHVuaXQpIHtcbiAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBzaXplICE9PSAnJykge1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgcmV0dXJuIDg7XG4gICAgY2FzZSAnZmxvYXQnOlxuICAgICAgcmV0dXJuIDY0O1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bitsyntax/lib/pattern.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/any.js":
/*!*************************************************!*\
  !*** ./node_modules/bluebird/js/release/any.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar SomePromiseArray = Promise._SomePromiseArray;\nfunction any(promises) {\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(1);\n    ret.setUnwrap();\n    ret.init();\n    return promise;\n}\n\nPromise.any = function (promises) {\n    return any(promises);\n};\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9hbnkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9hbnkuanM/MTRiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSkge1xudmFyIFNvbWVQcm9taXNlQXJyYXkgPSBQcm9taXNlLl9Tb21lUHJvbWlzZUFycmF5O1xuZnVuY3Rpb24gYW55KHByb21pc2VzKSB7XG4gICAgdmFyIHJldCA9IG5ldyBTb21lUHJvbWlzZUFycmF5KHByb21pc2VzKTtcbiAgICB2YXIgcHJvbWlzZSA9IHJldC5wcm9taXNlKCk7XG4gICAgcmV0LnNldEhvd01hbnkoMSk7XG4gICAgcmV0LnNldFVud3JhcCgpO1xuICAgIHJldC5pbml0KCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UuYW55ID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIGFueShwcm9taXNlcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFueSh0aGlzKTtcbn07XG5cbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/any.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/async.js":
/*!***************************************************!*\
  !*** ./node_modules/bluebird/js/release/async.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar firstLineError;\ntry {throw new Error(); } catch (e) {firstLineError = e;}\nvar schedule = __webpack_require__(/*! ./schedule */ \"./node_modules/bluebird/js/release/schedule.js\");\nvar Queue = __webpack_require__(/*! ./queue */ \"./node_modules/bluebird/js/release/queue.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\n\nfunction Async() {\n    this._customScheduler = false;\n    this._isTickUsed = false;\n    this._lateQueue = new Queue(16);\n    this._normalQueue = new Queue(16);\n    this._haveDrainedQueues = false;\n    this._trampolineEnabled = true;\n    var self = this;\n    this.drainQueues = function () {\n        self._drainQueues();\n    };\n    this._schedule = schedule;\n}\n\nAsync.prototype.setScheduler = function(fn) {\n    var prev = this._schedule;\n    this._schedule = fn;\n    this._customScheduler = true;\n    return prev;\n};\n\nAsync.prototype.hasCustomScheduler = function() {\n    return this._customScheduler;\n};\n\nAsync.prototype.enableTrampoline = function() {\n    this._trampolineEnabled = true;\n};\n\nAsync.prototype.disableTrampolineIfNecessary = function() {\n    if (util.hasDevTools) {\n        this._trampolineEnabled = false;\n    }\n};\n\nAsync.prototype.haveItemsQueued = function () {\n    return this._isTickUsed || this._haveDrainedQueues;\n};\n\n\nAsync.prototype.fatalError = function(e, isNode) {\n    if (isNode) {\n        process.stderr.write(\"Fatal \" + (e instanceof Error ? e.stack : e) +\n            \"\\n\");\n        process.exit(2);\n    } else {\n        this.throwLater(e);\n    }\n};\n\nAsync.prototype.throwLater = function(fn, arg) {\n    if (arguments.length === 1) {\n        arg = fn;\n        fn = function () { throw arg; };\n    }\n    if (typeof setTimeout !== \"undefined\") {\n        setTimeout(function() {\n            fn(arg);\n        }, 0);\n    } else try {\n        this._schedule(function() {\n            fn(arg);\n        });\n    } catch (e) {\n        throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n};\n\nfunction AsyncInvokeLater(fn, receiver, arg) {\n    this._lateQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncInvoke(fn, receiver, arg) {\n    this._normalQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncSettlePromises(promise) {\n    this._normalQueue._pushOne(promise);\n    this._queueTick();\n}\n\nif (!util.hasDevTools) {\n    Async.prototype.invokeLater = AsyncInvokeLater;\n    Async.prototype.invoke = AsyncInvoke;\n    Async.prototype.settlePromises = AsyncSettlePromises;\n} else {\n    Async.prototype.invokeLater = function (fn, receiver, arg) {\n        if (this._trampolineEnabled) {\n            AsyncInvokeLater.call(this, fn, receiver, arg);\n        } else {\n            this._schedule(function() {\n                setTimeout(function() {\n                    fn.call(receiver, arg);\n                }, 100);\n            });\n        }\n    };\n\n    Async.prototype.invoke = function (fn, receiver, arg) {\n        if (this._trampolineEnabled) {\n            AsyncInvoke.call(this, fn, receiver, arg);\n        } else {\n            this._schedule(function() {\n                fn.call(receiver, arg);\n            });\n        }\n    };\n\n    Async.prototype.settlePromises = function(promise) {\n        if (this._trampolineEnabled) {\n            AsyncSettlePromises.call(this, promise);\n        } else {\n            this._schedule(function() {\n                promise._settlePromises();\n            });\n        }\n    };\n}\n\nAsync.prototype._drainQueue = function(queue) {\n    while (queue.length() > 0) {\n        var fn = queue.shift();\n        if (typeof fn !== \"function\") {\n            fn._settlePromises();\n            continue;\n        }\n        var receiver = queue.shift();\n        var arg = queue.shift();\n        fn.call(receiver, arg);\n    }\n};\n\nAsync.prototype._drainQueues = function () {\n    this._drainQueue(this._normalQueue);\n    this._reset();\n    this._haveDrainedQueues = true;\n    this._drainQueue(this._lateQueue);\n};\n\nAsync.prototype._queueTick = function () {\n    if (!this._isTickUsed) {\n        this._isTickUsed = true;\n        this._schedule(this.drainQueues);\n    }\n};\n\nAsync.prototype._reset = function () {\n    this._isTickUsed = false;\n};\n\nmodule.exports = Async;\nmodule.exports.firstLineError = firstLineError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9hc3luYy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2FzeW5jLmpzPzhjNWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZmlyc3RMaW5lRXJyb3I7XG50cnkge3Rocm93IG5ldyBFcnJvcigpOyB9IGNhdGNoIChlKSB7Zmlyc3RMaW5lRXJyb3IgPSBlO31cbnZhciBzY2hlZHVsZSA9IHJlcXVpcmUoXCIuL3NjaGVkdWxlXCIpO1xudmFyIFF1ZXVlID0gcmVxdWlyZShcIi4vcXVldWVcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbmZ1bmN0aW9uIEFzeW5jKCkge1xuICAgIHRoaXMuX2N1c3RvbVNjaGVkdWxlciA9IGZhbHNlO1xuICAgIHRoaXMuX2lzVGlja1VzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXRlUXVldWUgPSBuZXcgUXVldWUoMTYpO1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlID0gbmV3IFF1ZXVlKDE2KTtcbiAgICB0aGlzLl9oYXZlRHJhaW5lZFF1ZXVlcyA9IGZhbHNlO1xuICAgIHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkID0gdHJ1ZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5kcmFpblF1ZXVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5fZHJhaW5RdWV1ZXMoKTtcbiAgICB9O1xuICAgIHRoaXMuX3NjaGVkdWxlID0gc2NoZWR1bGU7XG59XG5cbkFzeW5jLnByb3RvdHlwZS5zZXRTY2hlZHVsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIHZhciBwcmV2ID0gdGhpcy5fc2NoZWR1bGU7XG4gICAgdGhpcy5fc2NoZWR1bGUgPSBmbjtcbiAgICB0aGlzLl9jdXN0b21TY2hlZHVsZXIgPSB0cnVlO1xuICAgIHJldHVybiBwcmV2O1xufTtcblxuQXN5bmMucHJvdG90eXBlLmhhc0N1c3RvbVNjaGVkdWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXN0b21TY2hlZHVsZXI7XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuZW5hYmxlVHJhbXBvbGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkID0gdHJ1ZTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5kaXNhYmxlVHJhbXBvbGluZUlmTmVjZXNzYXJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaGFzRGV2VG9vbHMpIHtcbiAgICAgICAgdGhpcy5fdHJhbXBvbGluZUVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuaGF2ZUl0ZW1zUXVldWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1RpY2tVc2VkIHx8IHRoaXMuX2hhdmVEcmFpbmVkUXVldWVzO1xufTtcblxuXG5Bc3luYy5wcm90b3R5cGUuZmF0YWxFcnJvciA9IGZ1bmN0aW9uKGUsIGlzTm9kZSkge1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoXCJGYXRhbCBcIiArIChlIGluc3RhbmNlb2YgRXJyb3IgPyBlLnN0YWNrIDogZSkgK1xuICAgICAgICAgICAgXCJcXG5cIik7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRocm93TGF0ZXIoZSk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLnRocm93TGF0ZXIgPSBmdW5jdGlvbihmbiwgYXJnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgYXJnID0gZm47XG4gICAgICAgIGZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBhcmc7IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4oYXJnKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfSBlbHNlIHRyeSB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm4oYXJnKTtcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhc3luYyBzY2hlZHVsZXIgYXZhaWxhYmxlXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBBc3luY0ludm9rZUxhdGVyKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgdGhpcy5fbGF0ZVF1ZXVlLnB1c2goZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5mdW5jdGlvbiBBc3luY0ludm9rZShmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHRoaXMuX25vcm1hbFF1ZXVlLnB1c2goZm4sIHJlY2VpdmVyLCBhcmcpO1xuICAgIHRoaXMuX3F1ZXVlVGljaygpO1xufVxuXG5mdW5jdGlvbiBBc3luY1NldHRsZVByb21pc2VzKHByb21pc2UpIHtcbiAgICB0aGlzLl9ub3JtYWxRdWV1ZS5fcHVzaE9uZShwcm9taXNlKTtcbiAgICB0aGlzLl9xdWV1ZVRpY2soKTtcbn1cblxuaWYgKCF1dGlsLmhhc0RldlRvb2xzKSB7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZUxhdGVyID0gQXN5bmNJbnZva2VMYXRlcjtcbiAgICBBc3luYy5wcm90b3R5cGUuaW52b2tlID0gQXN5bmNJbnZva2U7XG4gICAgQXN5bmMucHJvdG90eXBlLnNldHRsZVByb21pc2VzID0gQXN5bmNTZXR0bGVQcm9taXNlcztcbn0gZWxzZSB7XG4gICAgQXN5bmMucHJvdG90eXBlLmludm9rZUxhdGVyID0gZnVuY3Rpb24gKGZuLCByZWNlaXZlciwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFtcG9saW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgQXN5bmNJbnZva2VMYXRlci5jYWxsKHRoaXMsIGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEFzeW5jLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAoZm4sIHJlY2VpdmVyLCBhcmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW1wb2xpbmVFbmFibGVkKSB7XG4gICAgICAgICAgICBBc3luY0ludm9rZS5jYWxsKHRoaXMsIGZuLCByZWNlaXZlciwgYXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwocmVjZWl2ZXIsIGFyZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBBc3luYy5wcm90b3R5cGUuc2V0dGxlUHJvbWlzZXMgPSBmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFtcG9saW5lRW5hYmxlZCkge1xuICAgICAgICAgICAgQXN5bmNTZXR0bGVQcm9taXNlcy5jYWxsKHRoaXMsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fc2V0dGxlUHJvbWlzZXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuQXN5bmMucHJvdG90eXBlLl9kcmFpblF1ZXVlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm4uX3NldHRsZVByb21pc2VzKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVjZWl2ZXIgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICB2YXIgYXJnID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgZm4uY2FsbChyZWNlaXZlciwgYXJnKTtcbiAgICB9XG59O1xuXG5Bc3luYy5wcm90b3R5cGUuX2RyYWluUXVldWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RyYWluUXVldWUodGhpcy5fbm9ybWFsUXVldWUpO1xuICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgdGhpcy5faGF2ZURyYWluZWRRdWV1ZXMgPSB0cnVlO1xuICAgIHRoaXMuX2RyYWluUXVldWUodGhpcy5fbGF0ZVF1ZXVlKTtcbn07XG5cbkFzeW5jLnByb3RvdHlwZS5fcXVldWVUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5faXNUaWNrVXNlZCkge1xuICAgICAgICB0aGlzLl9pc1RpY2tVc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUodGhpcy5kcmFpblF1ZXVlcyk7XG4gICAgfVxufTtcblxuQXN5bmMucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pc1RpY2tVc2VkID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzeW5jO1xubW9kdWxlLmV4cG9ydHMuZmlyc3RMaW5lRXJyb3IgPSBmaXJzdExpbmVFcnJvcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/async.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/bind.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/release/bind.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {\nvar calledBind = false;\nvar rejectThis = function(_, e) {\n    this._reject(e);\n};\n\nvar targetRejected = function(e, context) {\n    context.promiseRejectionQueued = true;\n    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\n};\n\nvar bindingResolved = function(thisArg, context) {\n    if (((this._bitField & 50397184) === 0)) {\n        this._resolveCallback(context.target);\n    }\n};\n\nvar bindingRejected = function(e, context) {\n    if (!context.promiseRejectionQueued) this._reject(e);\n};\n\nPromise.prototype.bind = function (thisArg) {\n    if (!calledBind) {\n        calledBind = true;\n        Promise.prototype._propagateFrom = debug.propagateFromFunction();\n        Promise.prototype._boundValue = debug.boundValueFunction();\n    }\n    var maybePromise = tryConvertToPromise(thisArg);\n    var ret = new Promise(INTERNAL);\n    ret._propagateFrom(this, 1);\n    var target = this._target();\n    ret._setBoundTo(maybePromise);\n    if (maybePromise instanceof Promise) {\n        var context = {\n            promiseRejectionQueued: false,\n            promise: ret,\n            target: target,\n            bindingPromise: maybePromise\n        };\n        target._then(INTERNAL, targetRejected, undefined, ret, context);\n        maybePromise._then(\n            bindingResolved, bindingRejected, undefined, ret, context);\n        ret._setOnCancel(maybePromise);\n    } else {\n        ret._resolveCallback(target);\n    }\n    return ret;\n};\n\nPromise.prototype._setBoundTo = function (obj) {\n    if (obj !== undefined) {\n        this._bitField = this._bitField | 2097152;\n        this._boundTo = obj;\n    } else {\n        this._bitField = this._bitField & (~2097152);\n    }\n};\n\nPromise.prototype._isBound = function () {\n    return (this._bitField & 2097152) === 2097152;\n};\n\nPromise.bind = function (thisArg, value) {\n    return Promise.resolve(value).bind(thisArg);\n};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9iaW5kLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvYmluZC5qcz8wNjNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgZGVidWcpIHtcbnZhciBjYWxsZWRCaW5kID0gZmFsc2U7XG52YXIgcmVqZWN0VGhpcyA9IGZ1bmN0aW9uKF8sIGUpIHtcbiAgICB0aGlzLl9yZWplY3QoZSk7XG59O1xuXG52YXIgdGFyZ2V0UmVqZWN0ZWQgPSBmdW5jdGlvbihlLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5wcm9taXNlUmVqZWN0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICBjb250ZXh0LmJpbmRpbmdQcm9taXNlLl90aGVuKHJlamVjdFRoaXMsIHJlamVjdFRoaXMsIG51bGwsIHRoaXMsIGUpO1xufTtcblxudmFyIGJpbmRpbmdSZXNvbHZlZCA9IGZ1bmN0aW9uKHRoaXNBcmcsIGNvbnRleHQpIHtcbiAgICBpZiAoKCh0aGlzLl9iaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUNhbGxiYWNrKGNvbnRleHQudGFyZ2V0KTtcbiAgICB9XG59O1xuXG52YXIgYmluZGluZ1JlamVjdGVkID0gZnVuY3Rpb24oZSwgY29udGV4dCkge1xuICAgIGlmICghY29udGV4dC5wcm9taXNlUmVqZWN0aW9uUXVldWVkKSB0aGlzLl9yZWplY3QoZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcpIHtcbiAgICBpZiAoIWNhbGxlZEJpbmQpIHtcbiAgICAgICAgY2FsbGVkQmluZCA9IHRydWU7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gZGVidWcucHJvcGFnYXRlRnJvbUZ1bmN0aW9uKCk7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9ib3VuZFZhbHVlID0gZGVidWcuYm91bmRWYWx1ZUZ1bmN0aW9uKCk7XG4gICAgfVxuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXNBcmcpO1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9wcm9wYWdhdGVGcm9tKHRoaXMsIDEpO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICByZXQuX3NldEJvdW5kVG8obWF5YmVQcm9taXNlKTtcbiAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIHByb21pc2VSZWplY3Rpb25RdWV1ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJvbWlzZTogcmV0LFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBiaW5kaW5nUHJvbWlzZTogbWF5YmVQcm9taXNlXG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldC5fdGhlbihJTlRFUk5BTCwgdGFyZ2V0UmVqZWN0ZWQsIHVuZGVmaW5lZCwgcmV0LCBjb250ZXh0KTtcbiAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKFxuICAgICAgICAgICAgYmluZGluZ1Jlc29sdmVkLCBiaW5kaW5nUmVqZWN0ZWQsIHVuZGVmaW5lZCwgcmV0LCBjb250ZXh0KTtcbiAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbChtYXliZVByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5fcmVzb2x2ZUNhbGxiYWNrKHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0Qm91bmRUbyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDIwOTcxNTI7XG4gICAgICAgIHRoaXMuX2JvdW5kVG8gPSBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+MjA5NzE1Mik7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzQm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDIwOTcxNTIpID09PSAyMDk3MTUyO1xufTtcblxuUHJvbWlzZS5iaW5kID0gZnVuY3Rpb24gKHRoaXNBcmcsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkuYmluZCh0aGlzQXJnKTtcbn07XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/bind.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/bluebird.js":
/*!******************************************************!*\
  !*** ./node_modules/bluebird/js/release/bluebird.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar old;\nif (typeof Promise !== \"undefined\") old = Promise;\nfunction noConflict() {\n    try { if (Promise === bluebird) Promise = old; }\n    catch (e) {}\n    return bluebird;\n}\nvar bluebird = __webpack_require__(/*! ./promise */ \"./node_modules/bluebird/js/release/promise.js\")();\nbluebird.noConflict = noConflict;\nmodule.exports = bluebird;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9ibHVlYmlyZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2JsdWViaXJkLmpzPzRhOGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgb2xkO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSBvbGQgPSBQcm9taXNlO1xuZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICB0cnkgeyBpZiAoUHJvbWlzZSA9PT0gYmx1ZWJpcmQpIFByb21pc2UgPSBvbGQ7IH1cbiAgICBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gYmx1ZWJpcmQ7XG59XG52YXIgYmx1ZWJpcmQgPSByZXF1aXJlKFwiLi9wcm9taXNlXCIpKCk7XG5ibHVlYmlyZC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbm1vZHVsZS5leHBvcnRzID0gYmx1ZWJpcmQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/bluebird.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/call_get.js":
/*!******************************************************!*\
  !*** ./node_modules/bluebird/js/release/call_get.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar cr = Object.create;\nif (cr) {\n    var callerCache = cr(null);\n    var getterCache = cr(null);\n    callerCache[\" size\"] = getterCache[\" size\"] = 0;\n}\n\nmodule.exports = function(Promise) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar canEvaluate = util.canEvaluate;\nvar isIdentifier = util.isIdentifier;\n\nvar getMethodCaller;\nvar getGetter;\nif (true) {\nvar makeMethodCaller = function (methodName) {\n    return new Function(\"ensureMethod\", \"                                    \\n\\\n        return function(obj) {                                               \\n\\\n            'use strict'                                                     \\n\\\n            var len = this.length;                                           \\n\\\n            ensureMethod(obj, 'methodName');                                 \\n\\\n            switch(len) {                                                    \\n\\\n                case 1: return obj.methodName(this[0]);                      \\n\\\n                case 2: return obj.methodName(this[0], this[1]);             \\n\\\n                case 3: return obj.methodName(this[0], this[1], this[2]);    \\n\\\n                case 0: return obj.methodName();                             \\n\\\n                default:                                                     \\n\\\n                    return obj.methodName.apply(obj, this);                  \\n\\\n            }                                                                \\n\\\n        };                                                                   \\n\\\n        \".replace(/methodName/g, methodName))(ensureMethod);\n};\n\nvar makeGetter = function (propertyName) {\n    return new Function(\"obj\", \"                                             \\n\\\n        'use strict';                                                        \\n\\\n        return obj.propertyName;                                             \\n\\\n        \".replace(\"propertyName\", propertyName));\n};\n\nvar getCompiled = function(name, compiler, cache) {\n    var ret = cache[name];\n    if (typeof ret !== \"function\") {\n        if (!isIdentifier(name)) {\n            return null;\n        }\n        ret = compiler(name);\n        cache[name] = ret;\n        cache[\" size\"]++;\n        if (cache[\" size\"] > 512) {\n            var keys = Object.keys(cache);\n            for (var i = 0; i < 256; ++i) delete cache[keys[i]];\n            cache[\" size\"] = keys.length - 256;\n        }\n    }\n    return ret;\n};\n\ngetMethodCaller = function(name) {\n    return getCompiled(name, makeMethodCaller, callerCache);\n};\n\ngetGetter = function(name) {\n    return getCompiled(name, makeGetter, getterCache);\n};\n}\n\nfunction ensureMethod(obj, methodName) {\n    var fn;\n    if (obj != null) fn = obj[methodName];\n    if (typeof fn !== \"function\") {\n        var message = \"Object \" + util.classString(obj) + \" has no method '\" +\n            util.toString(methodName) + \"'\";\n        throw new Promise.TypeError(message);\n    }\n    return fn;\n}\n\nfunction caller(obj) {\n    var methodName = this.pop();\n    var fn = ensureMethod(obj, methodName);\n    return fn.apply(obj, this);\n}\nPromise.prototype.call = function (methodName) {\n    var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};\n    if (true) {\n        if (canEvaluate) {\n            var maybeCaller = getMethodCaller(methodName);\n            if (maybeCaller !== null) {\n                return this._then(\n                    maybeCaller, undefined, undefined, args, undefined);\n            }\n        }\n    }\n    args.push(methodName);\n    return this._then(caller, undefined, undefined, args, undefined);\n};\n\nfunction namedGetter(obj) {\n    return obj[this];\n}\nfunction indexedGetter(obj) {\n    var index = +this;\n    if (index < 0) index = Math.max(0, index + obj.length);\n    return obj[index];\n}\nPromise.prototype.get = function (propertyName) {\n    var isIndex = (typeof propertyName === \"number\");\n    var getter;\n    if (!isIndex) {\n        if (canEvaluate) {\n            var maybeGetter = getGetter(propertyName);\n            getter = maybeGetter !== null ? maybeGetter : namedGetter;\n        } else {\n            getter = namedGetter;\n        }\n    } else {\n        getter = indexedGetter;\n    }\n    return this._then(getter, undefined, undefined, propertyName, undefined);\n};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9jYWxsX2dldC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2NhbGxfZ2V0LmpzP2ZmZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgY3IgPSBPYmplY3QuY3JlYXRlO1xuaWYgKGNyKSB7XG4gICAgdmFyIGNhbGxlckNhY2hlID0gY3IobnVsbCk7XG4gICAgdmFyIGdldHRlckNhY2hlID0gY3IobnVsbCk7XG4gICAgY2FsbGVyQ2FjaGVbXCIgc2l6ZVwiXSA9IGdldHRlckNhY2hlW1wiIHNpemVcIl0gPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG52YXIgaXNJZGVudGlmaWVyID0gdXRpbC5pc0lkZW50aWZpZXI7XG5cbnZhciBnZXRNZXRob2RDYWxsZXI7XG52YXIgZ2V0R2V0dGVyO1xuaWYgKCFmYWxzZSkge1xudmFyIG1ha2VNZXRob2RDYWxsZXIgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJlbnN1cmVNZXRob2RcIiwgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgZW5zdXJlTWV0aG9kKG9iaiwgJ21ldGhvZE5hbWUnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgc3dpdGNoKGxlbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0pOyAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0pOyAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG9iai5tZXRob2ROYW1lKHRoaXNbMF0sIHRoaXNbMV0sIHRoaXNbMl0pOyAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG9iai5tZXRob2ROYW1lKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLm1ldGhvZE5hbWUuYXBwbHkob2JqLCB0aGlzKTsgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICBcIi5yZXBsYWNlKC9tZXRob2ROYW1lL2csIG1ldGhvZE5hbWUpKShlbnN1cmVNZXRob2QpO1xufTtcblxudmFyIG1ha2VHZXR0ZXIgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcIm9ialwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiBvYmoucHJvcGVydHlOYW1lOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIFwiLnJlcGxhY2UoXCJwcm9wZXJ0eU5hbWVcIiwgcHJvcGVydHlOYW1lKSk7XG59O1xuXG52YXIgZ2V0Q29tcGlsZWQgPSBmdW5jdGlvbihuYW1lLCBjb21waWxlciwgY2FjaGUpIHtcbiAgICB2YXIgcmV0ID0gY2FjaGVbbmFtZV07XG4gICAgaWYgKHR5cGVvZiByZXQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllcihuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gY29tcGlsZXIobmFtZSk7XG4gICAgICAgIGNhY2hlW25hbWVdID0gcmV0O1xuICAgICAgICBjYWNoZVtcIiBzaXplXCJdKys7XG4gICAgICAgIGlmIChjYWNoZVtcIiBzaXplXCJdID4gNTEyKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIGRlbGV0ZSBjYWNoZVtrZXlzW2ldXTtcbiAgICAgICAgICAgIGNhY2hlW1wiIHNpemVcIl0gPSBrZXlzLmxlbmd0aCAtIDI1NjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZ2V0TWV0aG9kQ2FsbGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBnZXRDb21waWxlZChuYW1lLCBtYWtlTWV0aG9kQ2FsbGVyLCBjYWxsZXJDYWNoZSk7XG59O1xuXG5nZXRHZXR0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGdldENvbXBpbGVkKG5hbWUsIG1ha2VHZXR0ZXIsIGdldHRlckNhY2hlKTtcbn07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZU1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgZm47XG4gICAgaWYgKG9iaiAhPSBudWxsKSBmbiA9IG9ialttZXRob2ROYW1lXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIk9iamVjdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcob2JqKSArIFwiIGhhcyBubyBtZXRob2QgJ1wiICtcbiAgICAgICAgICAgIHV0aWwudG9TdHJpbmcobWV0aG9kTmFtZSkgKyBcIidcIjtcbiAgICAgICAgdGhyb3cgbmV3IFByb21pc2UuVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gZm47XG59XG5cbmZ1bmN0aW9uIGNhbGxlcihvYmopIHtcbiAgICB2YXIgbWV0aG9kTmFtZSA9IHRoaXMucG9wKCk7XG4gICAgdmFyIGZuID0gZW5zdXJlTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgdGhpcyk7XG59XG5Qcm9taXNlLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgJF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoO3ZhciBhcmdzID0gbmV3IEFycmF5KE1hdGgubWF4KCRfbGVuIC0gMSwgMCkpOyBmb3IodmFyICRfaSA9IDE7ICRfaSA8ICRfbGVuOyArKyRfaSkge2FyZ3NbJF9pIC0gMV0gPSBhcmd1bWVudHNbJF9pXTt9O1xuICAgIGlmICghZmFsc2UpIHtcbiAgICAgICAgaWYgKGNhbkV2YWx1YXRlKSB7XG4gICAgICAgICAgICB2YXIgbWF5YmVDYWxsZXIgPSBnZXRNZXRob2RDYWxsZXIobWV0aG9kTmFtZSk7XG4gICAgICAgICAgICBpZiAobWF5YmVDYWxsZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhlbihcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVDYWxsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmdzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFyZ3MucHVzaChtZXRob2ROYW1lKTtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihjYWxsZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmdzLCB1bmRlZmluZWQpO1xufTtcblxuZnVuY3Rpb24gbmFtZWRHZXR0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9ialt0aGlzXTtcbn1cbmZ1bmN0aW9uIGluZGV4ZWRHZXR0ZXIob2JqKSB7XG4gICAgdmFyIGluZGV4ID0gK3RoaXM7XG4gICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBNYXRoLm1heCgwLCBpbmRleCArIG9iai5sZW5ndGgpO1xuICAgIHJldHVybiBvYmpbaW5kZXhdO1xufVxuUHJvbWlzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgIHZhciBpc0luZGV4ID0gKHR5cGVvZiBwcm9wZXJ0eU5hbWUgPT09IFwibnVtYmVyXCIpO1xuICAgIHZhciBnZXR0ZXI7XG4gICAgaWYgKCFpc0luZGV4KSB7XG4gICAgICAgIGlmIChjYW5FdmFsdWF0ZSkge1xuICAgICAgICAgICAgdmFyIG1heWJlR2V0dGVyID0gZ2V0R2V0dGVyKHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICBnZXR0ZXIgPSBtYXliZUdldHRlciAhPT0gbnVsbCA/IG1heWJlR2V0dGVyIDogbmFtZWRHZXR0ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXR0ZXIgPSBuYW1lZEdldHRlcjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldHRlciA9IGluZGV4ZWRHZXR0ZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90aGVuKGdldHRlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb3BlcnR5TmFtZSwgdW5kZWZpbmVkKTtcbn07XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/call_get.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/cancel.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/cancel.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, PromiseArray, apiRejection, debug) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar async = Promise._async;\n\nPromise.prototype[\"break\"] = Promise.prototype.cancel = function() {\n    if (!debug.cancellation()) return this._warn(\"cancellation is disabled\");\n\n    var promise = this;\n    var child = promise;\n    while (promise._isCancellable()) {\n        if (!promise._cancelBy(child)) {\n            if (child._isFollowing()) {\n                child._followee().cancel();\n            } else {\n                child._cancelBranched();\n            }\n            break;\n        }\n\n        var parent = promise._cancellationParent;\n        if (parent == null || !parent._isCancellable()) {\n            if (promise._isFollowing()) {\n                promise._followee().cancel();\n            } else {\n                promise._cancelBranched();\n            }\n            break;\n        } else {\n            if (promise._isFollowing()) promise._followee().cancel();\n            promise._setWillBeCancelled();\n            child = promise;\n            promise = parent;\n        }\n    }\n};\n\nPromise.prototype._branchHasCancelled = function() {\n    this._branchesRemainingToCancel--;\n};\n\nPromise.prototype._enoughBranchesHaveCancelled = function() {\n    return this._branchesRemainingToCancel === undefined ||\n           this._branchesRemainingToCancel <= 0;\n};\n\nPromise.prototype._cancelBy = function(canceller) {\n    if (canceller === this) {\n        this._branchesRemainingToCancel = 0;\n        this._invokeOnCancel();\n        return true;\n    } else {\n        this._branchHasCancelled();\n        if (this._enoughBranchesHaveCancelled()) {\n            this._invokeOnCancel();\n            return true;\n        }\n    }\n    return false;\n};\n\nPromise.prototype._cancelBranched = function() {\n    if (this._enoughBranchesHaveCancelled()) {\n        this._cancel();\n    }\n};\n\nPromise.prototype._cancel = function() {\n    if (!this._isCancellable()) return;\n    this._setCancelled();\n    async.invoke(this._cancelPromises, this, undefined);\n};\n\nPromise.prototype._cancelPromises = function() {\n    if (this._length() > 0) this._settlePromises();\n};\n\nPromise.prototype._unsetOnCancel = function() {\n    this._onCancelField = undefined;\n};\n\nPromise.prototype._isCancellable = function() {\n    return this.isPending() && !this._isCancelled();\n};\n\nPromise.prototype.isCancellable = function() {\n    return this.isPending() && !this.isCancelled();\n};\n\nPromise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {\n    if (util.isArray(onCancelCallback)) {\n        for (var i = 0; i < onCancelCallback.length; ++i) {\n            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);\n        }\n    } else if (onCancelCallback !== undefined) {\n        if (typeof onCancelCallback === \"function\") {\n            if (!internalOnly) {\n                var e = tryCatch(onCancelCallback).call(this._boundValue());\n                if (e === errorObj) {\n                    this._attachExtraTrace(e.e);\n                    async.throwLater(e.e);\n                }\n            }\n        } else {\n            onCancelCallback._resultCancelled(this);\n        }\n    }\n};\n\nPromise.prototype._invokeOnCancel = function() {\n    var onCancelCallback = this._onCancel();\n    this._unsetOnCancel();\n    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);\n};\n\nPromise.prototype._invokeInternalOnCancel = function() {\n    if (this._isCancellable()) {\n        this._doInvokeOnCancel(this._onCancel(), true);\n        this._unsetOnCancel();\n    }\n};\n\nPromise.prototype._resultCancelled = function() {\n    this.cancel();\n};\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9jYW5jZWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9jYW5jZWwuanM/MmNiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIGRlYnVnKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciBhc3luYyA9IFByb21pc2UuX2FzeW5jO1xuXG5Qcm9taXNlLnByb3RvdHlwZVtcImJyZWFrXCJdID0gUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFkZWJ1Zy5jYW5jZWxsYXRpb24oKSkgcmV0dXJuIHRoaXMuX3dhcm4oXCJjYW5jZWxsYXRpb24gaXMgZGlzYWJsZWRcIik7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGNoaWxkID0gcHJvbWlzZTtcbiAgICB3aGlsZSAocHJvbWlzZS5faXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIGlmICghcHJvbWlzZS5fY2FuY2VsQnkoY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuX2lzRm9sbG93aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuX2NhbmNlbEJyYW5jaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnQgPSBwcm9taXNlLl9jYW5jZWxsYXRpb25QYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgPT0gbnVsbCB8fCAhcGFyZW50Ll9pc0NhbmNlbGxhYmxlKCkpIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9pc0ZvbGxvd2luZygpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fZm9sbG93ZWUoKS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fY2FuY2VsQnJhbmNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX2lzRm9sbG93aW5nKCkpIHByb21pc2UuX2ZvbGxvd2VlKCkuY2FuY2VsKCk7XG4gICAgICAgICAgICBwcm9taXNlLl9zZXRXaWxsQmVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIGNoaWxkID0gcHJvbWlzZTtcbiAgICAgICAgICAgIHByb21pc2UgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYnJhbmNoSGFzQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbC0tO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Vub3VnaEJyYW5jaGVzSGF2ZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgdGhpcy5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA8PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2NhbmNlbEJ5ID0gZnVuY3Rpb24oY2FuY2VsbGVyKSB7XG4gICAgaWYgKGNhbmNlbGxlciA9PT0gdGhpcykge1xuICAgICAgICB0aGlzLl9icmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID0gMDtcbiAgICAgICAgdGhpcy5faW52b2tlT25DYW5jZWwoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYnJhbmNoSGFzQ2FuY2VsbGVkKCk7XG4gICAgICAgIGlmICh0aGlzLl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5faW52b2tlT25DYW5jZWwoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jYW5jZWxCcmFuY2hlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9lbm91Z2hCcmFuY2hlc0hhdmVDYW5jZWxsZWQoKSkge1xuICAgICAgICB0aGlzLl9jYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxhYmxlKCkpIHJldHVybjtcbiAgICB0aGlzLl9zZXRDYW5jZWxsZWQoKTtcbiAgICBhc3luYy5pbnZva2UodGhpcy5fY2FuY2VsUHJvbWlzZXMsIHRoaXMsIHVuZGVmaW5lZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fY2FuY2VsUHJvbWlzZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGVuZ3RoKCkgPiAwKSB0aGlzLl9zZXR0bGVQcm9taXNlcygpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0T25DYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gdW5kZWZpbmVkO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzQ2FuY2VsbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BlbmRpbmcoKSAmJiAhdGhpcy5faXNDYW5jZWxsZWQoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmlzQ2FuY2VsbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BlbmRpbmcoKSAmJiAhdGhpcy5pc0NhbmNlbGxlZCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2RvSW52b2tlT25DYW5jZWwgPSBmdW5jdGlvbihvbkNhbmNlbENhbGxiYWNrLCBpbnRlcm5hbE9ubHkpIHtcbiAgICBpZiAodXRpbC5pc0FycmF5KG9uQ2FuY2VsQ2FsbGJhY2spKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb25DYW5jZWxDYWxsYmFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5fZG9JbnZva2VPbkNhbmNlbChvbkNhbmNlbENhbGxiYWNrW2ldLCBpbnRlcm5hbE9ubHkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvbkNhbmNlbENhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbENhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxPbmx5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0cnlDYXRjaChvbkNhbmNlbENhbGxiYWNrKS5jYWxsKHRoaXMuX2JvdW5kVmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZS5lKTtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlLmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uQ2FuY2VsQ2FsbGJhY2suX3Jlc3VsdENhbmNlbGxlZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pbnZva2VPbkNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbkNhbmNlbENhbGxiYWNrID0gdGhpcy5fb25DYW5jZWwoKTtcbiAgICB0aGlzLl91bnNldE9uQ2FuY2VsKCk7XG4gICAgYXN5bmMuaW52b2tlKHRoaXMuX2RvSW52b2tlT25DYW5jZWwsIHRoaXMsIG9uQ2FuY2VsQ2FsbGJhY2spO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ludm9rZUludGVybmFsT25DYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNDYW5jZWxsYWJsZSgpKSB7XG4gICAgICAgIHRoaXMuX2RvSW52b2tlT25DYW5jZWwodGhpcy5fb25DYW5jZWwoKSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3Vuc2V0T25DYW5jZWwoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYW5jZWwoKTtcbn07XG5cbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/cancel.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/catch_filter.js":
/*!**********************************************************!*\
  !*** ./node_modules/bluebird/js/release/catch_filter.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(NEXT_FILTER) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar getKeys = __webpack_require__(/*! ./es5 */ \"./node_modules/bluebird/js/release/es5.js\").keys;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction catchFilter(instances, cb, promise) {\n    return function(e) {\n        var boundTo = promise._boundValue();\n        predicateLoop: for (var i = 0; i < instances.length; ++i) {\n            var item = instances[i];\n\n            if (item === Error ||\n                (item != null && item.prototype instanceof Error)) {\n                if (e instanceof item) {\n                    return tryCatch(cb).call(boundTo, e);\n                }\n            } else if (typeof item === \"function\") {\n                var matchesPredicate = tryCatch(item).call(boundTo, e);\n                if (matchesPredicate === errorObj) {\n                    return matchesPredicate;\n                } else if (matchesPredicate) {\n                    return tryCatch(cb).call(boundTo, e);\n                }\n            } else if (util.isObject(e)) {\n                var keys = getKeys(item);\n                for (var j = 0; j < keys.length; ++j) {\n                    var key = keys[j];\n                    if (item[key] != e[key]) {\n                        continue predicateLoop;\n                    }\n                }\n                return tryCatch(cb).call(boundTo, e);\n            }\n        }\n        return NEXT_FILTER;\n    };\n}\n\nreturn catchFilter;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9jYXRjaF9maWx0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9jYXRjaF9maWx0ZXIuanM/MDQ2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkVYVF9GSUxURVIpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZShcIi4vZXM1XCIpLmtleXM7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcblxuZnVuY3Rpb24gY2F0Y2hGaWx0ZXIoaW5zdGFuY2VzLCBjYiwgcHJvbWlzZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBib3VuZFRvID0gcHJvbWlzZS5fYm91bmRWYWx1ZSgpO1xuICAgICAgICBwcmVkaWNhdGVMb29wOiBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbnN0YW5jZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSBFcnJvciB8fFxuICAgICAgICAgICAgICAgIChpdGVtICE9IG51bGwgJiYgaXRlbS5wcm90b3R5cGUgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeUNhdGNoKGNiKS5jYWxsKGJvdW5kVG8sIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzUHJlZGljYXRlID0gdHJ5Q2F0Y2goaXRlbSkuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1ByZWRpY2F0ZSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNQcmVkaWNhdGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzUHJlZGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlDYXRjaChjYikuY2FsbChib3VuZFRvLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNPYmplY3QoZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IGdldEtleXMoaXRlbSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVtrZXldICE9IGVba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgcHJlZGljYXRlTG9vcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5Q2F0Y2goY2IpLmNhbGwoYm91bmRUbywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5FWFRfRklMVEVSO1xuICAgIH07XG59XG5cbnJldHVybiBjYXRjaEZpbHRlcjtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/catch_filter.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/context.js":
/*!*****************************************************!*\
  !*** ./node_modules/bluebird/js/release/context.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar longStackTraces = false;\nvar contextStack = [];\n\nPromise.prototype._promiseCreated = function() {};\nPromise.prototype._pushContext = function() {};\nPromise.prototype._popContext = function() {return null;};\nPromise._peekContext = Promise.prototype._peekContext = function() {};\n\nfunction Context() {\n    this._trace = new Context.CapturedTrace(peekContext());\n}\nContext.prototype._pushContext = function () {\n    if (this._trace !== undefined) {\n        this._trace._promiseCreated = null;\n        contextStack.push(this._trace);\n    }\n};\n\nContext.prototype._popContext = function () {\n    if (this._trace !== undefined) {\n        var trace = contextStack.pop();\n        var ret = trace._promiseCreated;\n        trace._promiseCreated = null;\n        return ret;\n    }\n    return null;\n};\n\nfunction createContext() {\n    if (longStackTraces) return new Context();\n}\n\nfunction peekContext() {\n    var lastIndex = contextStack.length - 1;\n    if (lastIndex >= 0) {\n        return contextStack[lastIndex];\n    }\n    return undefined;\n}\nContext.CapturedTrace = null;\nContext.create = createContext;\nContext.deactivateLongStackTraces = function() {};\nContext.activateLongStackTraces = function() {\n    var Promise_pushContext = Promise.prototype._pushContext;\n    var Promise_popContext = Promise.prototype._popContext;\n    var Promise_PeekContext = Promise._peekContext;\n    var Promise_peekContext = Promise.prototype._peekContext;\n    var Promise_promiseCreated = Promise.prototype._promiseCreated;\n    Context.deactivateLongStackTraces = function() {\n        Promise.prototype._pushContext = Promise_pushContext;\n        Promise.prototype._popContext = Promise_popContext;\n        Promise._peekContext = Promise_PeekContext;\n        Promise.prototype._peekContext = Promise_peekContext;\n        Promise.prototype._promiseCreated = Promise_promiseCreated;\n        longStackTraces = false;\n    };\n    longStackTraces = true;\n    Promise.prototype._pushContext = Context.prototype._pushContext;\n    Promise.prototype._popContext = Context.prototype._popContext;\n    Promise._peekContext = Promise.prototype._peekContext = peekContext;\n    Promise.prototype._promiseCreated = function() {\n        var ctx = this._peekContext();\n        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;\n    };\n};\nreturn Context;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9jb250ZXh0LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvY29udGV4dC5qcz9jNDczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgbG9uZ1N0YWNrVHJhY2VzID0gZmFsc2U7XG52YXIgY29udGV4dFN0YWNrID0gW107XG5cblByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZCA9IGZ1bmN0aW9uKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBmdW5jdGlvbigpIHt9O1xuUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBmdW5jdGlvbigpIHtyZXR1cm4gbnVsbDt9O1xuUHJvbWlzZS5fcGVla0NvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQgPSBmdW5jdGlvbigpIHt9O1xuXG5mdW5jdGlvbiBDb250ZXh0KCkge1xuICAgIHRoaXMuX3RyYWNlID0gbmV3IENvbnRleHQuQ2FwdHVyZWRUcmFjZShwZWVrQ29udGV4dCgpKTtcbn1cbkNvbnRleHQucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fdHJhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl90cmFjZS5fcHJvbWlzZUNyZWF0ZWQgPSBudWxsO1xuICAgICAgICBjb250ZXh0U3RhY2sucHVzaCh0aGlzLl90cmFjZSk7XG4gICAgfVxufTtcblxuQ29udGV4dC5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3RyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHRyYWNlID0gY29udGV4dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmV0ID0gdHJhY2UuX3Byb21pc2VDcmVhdGVkO1xuICAgICAgICB0cmFjZS5fcHJvbWlzZUNyZWF0ZWQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoKSB7XG4gICAgaWYgKGxvbmdTdGFja1RyYWNlcykgcmV0dXJuIG5ldyBDb250ZXh0KCk7XG59XG5cbmZ1bmN0aW9uIHBlZWtDb250ZXh0KCkge1xuICAgIHZhciBsYXN0SW5kZXggPSBjb250ZXh0U3RhY2subGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdEluZGV4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRTdGFja1tsYXN0SW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuQ29udGV4dC5DYXB0dXJlZFRyYWNlID0gbnVsbDtcbkNvbnRleHQuY3JlYXRlID0gY3JlYXRlQ29udGV4dDtcbkNvbnRleHQuZGVhY3RpdmF0ZUxvbmdTdGFja1RyYWNlcyA9IGZ1bmN0aW9uKCkge307XG5Db250ZXh0LmFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFByb21pc2VfcHVzaENvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfcG9wQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wb3BDb250ZXh0O1xuICAgIHZhciBQcm9taXNlX1BlZWtDb250ZXh0ID0gUHJvbWlzZS5fcGVla0NvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfcGVla0NvbnRleHQgPSBQcm9taXNlLnByb3RvdHlwZS5fcGVla0NvbnRleHQ7XG4gICAgdmFyIFByb21pc2VfcHJvbWlzZUNyZWF0ZWQgPSBQcm9taXNlLnByb3RvdHlwZS5fcHJvbWlzZUNyZWF0ZWQ7XG4gICAgQ29udGV4dC5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wdXNoQ29udGV4dCA9IFByb21pc2VfcHVzaENvbnRleHQ7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wb3BDb250ZXh0ID0gUHJvbWlzZV9wb3BDb250ZXh0O1xuICAgICAgICBQcm9taXNlLl9wZWVrQ29udGV4dCA9IFByb21pc2VfUGVla0NvbnRleHQ7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dCA9IFByb21pc2VfcGVla0NvbnRleHQ7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZCA9IFByb21pc2VfcHJvbWlzZUNyZWF0ZWQ7XG4gICAgICAgIGxvbmdTdGFja1RyYWNlcyA9IGZhbHNlO1xuICAgIH07XG4gICAgbG9uZ1N0YWNrVHJhY2VzID0gdHJ1ZTtcbiAgICBQcm9taXNlLnByb3RvdHlwZS5fcHVzaENvbnRleHQgPSBDb250ZXh0LnByb3RvdHlwZS5fcHVzaENvbnRleHQ7XG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX3BvcENvbnRleHQgPSBDb250ZXh0LnByb3RvdHlwZS5fcG9wQ29udGV4dDtcbiAgICBQcm9taXNlLl9wZWVrQ29udGV4dCA9IFByb21pc2UucHJvdG90eXBlLl9wZWVrQ29udGV4dCA9IHBlZWtDb250ZXh0O1xuICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9taXNlQ3JlYXRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5fcGVla0NvbnRleHQoKTtcbiAgICAgICAgaWYgKGN0eCAmJiBjdHguX3Byb21pc2VDcmVhdGVkID09IG51bGwpIGN0eC5fcHJvbWlzZUNyZWF0ZWQgPSB0aGlzO1xuICAgIH07XG59O1xucmV0dXJuIENvbnRleHQ7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/context.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/debuggability.js":
/*!***********************************************************!*\
  !*** ./node_modules/bluebird/js/release/debuggability.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, Context) {\nvar getDomain = Promise._getDomain;\nvar async = Promise._async;\nvar Warning = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\").Warning;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar canAttachTrace = util.canAttachTrace;\nvar unhandledRejectionHandled;\nvar possiblyUnhandledRejection;\nvar bluebirdFramePattern =\n    /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](release|debug|instrumented)/;\nvar nodeFramePattern = /\\((?:timers\\.js):\\d+:\\d+\\)/;\nvar parseLinePattern = /[\\/<\\(](.+?):(\\d+):(\\d+)\\)?\\s*$/;\nvar stackFramePattern = null;\nvar formatStack = null;\nvar indentStackFrames = false;\nvar printWarning;\nvar debugging = !!(util.env(\"BLUEBIRD_DEBUG\") != 0 &&\n                        (false ||\n                         util.env(\"BLUEBIRD_DEBUG\") ||\n                         util.env(\"NODE_ENV\") === \"development\"));\n\nvar warnings = !!(util.env(\"BLUEBIRD_WARNINGS\") != 0 &&\n    (debugging || util.env(\"BLUEBIRD_WARNINGS\")));\n\nvar longStackTraces = !!(util.env(\"BLUEBIRD_LONG_STACK_TRACES\") != 0 &&\n    (debugging || util.env(\"BLUEBIRD_LONG_STACK_TRACES\")));\n\nvar wForgottenReturn = util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\") != 0 &&\n    (warnings || !!util.env(\"BLUEBIRD_W_FORGOTTEN_RETURN\"));\n\nPromise.prototype.suppressUnhandledRejections = function() {\n    var target = this._target();\n    target._bitField = ((target._bitField & (~1048576)) |\n                      524288);\n};\n\nPromise.prototype._ensurePossibleRejectionHandled = function () {\n    if ((this._bitField & 524288) !== 0) return;\n    this._setRejectionIsUnhandled();\n    var self = this;\n    setTimeout(function() {\n        self._notifyUnhandledRejection();\n    }, 1);\n};\n\nPromise.prototype._notifyUnhandledRejectionIsHandled = function () {\n    fireRejectionEvent(\"rejectionHandled\",\n                                  unhandledRejectionHandled, undefined, this);\n};\n\nPromise.prototype._setReturnedNonUndefined = function() {\n    this._bitField = this._bitField | 268435456;\n};\n\nPromise.prototype._returnedNonUndefined = function() {\n    return (this._bitField & 268435456) !== 0;\n};\n\nPromise.prototype._notifyUnhandledRejection = function () {\n    if (this._isRejectionUnhandled()) {\n        var reason = this._settledValue();\n        this._setUnhandledRejectionIsNotified();\n        fireRejectionEvent(\"unhandledRejection\",\n                                      possiblyUnhandledRejection, reason, this);\n    }\n};\n\nPromise.prototype._setUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField | 262144;\n};\n\nPromise.prototype._unsetUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField & (~262144);\n};\n\nPromise.prototype._isUnhandledRejectionNotified = function () {\n    return (this._bitField & 262144) > 0;\n};\n\nPromise.prototype._setRejectionIsUnhandled = function () {\n    this._bitField = this._bitField | 1048576;\n};\n\nPromise.prototype._unsetRejectionIsUnhandled = function () {\n    this._bitField = this._bitField & (~1048576);\n    if (this._isUnhandledRejectionNotified()) {\n        this._unsetUnhandledRejectionIsNotified();\n        this._notifyUnhandledRejectionIsHandled();\n    }\n};\n\nPromise.prototype._isRejectionUnhandled = function () {\n    return (this._bitField & 1048576) > 0;\n};\n\nPromise.prototype._warn = function(message, shouldUseOwnTrace, promise) {\n    return warn(message, shouldUseOwnTrace, promise || this);\n};\n\nPromise.onPossiblyUnhandledRejection = function (fn) {\n    var domain = getDomain();\n    possiblyUnhandledRejection =\n        typeof fn === \"function\" ? (domain === null ?\n                                            fn : util.domainBind(domain, fn))\n                                 : undefined;\n};\n\nPromise.onUnhandledRejectionHandled = function (fn) {\n    var domain = getDomain();\n    unhandledRejectionHandled =\n        typeof fn === \"function\" ? (domain === null ?\n                                            fn : util.domainBind(domain, fn))\n                                 : undefined;\n};\n\nvar disableLongStackTraces = function() {};\nPromise.longStackTraces = function () {\n    if (async.haveItemsQueued() && !config.longStackTraces) {\n        throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    if (!config.longStackTraces && longStackTracesIsSupported()) {\n        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;\n        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;\n        config.longStackTraces = true;\n        disableLongStackTraces = function() {\n            if (async.haveItemsQueued() && !config.longStackTraces) {\n                throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n            }\n            Promise.prototype._captureStackTrace = Promise_captureStackTrace;\n            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;\n            Context.deactivateLongStackTraces();\n            async.enableTrampoline();\n            config.longStackTraces = false;\n        };\n        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;\n        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;\n        Context.activateLongStackTraces();\n        async.disableTrampolineIfNecessary();\n    }\n};\n\nPromise.hasLongStackTraces = function () {\n    return config.longStackTraces && longStackTracesIsSupported();\n};\n\nvar fireDomEvent = (function() {\n    try {\n        if (typeof CustomEvent === \"function\") {\n            var event = new CustomEvent(\"CustomEvent\");\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                var domEvent = new CustomEvent(name.toLowerCase(), {\n                    detail: event,\n                    cancelable: true\n                });\n                return !util.global.dispatchEvent(domEvent);\n            };\n        } else if (typeof Event === \"function\") {\n            var event = new Event(\"CustomEvent\");\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                var domEvent = new Event(name.toLowerCase(), {\n                    cancelable: true\n                });\n                domEvent.detail = event;\n                return !util.global.dispatchEvent(domEvent);\n            };\n        } else {\n            var event = document.createEvent(\"CustomEvent\");\n            event.initCustomEvent(\"testingtheevent\", false, true, {});\n            util.global.dispatchEvent(event);\n            return function(name, event) {\n                var domEvent = document.createEvent(\"CustomEvent\");\n                domEvent.initCustomEvent(name.toLowerCase(), false, true,\n                    event);\n                return !util.global.dispatchEvent(domEvent);\n            };\n        }\n    } catch (e) {}\n    return function() {\n        return false;\n    };\n})();\n\nvar fireGlobalEvent = (function() {\n    if (util.isNode) {\n        return function() {\n            return process.emit.apply(process, arguments);\n        };\n    } else {\n        if (!util.global) {\n            return function() {\n                return false;\n            };\n        }\n        return function(name) {\n            var methodName = \"on\" + name.toLowerCase();\n            var method = util.global[methodName];\n            if (!method) return false;\n            method.apply(util.global, [].slice.call(arguments, 1));\n            return true;\n        };\n    }\n})();\n\nfunction generatePromiseLifecycleEventObject(name, promise) {\n    return {promise: promise};\n}\n\nvar eventToObjectGenerator = {\n    promiseCreated: generatePromiseLifecycleEventObject,\n    promiseFulfilled: generatePromiseLifecycleEventObject,\n    promiseRejected: generatePromiseLifecycleEventObject,\n    promiseResolved: generatePromiseLifecycleEventObject,\n    promiseCancelled: generatePromiseLifecycleEventObject,\n    promiseChained: function(name, promise, child) {\n        return {promise: promise, child: child};\n    },\n    warning: function(name, warning) {\n        return {warning: warning};\n    },\n    unhandledRejection: function (name, reason, promise) {\n        return {reason: reason, promise: promise};\n    },\n    rejectionHandled: generatePromiseLifecycleEventObject\n};\n\nvar activeFireEvent = function (name) {\n    var globalEventFired = false;\n    try {\n        globalEventFired = fireGlobalEvent.apply(null, arguments);\n    } catch (e) {\n        async.throwLater(e);\n        globalEventFired = true;\n    }\n\n    var domEventFired = false;\n    try {\n        domEventFired = fireDomEvent(name,\n                    eventToObjectGenerator[name].apply(null, arguments));\n    } catch (e) {\n        async.throwLater(e);\n        domEventFired = true;\n    }\n\n    return domEventFired || globalEventFired;\n};\n\nPromise.config = function(opts) {\n    opts = Object(opts);\n    if (\"longStackTraces\" in opts) {\n        if (opts.longStackTraces) {\n            Promise.longStackTraces();\n        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {\n            disableLongStackTraces();\n        }\n    }\n    if (\"warnings\" in opts) {\n        var warningsOption = opts.warnings;\n        config.warnings = !!warningsOption;\n        wForgottenReturn = config.warnings;\n\n        if (util.isObject(warningsOption)) {\n            if (\"wForgottenReturn\" in warningsOption) {\n                wForgottenReturn = !!warningsOption.wForgottenReturn;\n            }\n        }\n    }\n    if (\"cancellation\" in opts && opts.cancellation && !config.cancellation) {\n        if (async.haveItemsQueued()) {\n            throw new Error(\n                \"cannot enable cancellation after promises are in use\");\n        }\n        Promise.prototype._clearCancellationData =\n            cancellationClearCancellationData;\n        Promise.prototype._propagateFrom = cancellationPropagateFrom;\n        Promise.prototype._onCancel = cancellationOnCancel;\n        Promise.prototype._setOnCancel = cancellationSetOnCancel;\n        Promise.prototype._attachCancellationCallback =\n            cancellationAttachCancellationCallback;\n        Promise.prototype._execute = cancellationExecute;\n        propagateFromFunction = cancellationPropagateFrom;\n        config.cancellation = true;\n    }\n    if (\"monitoring\" in opts) {\n        if (opts.monitoring && !config.monitoring) {\n            config.monitoring = true;\n            Promise.prototype._fireEvent = activeFireEvent;\n        } else if (!opts.monitoring && config.monitoring) {\n            config.monitoring = false;\n            Promise.prototype._fireEvent = defaultFireEvent;\n        }\n    }\n    return Promise;\n};\n\nfunction defaultFireEvent() { return false; }\n\nPromise.prototype._fireEvent = defaultFireEvent;\nPromise.prototype._execute = function(executor, resolve, reject) {\n    try {\n        executor(resolve, reject);\n    } catch (e) {\n        return e;\n    }\n};\nPromise.prototype._onCancel = function () {};\nPromise.prototype._setOnCancel = function (handler) { ; };\nPromise.prototype._attachCancellationCallback = function(onCancel) {\n    ;\n};\nPromise.prototype._captureStackTrace = function () {};\nPromise.prototype._attachExtraTrace = function () {};\nPromise.prototype._clearCancellationData = function() {};\nPromise.prototype._propagateFrom = function (parent, flags) {\n    ;\n    ;\n};\n\nfunction cancellationExecute(executor, resolve, reject) {\n    var promise = this;\n    try {\n        executor(resolve, reject, function(onCancel) {\n            if (typeof onCancel !== \"function\") {\n                throw new TypeError(\"onCancel must be a function, got: \" +\n                                    util.toString(onCancel));\n            }\n            promise._attachCancellationCallback(onCancel);\n        });\n    } catch (e) {\n        return e;\n    }\n}\n\nfunction cancellationAttachCancellationCallback(onCancel) {\n    if (!this._isCancellable()) return this;\n\n    var previousOnCancel = this._onCancel();\n    if (previousOnCancel !== undefined) {\n        if (util.isArray(previousOnCancel)) {\n            previousOnCancel.push(onCancel);\n        } else {\n            this._setOnCancel([previousOnCancel, onCancel]);\n        }\n    } else {\n        this._setOnCancel(onCancel);\n    }\n}\n\nfunction cancellationOnCancel() {\n    return this._onCancelField;\n}\n\nfunction cancellationSetOnCancel(onCancel) {\n    this._onCancelField = onCancel;\n}\n\nfunction cancellationClearCancellationData() {\n    this._cancellationParent = undefined;\n    this._onCancelField = undefined;\n}\n\nfunction cancellationPropagateFrom(parent, flags) {\n    if ((flags & 1) !== 0) {\n        this._cancellationParent = parent;\n        var branchesRemainingToCancel = parent._branchesRemainingToCancel;\n        if (branchesRemainingToCancel === undefined) {\n            branchesRemainingToCancel = 0;\n        }\n        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;\n    }\n    if ((flags & 2) !== 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n}\n\nfunction bindingPropagateFrom(parent, flags) {\n    if ((flags & 2) !== 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n}\nvar propagateFromFunction = bindingPropagateFrom;\n\nfunction boundValueFunction() {\n    var ret = this._boundTo;\n    if (ret !== undefined) {\n        if (ret instanceof Promise) {\n            if (ret.isFulfilled()) {\n                return ret.value();\n            } else {\n                return undefined;\n            }\n        }\n    }\n    return ret;\n}\n\nfunction longStackTracesCaptureStackTrace() {\n    this._trace = new CapturedTrace(this._peekContext());\n}\n\nfunction longStackTracesAttachExtraTrace(error, ignoreSelf) {\n    if (canAttachTrace(error)) {\n        var trace = this._trace;\n        if (trace !== undefined) {\n            if (ignoreSelf) trace = trace._parent;\n        }\n        if (trace !== undefined) {\n            trace.attachExtraTrace(error);\n        } else if (!error.__stackCleaned__) {\n            var parsed = parseStackAndMessage(error);\n            util.notEnumerableProp(error, \"stack\",\n                parsed.message + \"\\n\" + parsed.stack.join(\"\\n\"));\n            util.notEnumerableProp(error, \"__stackCleaned__\", true);\n        }\n    }\n}\n\nfunction checkForgottenReturns(returnValue, promiseCreated, name, promise,\n                               parent) {\n    if (returnValue === undefined && promiseCreated !== null &&\n        wForgottenReturn) {\n        if (parent !== undefined && parent._returnedNonUndefined()) return;\n        if ((promise._bitField & 65535) === 0) return;\n\n        if (name) name = name + \" \";\n        var handlerLine = \"\";\n        var creatorLine = \"\";\n        if (promiseCreated._trace) {\n            var traceLines = promiseCreated._trace.stack.split(\"\\n\");\n            var stack = cleanStack(traceLines);\n            for (var i = stack.length - 1; i >= 0; --i) {\n                var line = stack[i];\n                if (!nodeFramePattern.test(line)) {\n                    var lineMatches = line.match(parseLinePattern);\n                    if (lineMatches) {\n                        handlerLine  = \"at \" + lineMatches[1] +\n                            \":\" + lineMatches[2] + \":\" + lineMatches[3] + \" \";\n                    }\n                    break;\n                }\n            }\n\n            if (stack.length > 0) {\n                var firstUserLine = stack[0];\n                for (var i = 0; i < traceLines.length; ++i) {\n\n                    if (traceLines[i] === firstUserLine) {\n                        if (i > 0) {\n                            creatorLine = \"\\n\" + traceLines[i - 1];\n                        }\n                        break;\n                    }\n                }\n\n            }\n        }\n        var msg = \"a promise was created in a \" + name +\n            \"handler \" + handlerLine + \"but was not returned from it, \" +\n            \"see http://goo.gl/rRqMUw\" +\n            creatorLine;\n        promise._warn(msg, true, promiseCreated);\n    }\n}\n\nfunction deprecated(name, replacement) {\n    var message = name +\n        \" is deprecated and will be removed in a future version.\";\n    if (replacement) message += \" Use \" + replacement + \" instead.\";\n    return warn(message);\n}\n\nfunction warn(message, shouldUseOwnTrace, promise) {\n    if (!config.warnings) return;\n    var warning = new Warning(message);\n    var ctx;\n    if (shouldUseOwnTrace) {\n        promise._attachExtraTrace(warning);\n    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {\n        ctx.attachExtraTrace(warning);\n    } else {\n        var parsed = parseStackAndMessage(warning);\n        warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n    }\n\n    if (!activeFireEvent(\"warning\", warning)) {\n        formatAndLogError(warning, \"\", true);\n    }\n}\n\nfunction reconstructStack(message, stacks) {\n    for (var i = 0; i < stacks.length - 1; ++i) {\n        stacks[i].push(\"From previous event:\");\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    if (i < stacks.length) {\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    return message + \"\\n\" + stacks.join(\"\\n\");\n}\n\nfunction removeDuplicateOrEmptyJumps(stacks) {\n    for (var i = 0; i < stacks.length; ++i) {\n        if (stacks[i].length === 0 ||\n            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {\n            stacks.splice(i, 1);\n            i--;\n        }\n    }\n}\n\nfunction removeCommonRoots(stacks) {\n    var current = stacks[0];\n    for (var i = 1; i < stacks.length; ++i) {\n        var prev = stacks[i];\n        var currentLastIndex = current.length - 1;\n        var currentLastLine = current[currentLastIndex];\n        var commonRootMeetPoint = -1;\n\n        for (var j = prev.length - 1; j >= 0; --j) {\n            if (prev[j] === currentLastLine) {\n                commonRootMeetPoint = j;\n                break;\n            }\n        }\n\n        for (var j = commonRootMeetPoint; j >= 0; --j) {\n            var line = prev[j];\n            if (current[currentLastIndex] === line) {\n                current.pop();\n                currentLastIndex--;\n            } else {\n                break;\n            }\n        }\n        current = prev;\n    }\n}\n\nfunction cleanStack(stack) {\n    var ret = [];\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        var isTraceLine = \"    (No stack trace)\" === line ||\n            stackFramePattern.test(line);\n        var isInternalFrame = isTraceLine && shouldIgnore(line);\n        if (isTraceLine && !isInternalFrame) {\n            if (indentStackFrames && line.charAt(0) !== \" \") {\n                line = \"    \" + line;\n            }\n            ret.push(line);\n        }\n    }\n    return ret;\n}\n\nfunction stackFramesAsArray(error) {\n    var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n            break;\n        }\n    }\n    if (i > 0 && error.name != \"SyntaxError\") {\n        stack = stack.slice(i);\n    }\n    return stack;\n}\n\nfunction parseStackAndMessage(error) {\n    var stack = error.stack;\n    var message = error.toString();\n    stack = typeof stack === \"string\" && stack.length > 0\n                ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n    return {\n        message: message,\n        stack: error.name == \"SyntaxError\" ? stack : cleanStack(stack)\n    };\n}\n\nfunction formatAndLogError(error, title, isSoft) {\n    if (typeof console !== \"undefined\") {\n        var message;\n        if (util.isObject(error)) {\n            var stack = error.stack;\n            message = title + formatStack(stack, error);\n        } else {\n            message = title + String(error);\n        }\n        if (typeof printWarning === \"function\") {\n            printWarning(message, isSoft);\n        } else if (typeof console.log === \"function\" ||\n            typeof console.log === \"object\") {\n            console.log(message);\n        }\n    }\n}\n\nfunction fireRejectionEvent(name, localHandler, reason, promise) {\n    var localEventFired = false;\n    try {\n        if (typeof localHandler === \"function\") {\n            localEventFired = true;\n            if (name === \"rejectionHandled\") {\n                localHandler(promise);\n            } else {\n                localHandler(reason, promise);\n            }\n        }\n    } catch (e) {\n        async.throwLater(e);\n    }\n\n    if (name === \"unhandledRejection\") {\n        if (!activeFireEvent(name, reason, promise) && !localEventFired) {\n            formatAndLogError(reason, \"Unhandled rejection \");\n        }\n    } else {\n        activeFireEvent(name, promise);\n    }\n}\n\nfunction formatNonError(obj) {\n    var str;\n    if (typeof obj === \"function\") {\n        str = \"[function \" +\n            (obj.name || \"anonymous\") +\n            \"]\";\n    } else {\n        str = obj && typeof obj.toString === \"function\"\n            ? obj.toString() : util.toString(obj);\n        var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n        if (ruselessToString.test(str)) {\n            try {\n                var newStr = JSON.stringify(obj);\n                str = newStr;\n            }\n            catch(e) {\n\n            }\n        }\n        if (str.length === 0) {\n            str = \"(empty array)\";\n        }\n    }\n    return (\"(<\" + snip(str) + \">, no stack trace)\");\n}\n\nfunction snip(str) {\n    var maxChars = 41;\n    if (str.length < maxChars) {\n        return str;\n    }\n    return str.substr(0, maxChars - 3) + \"...\";\n}\n\nfunction longStackTracesIsSupported() {\n    return typeof captureStackTrace === \"function\";\n}\n\nvar shouldIgnore = function() { return false; };\nvar parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\nfunction parseLineInfo(line) {\n    var matches = line.match(parseLineInfoRegex);\n    if (matches) {\n        return {\n            fileName: matches[1],\n            line: parseInt(matches[2], 10)\n        };\n    }\n}\n\nfunction setBounds(firstLineError, lastLineError) {\n    if (!longStackTracesIsSupported()) return;\n    var firstStackLines = firstLineError.stack.split(\"\\n\");\n    var lastStackLines = lastLineError.stack.split(\"\\n\");\n    var firstIndex = -1;\n    var lastIndex = -1;\n    var firstFileName;\n    var lastFileName;\n    for (var i = 0; i < firstStackLines.length; ++i) {\n        var result = parseLineInfo(firstStackLines[i]);\n        if (result) {\n            firstFileName = result.fileName;\n            firstIndex = result.line;\n            break;\n        }\n    }\n    for (var i = 0; i < lastStackLines.length; ++i) {\n        var result = parseLineInfo(lastStackLines[i]);\n        if (result) {\n            lastFileName = result.fileName;\n            lastIndex = result.line;\n            break;\n        }\n    }\n    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||\n        firstFileName !== lastFileName || firstIndex >= lastIndex) {\n        return;\n    }\n\n    shouldIgnore = function(line) {\n        if (bluebirdFramePattern.test(line)) return true;\n        var info = parseLineInfo(line);\n        if (info) {\n            if (info.fileName === firstFileName &&\n                (firstIndex <= info.line && info.line <= lastIndex)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n\nfunction CapturedTrace(parent) {\n    this._parent = parent;\n    this._promisesCreated = 0;\n    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n    captureStackTrace(this, CapturedTrace);\n    if (length > 32) this.uncycle();\n}\nutil.inherits(CapturedTrace, Error);\nContext.CapturedTrace = CapturedTrace;\n\nCapturedTrace.prototype.uncycle = function() {\n    var length = this._length;\n    if (length < 2) return;\n    var nodes = [];\n    var stackToIndex = {};\n\n    for (var i = 0, node = this; node !== undefined; ++i) {\n        nodes.push(node);\n        node = node._parent;\n    }\n    length = this._length = i;\n    for (var i = length - 1; i >= 0; --i) {\n        var stack = nodes[i].stack;\n        if (stackToIndex[stack] === undefined) {\n            stackToIndex[stack] = i;\n        }\n    }\n    for (var i = 0; i < length; ++i) {\n        var currentStack = nodes[i].stack;\n        var index = stackToIndex[currentStack];\n        if (index !== undefined && index !== i) {\n            if (index > 0) {\n                nodes[index - 1]._parent = undefined;\n                nodes[index - 1]._length = 1;\n            }\n            nodes[i]._parent = undefined;\n            nodes[i]._length = 1;\n            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n\n            if (index < length - 1) {\n                cycleEdgeNode._parent = nodes[index + 1];\n                cycleEdgeNode._parent.uncycle();\n                cycleEdgeNode._length =\n                    cycleEdgeNode._parent._length + 1;\n            } else {\n                cycleEdgeNode._parent = undefined;\n                cycleEdgeNode._length = 1;\n            }\n            var currentChildLength = cycleEdgeNode._length + 1;\n            for (var j = i - 2; j >= 0; --j) {\n                nodes[j]._length = currentChildLength;\n                currentChildLength++;\n            }\n            return;\n        }\n    }\n};\n\nCapturedTrace.prototype.attachExtraTrace = function(error) {\n    if (error.__stackCleaned__) return;\n    this.uncycle();\n    var parsed = parseStackAndMessage(error);\n    var message = parsed.message;\n    var stacks = [parsed.stack];\n\n    var trace = this;\n    while (trace !== undefined) {\n        stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n        trace = trace._parent;\n    }\n    removeCommonRoots(stacks);\n    removeDuplicateOrEmptyJumps(stacks);\n    util.notEnumerableProp(error, \"stack\", reconstructStack(message, stacks));\n    util.notEnumerableProp(error, \"__stackCleaned__\", true);\n};\n\nvar captureStackTrace = (function stackDetection() {\n    var v8stackFramePattern = /^\\s*at\\s*/;\n    var v8stackFormatter = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if (error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    if (typeof Error.stackTraceLimit === \"number\" &&\n        typeof Error.captureStackTrace === \"function\") {\n        Error.stackTraceLimit += 6;\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        var captureStackTrace = Error.captureStackTrace;\n\n        shouldIgnore = function(line) {\n            return bluebirdFramePattern.test(line);\n        };\n        return function(receiver, ignoreUntil) {\n            Error.stackTraceLimit += 6;\n            captureStackTrace(receiver, ignoreUntil);\n            Error.stackTraceLimit -= 6;\n        };\n    }\n    var err = new Error();\n\n    if (typeof err.stack === \"string\" &&\n        err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n        stackFramePattern = /@/;\n        formatStack = v8stackFormatter;\n        indentStackFrames = true;\n        return function captureStackTrace(o) {\n            o.stack = new Error().stack;\n        };\n    }\n\n    var hasStackAfterThrow;\n    try { throw new Error(); }\n    catch(e) {\n        hasStackAfterThrow = (\"stack\" in e);\n    }\n    if (!(\"stack\" in err) && hasStackAfterThrow &&\n        typeof Error.stackTraceLimit === \"number\") {\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        return function captureStackTrace(o) {\n            Error.stackTraceLimit += 6;\n            try { throw new Error(); }\n            catch(e) { o.stack = e.stack; }\n            Error.stackTraceLimit -= 6;\n        };\n    }\n\n    formatStack = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if ((typeof error === \"object\" ||\n            typeof error === \"function\") &&\n            error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    return null;\n\n})([]);\n\nif (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n    printWarning = function (message) {\n        console.warn(message);\n    };\n    if (util.isNode && process.stderr.isTTY) {\n        printWarning = function(message, isSoft) {\n            var color = isSoft ? \"\\u001b[33m\" : \"\\u001b[31m\";\n            console.warn(color + message + \"\\u001b[0m\\n\");\n        };\n    } else if (!util.isNode && typeof (new Error().stack) === \"string\") {\n        printWarning = function(message, isSoft) {\n            console.warn(\"%c\" + message,\n                        isSoft ? \"color: darkorange\" : \"color: red\");\n        };\n    }\n}\n\nvar config = {\n    warnings: warnings,\n    longStackTraces: false,\n    cancellation: false,\n    monitoring: false\n};\n\nif (longStackTraces) Promise.longStackTraces();\n\nreturn {\n    longStackTraces: function() {\n        return config.longStackTraces;\n    },\n    warnings: function() {\n        return config.warnings;\n    },\n    cancellation: function() {\n        return config.cancellation;\n    },\n    monitoring: function() {\n        return config.monitoring;\n    },\n    propagateFromFunction: function() {\n        return propagateFromFunction;\n    },\n    boundValueFunction: function() {\n        return boundValueFunction;\n    },\n    checkForgottenReturns: checkForgottenReturns,\n    setBounds: setBounds,\n    warn: warn,\n    deprecated: deprecated,\n    CapturedTrace: CapturedTrace,\n    fireDomEvent: fireDomEvent,\n    fireGlobalEvent: fireGlobalEvent\n};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9kZWJ1Z2dhYmlsaXR5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZGVidWdnYWJpbGl0eS5qcz80M2VlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBDb250ZXh0KSB7XG52YXIgZ2V0RG9tYWluID0gUHJvbWlzZS5fZ2V0RG9tYWluO1xudmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG52YXIgV2FybmluZyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKS5XYXJuaW5nO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGNhbkF0dGFjaFRyYWNlID0gdXRpbC5jYW5BdHRhY2hUcmFjZTtcbnZhciB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkO1xudmFyIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uO1xudmFyIGJsdWViaXJkRnJhbWVQYXR0ZXJuID1cbiAgICAvW1xcXFxcXC9dYmx1ZWJpcmRbXFxcXFxcL11qc1tcXFxcXFwvXShyZWxlYXNlfGRlYnVnfGluc3RydW1lbnRlZCkvO1xudmFyIG5vZGVGcmFtZVBhdHRlcm4gPSAvXFwoKD86dGltZXJzXFwuanMpOlxcZCs6XFxkK1xcKS87XG52YXIgcGFyc2VMaW5lUGF0dGVybiA9IC9bXFwvPFxcKF0oLis/KTooXFxkKyk6KFxcZCspXFwpP1xccyokLztcbnZhciBzdGFja0ZyYW1lUGF0dGVybiA9IG51bGw7XG52YXIgZm9ybWF0U3RhY2sgPSBudWxsO1xudmFyIGluZGVudFN0YWNrRnJhbWVzID0gZmFsc2U7XG52YXIgcHJpbnRXYXJuaW5nO1xudmFyIGRlYnVnZ2luZyA9ICEhKHV0aWwuZW52KFwiQkxVRUJJUkRfREVCVUdcIikgIT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5lbnYoXCJCTFVFQklSRF9ERUJVR1wiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuZW52KFwiTk9ERV9FTlZcIikgPT09IFwiZGV2ZWxvcG1lbnRcIikpO1xuXG52YXIgd2FybmluZ3MgPSAhISh1dGlsLmVudihcIkJMVUVCSVJEX1dBUk5JTkdTXCIpICE9IDAgJiZcbiAgICAoZGVidWdnaW5nIHx8IHV0aWwuZW52KFwiQkxVRUJJUkRfV0FSTklOR1NcIikpKTtcblxudmFyIGxvbmdTdGFja1RyYWNlcyA9ICEhKHV0aWwuZW52KFwiQkxVRUJJUkRfTE9OR19TVEFDS19UUkFDRVNcIikgIT0gMCAmJlxuICAgIChkZWJ1Z2dpbmcgfHwgdXRpbC5lbnYoXCJCTFVFQklSRF9MT05HX1NUQUNLX1RSQUNFU1wiKSkpO1xuXG52YXIgd0ZvcmdvdHRlblJldHVybiA9IHV0aWwuZW52KFwiQkxVRUJJUkRfV19GT1JHT1RURU5fUkVUVVJOXCIpICE9IDAgJiZcbiAgICAod2FybmluZ3MgfHwgISF1dGlsLmVudihcIkJMVUVCSVJEX1dfRk9SR09UVEVOX1JFVFVSTlwiKSk7XG5cblByb21pc2UucHJvdG90eXBlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB0YXJnZXQuX2JpdEZpZWxkID0gKCh0YXJnZXQuX2JpdEZpZWxkICYgKH4xMDQ4NTc2KSkgfFxuICAgICAgICAgICAgICAgICAgICAgIDUyNDI4OCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICgodGhpcy5fYml0RmllbGQgJiA1MjQyODgpICE9PSAwKSByZXR1cm47XG4gICAgdGhpcy5fc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uKCk7XG4gICAgfSwgMSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbm90aWZ5VW5oYW5kbGVkUmVqZWN0aW9uSXNIYW5kbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGZpcmVSZWplY3Rpb25FdmVudChcInJlamVjdGlvbkhhbmRsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkLCB1bmRlZmluZWQsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFJldHVybmVkTm9uVW5kZWZpbmVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDI2ODQzNTQ1Njtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZXR1cm5lZE5vblVuZGVmaW5lZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAyNjg0MzU0NTYpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX25vdGlmeVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5faXNSZWplY3Rpb25VbmhhbmRsZWQoKSkge1xuICAgICAgICB2YXIgcmVhc29uID0gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG4gICAgICAgIHRoaXMuX3NldFVuaGFuZGxlZFJlamVjdGlvbklzTm90aWZpZWQoKTtcbiAgICAgICAgZmlyZVJlamVjdGlvbkV2ZW50KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmx5VW5oYW5kbGVkUmVqZWN0aW9uLCByZWFzb24sIHRoaXMpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAyNjIxNDQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRVbmhhbmRsZWRSZWplY3Rpb25Jc05vdGlmaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjI2MjE0NCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNVbmhhbmRsZWRSZWplY3Rpb25Ob3RpZmllZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMjYyMTQ0KSA+IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDEwNDg1NzY7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkICYgKH4xMDQ4NTc2KTtcbiAgICBpZiAodGhpcy5faXNVbmhhbmRsZWRSZWplY3Rpb25Ob3RpZmllZCgpKSB7XG4gICAgICAgIHRoaXMuX3Vuc2V0VW5oYW5kbGVkUmVqZWN0aW9uSXNOb3RpZmllZCgpO1xuICAgICAgICB0aGlzLl9ub3RpZnlVbmhhbmRsZWRSZWplY3Rpb25Jc0hhbmRsZWQoKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNSZWplY3Rpb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDEwNDg1NzYpID4gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl93YXJuID0gZnVuY3Rpb24obWVzc2FnZSwgc2hvdWxkVXNlT3duVHJhY2UsIHByb21pc2UpIHtcbiAgICByZXR1cm4gd2FybihtZXNzYWdlLCBzaG91bGRVc2VPd25UcmFjZSwgcHJvbWlzZSB8fCB0aGlzKTtcbn07XG5cblByb21pc2Uub25Qb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICBwb3NzaWJseVVuaGFuZGxlZFJlamVjdGlvbiA9XG4gICAgICAgIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiID8gKGRvbWFpbiA9PT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG59O1xuXG5Qcm9taXNlLm9uVW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkID1cbiAgICAgICAgdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyAoZG9tYWluID09PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBkaXNhYmxlTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UubG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhc3luYy5oYXZlSXRlbXNRdWV1ZWQoKSAmJiAhY29uZmlnLmxvbmdTdGFja1RyYWNlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5hYmxlIGxvbmcgc3RhY2sgdHJhY2VzIGFmdGVyIHByb21pc2VzIGhhdmUgYmVlbiBjcmVhdGVkXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgaWYgKCFjb25maWcubG9uZ1N0YWNrVHJhY2VzICYmIGxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgdmFyIFByb21pc2VfY2FwdHVyZVN0YWNrVHJhY2UgPSBQcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2U7XG4gICAgICAgIHZhciBQcm9taXNlX2F0dGFjaEV4dHJhVHJhY2UgPSBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZTtcbiAgICAgICAgY29uZmlnLmxvbmdTdGFja1RyYWNlcyA9IHRydWU7XG4gICAgICAgIGRpc2FibGVMb25nU3RhY2tUcmFjZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChhc3luYy5oYXZlSXRlbXNRdWV1ZWQoKSAmJiAhY29uZmlnLmxvbmdTdGFja1RyYWNlcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmFibGUgbG9uZyBzdGFjayB0cmFjZXMgYWZ0ZXIgcHJvbWlzZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2NhcHR1cmVTdGFja1RyYWNlID0gUHJvbWlzZV9jYXB0dXJlU3RhY2tUcmFjZTtcbiAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlID0gUHJvbWlzZV9hdHRhY2hFeHRyYVRyYWNlO1xuICAgICAgICAgICAgQ29udGV4dC5kZWFjdGl2YXRlTG9uZ1N0YWNrVHJhY2VzKCk7XG4gICAgICAgICAgICBhc3luYy5lbmFibGVUcmFtcG9saW5lKCk7XG4gICAgICAgICAgICBjb25maWcubG9uZ1N0YWNrVHJhY2VzID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9jYXB0dXJlU3RhY2tUcmFjZSA9IGxvbmdTdGFja1RyYWNlc0NhcHR1cmVTdGFja1RyYWNlO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoRXh0cmFUcmFjZSA9IGxvbmdTdGFja1RyYWNlc0F0dGFjaEV4dHJhVHJhY2U7XG4gICAgICAgIENvbnRleHQuYWN0aXZhdGVMb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgYXN5bmMuZGlzYWJsZVRyYW1wb2xpbmVJZk5lY2Vzc2FyeSgpO1xuICAgIH1cbn07XG5cblByb21pc2UuaGFzTG9uZ1N0YWNrVHJhY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb25maWcubG9uZ1N0YWNrVHJhY2VzICYmIGxvbmdTdGFja1RyYWNlc0lzU3VwcG9ydGVkKCk7XG59O1xuXG52YXIgZmlyZURvbUV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICB1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkb21FdmVudCA9IG5ldyBDdXN0b21FdmVudChuYW1lLnRvTG93ZXJDYXNlKCksIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAhdXRpbC5nbG9iYWwuZGlzcGF0Y2hFdmVudChkb21FdmVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBFdmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICAgICAgICAgIHV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gbmV3IEV2ZW50KG5hbWUudG9Mb3dlckNhc2UoKSwge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9tRXZlbnQuZGV0YWlsID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGRvbUV2ZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KFwidGVzdGluZ3RoZWV2ZW50XCIsIGZhbHNlLCB0cnVlLCB7fSk7XG4gICAgICAgICAgICB1dGlsLmdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkb21FdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgICAgICAgICAgICAgZG9tRXZlbnQuaW5pdEN1c3RvbUV2ZW50KG5hbWUudG9Mb3dlckNhc2UoKSwgZmFsc2UsIHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXV0aWwuZ2xvYmFsLmRpc3BhdGNoRXZlbnQoZG9tRXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn0pKCk7XG5cbnZhciBmaXJlR2xvYmFsRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaXNOb2RlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLmVtaXQuYXBwbHkocHJvY2VzcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXV0aWwuZ2xvYmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBcIm9uXCIgKyBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gdXRpbC5nbG9iYWxbbWV0aG9kTmFtZV07XG4gICAgICAgICAgICBpZiAoIW1ldGhvZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbWV0aG9kLmFwcGx5KHV0aWwuZ2xvYmFsLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QobmFtZSwgcHJvbWlzZSkge1xuICAgIHJldHVybiB7cHJvbWlzZTogcHJvbWlzZX07XG59XG5cbnZhciBldmVudFRvT2JqZWN0R2VuZXJhdG9yID0ge1xuICAgIHByb21pc2VDcmVhdGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlRnVsZmlsbGVkOiBnZW5lcmF0ZVByb21pc2VMaWZlY3ljbGVFdmVudE9iamVjdCxcbiAgICBwcm9taXNlUmVqZWN0ZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0LFxuICAgIHByb21pc2VSZXNvbHZlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZUNhbmNlbGxlZDogZ2VuZXJhdGVQcm9taXNlTGlmZWN5Y2xlRXZlbnRPYmplY3QsXG4gICAgcHJvbWlzZUNoYWluZWQ6IGZ1bmN0aW9uKG5hbWUsIHByb21pc2UsIGNoaWxkKSB7XG4gICAgICAgIHJldHVybiB7cHJvbWlzZTogcHJvbWlzZSwgY2hpbGQ6IGNoaWxkfTtcbiAgICB9LFxuICAgIHdhcm5pbmc6IGZ1bmN0aW9uKG5hbWUsIHdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIHt3YXJuaW5nOiB3YXJuaW5nfTtcbiAgICB9LFxuICAgIHVuaGFuZGxlZFJlamVjdGlvbjogZnVuY3Rpb24gKG5hbWUsIHJlYXNvbiwgcHJvbWlzZSkge1xuICAgICAgICByZXR1cm4ge3JlYXNvbjogcmVhc29uLCBwcm9taXNlOiBwcm9taXNlfTtcbiAgICB9LFxuICAgIHJlamVjdGlvbkhhbmRsZWQ6IGdlbmVyYXRlUHJvbWlzZUxpZmVjeWNsZUV2ZW50T2JqZWN0XG59O1xuXG52YXIgYWN0aXZlRmlyZUV2ZW50ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZ2xvYmFsRXZlbnRGaXJlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSBmaXJlR2xvYmFsRXZlbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZSk7XG4gICAgICAgIGdsb2JhbEV2ZW50RmlyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBkb21FdmVudEZpcmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgZG9tRXZlbnRGaXJlZCA9IGZpcmVEb21FdmVudChuYW1lLFxuICAgICAgICAgICAgICAgICAgICBldmVudFRvT2JqZWN0R2VuZXJhdG9yW25hbWVdLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihlKTtcbiAgICAgICAgZG9tRXZlbnRGaXJlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbUV2ZW50RmlyZWQgfHwgZ2xvYmFsRXZlbnRGaXJlZDtcbn07XG5cblByb21pc2UuY29uZmlnID0gZnVuY3Rpb24ob3B0cykge1xuICAgIG9wdHMgPSBPYmplY3Qob3B0cyk7XG4gICAgaWYgKFwibG9uZ1N0YWNrVHJhY2VzXCIgaW4gb3B0cykge1xuICAgICAgICBpZiAob3B0cy5sb25nU3RhY2tUcmFjZXMpIHtcbiAgICAgICAgICAgIFByb21pc2UubG9uZ1N0YWNrVHJhY2VzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdHMubG9uZ1N0YWNrVHJhY2VzICYmIFByb21pc2UuaGFzTG9uZ1N0YWNrVHJhY2VzKCkpIHtcbiAgICAgICAgICAgIGRpc2FibGVMb25nU3RhY2tUcmFjZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoXCJ3YXJuaW5nc1wiIGluIG9wdHMpIHtcbiAgICAgICAgdmFyIHdhcm5pbmdzT3B0aW9uID0gb3B0cy53YXJuaW5ncztcbiAgICAgICAgY29uZmlnLndhcm5pbmdzID0gISF3YXJuaW5nc09wdGlvbjtcbiAgICAgICAgd0ZvcmdvdHRlblJldHVybiA9IGNvbmZpZy53YXJuaW5ncztcblxuICAgICAgICBpZiAodXRpbC5pc09iamVjdCh3YXJuaW5nc09wdGlvbikpIHtcbiAgICAgICAgICAgIGlmIChcIndGb3Jnb3R0ZW5SZXR1cm5cIiBpbiB3YXJuaW5nc09wdGlvbikge1xuICAgICAgICAgICAgICAgIHdGb3Jnb3R0ZW5SZXR1cm4gPSAhIXdhcm5pbmdzT3B0aW9uLndGb3Jnb3R0ZW5SZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKFwiY2FuY2VsbGF0aW9uXCIgaW4gb3B0cyAmJiBvcHRzLmNhbmNlbGxhdGlvbiAmJiAhY29uZmlnLmNhbmNlbGxhdGlvbikge1xuICAgICAgICBpZiAoYXN5bmMuaGF2ZUl0ZW1zUXVldWVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcImNhbm5vdCBlbmFibGUgY2FuY2VsbGF0aW9uIGFmdGVyIHByb21pc2VzIGFyZSBpbiB1c2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX2NsZWFyQ2FuY2VsbGF0aW9uRGF0YSA9XG4gICAgICAgICAgICBjYW5jZWxsYXRpb25DbGVhckNhbmNlbGxhdGlvbkRhdGE7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gY2FuY2VsbGF0aW9uUHJvcGFnYXRlRnJvbTtcbiAgICAgICAgUHJvbWlzZS5wcm90b3R5cGUuX29uQ2FuY2VsID0gY2FuY2VsbGF0aW9uT25DYW5jZWw7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9zZXRPbkNhbmNlbCA9IGNhbmNlbGxhdGlvblNldE9uQ2FuY2VsO1xuICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sgPVxuICAgICAgICAgICAgY2FuY2VsbGF0aW9uQXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2s7XG4gICAgICAgIFByb21pc2UucHJvdG90eXBlLl9leGVjdXRlID0gY2FuY2VsbGF0aW9uRXhlY3V0ZTtcbiAgICAgICAgcHJvcGFnYXRlRnJvbUZ1bmN0aW9uID0gY2FuY2VsbGF0aW9uUHJvcGFnYXRlRnJvbTtcbiAgICAgICAgY29uZmlnLmNhbmNlbGxhdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChcIm1vbml0b3JpbmdcIiBpbiBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLm1vbml0b3JpbmcgJiYgIWNvbmZpZy5tb25pdG9yaW5nKSB7XG4gICAgICAgICAgICBjb25maWcubW9uaXRvcmluZyA9IHRydWU7XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZmlyZUV2ZW50ID0gYWN0aXZlRmlyZUV2ZW50O1xuICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLm1vbml0b3JpbmcgJiYgY29uZmlnLm1vbml0b3JpbmcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5tb25pdG9yaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5fZmlyZUV2ZW50ID0gZGVmYXVsdEZpcmVFdmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZTtcbn07XG5cbmZ1bmN0aW9uIGRlZmF1bHRGaXJlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuXG5Qcm9taXNlLnByb3RvdHlwZS5fZmlyZUV2ZW50ID0gZGVmYXVsdEZpcmVFdmVudDtcblByb21pc2UucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24oZXhlY3V0b3IsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG59O1xuUHJvbWlzZS5wcm90b3R5cGUuX29uQ2FuY2VsID0gZnVuY3Rpb24gKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0T25DYW5jZWwgPSBmdW5jdGlvbiAoaGFuZGxlcikgeyA7IH07XG5Qcm9taXNlLnByb3RvdHlwZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbihvbkNhbmNlbCkge1xuICAgIDtcbn07XG5Qcm9taXNlLnByb3RvdHlwZS5fY2FwdHVyZVN0YWNrVHJhY2UgPSBmdW5jdGlvbiAoKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9hdHRhY2hFeHRyYVRyYWNlID0gZnVuY3Rpb24gKCkge307XG5Qcm9taXNlLnByb3RvdHlwZS5fY2xlYXJDYW5jZWxsYXRpb25EYXRhID0gZnVuY3Rpb24oKSB7fTtcblByb21pc2UucHJvdG90eXBlLl9wcm9wYWdhdGVGcm9tID0gZnVuY3Rpb24gKHBhcmVudCwgZmxhZ3MpIHtcbiAgICA7XG4gICAgO1xufTtcblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uRXhlY3V0ZShleGVjdXRvciwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAgIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCwgZnVuY3Rpb24ob25DYW5jZWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25DYW5jZWwgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvbkNhbmNlbCBtdXN0IGJlIGEgZnVuY3Rpb24sIGdvdDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC50b1N0cmluZyhvbkNhbmNlbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvbWlzZS5fYXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sob25DYW5jZWwpO1xuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uQXR0YWNoQ2FuY2VsbGF0aW9uQ2FsbGJhY2sob25DYW5jZWwpIHtcbiAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGFibGUoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgcHJldmlvdXNPbkNhbmNlbCA9IHRoaXMuX29uQ2FuY2VsKCk7XG4gICAgaWYgKHByZXZpb3VzT25DYW5jZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodXRpbC5pc0FycmF5KHByZXZpb3VzT25DYW5jZWwpKSB7XG4gICAgICAgICAgICBwcmV2aW91c09uQ2FuY2VsLnB1c2gob25DYW5jZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0T25DYW5jZWwoW3ByZXZpb3VzT25DYW5jZWwsIG9uQ2FuY2VsXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRPbkNhbmNlbChvbkNhbmNlbCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxsYXRpb25PbkNhbmNlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25DYW5jZWxGaWVsZDtcbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uU2V0T25DYW5jZWwob25DYW5jZWwpIHtcbiAgICB0aGlzLl9vbkNhbmNlbEZpZWxkID0gb25DYW5jZWw7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbGxhdGlvbkNsZWFyQ2FuY2VsbGF0aW9uRGF0YSgpIHtcbiAgICB0aGlzLl9jYW5jZWxsYXRpb25QYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb25DYW5jZWxGaWVsZCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY2FuY2VsbGF0aW9uUHJvcGFnYXRlRnJvbShwYXJlbnQsIGZsYWdzKSB7XG4gICAgaWYgKChmbGFncyAmIDEpICE9PSAwKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbGxhdGlvblBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdmFyIGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSBwYXJlbnQuX2JyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWw7XG4gICAgICAgIGlmIChicmFuY2hlc1JlbWFpbmluZ1RvQ2FuY2VsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5fYnJhbmNoZXNSZW1haW5pbmdUb0NhbmNlbCA9IGJyYW5jaGVzUmVtYWluaW5nVG9DYW5jZWwgKyAxO1xuICAgIH1cbiAgICBpZiAoKGZsYWdzICYgMikgIT09IDAgJiYgcGFyZW50Ll9pc0JvdW5kKCkpIHtcbiAgICAgICAgdGhpcy5fc2V0Qm91bmRUbyhwYXJlbnQuX2JvdW5kVG8pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYmluZGluZ1Byb3BhZ2F0ZUZyb20ocGFyZW50LCBmbGFncykge1xuICAgIGlmICgoZmxhZ3MgJiAyKSAhPT0gMCAmJiBwYXJlbnQuX2lzQm91bmQoKSkge1xuICAgICAgICB0aGlzLl9zZXRCb3VuZFRvKHBhcmVudC5fYm91bmRUbyk7XG4gICAgfVxufVxudmFyIHByb3BhZ2F0ZUZyb21GdW5jdGlvbiA9IGJpbmRpbmdQcm9wYWdhdGVGcm9tO1xuXG5mdW5jdGlvbiBib3VuZFZhbHVlRnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldCA9IHRoaXMuX2JvdW5kVG87XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBpZiAocmV0LmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0LnZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gbG9uZ1N0YWNrVHJhY2VzQ2FwdHVyZVN0YWNrVHJhY2UoKSB7XG4gICAgdGhpcy5fdHJhY2UgPSBuZXcgQ2FwdHVyZWRUcmFjZSh0aGlzLl9wZWVrQ29udGV4dCgpKTtcbn1cblxuZnVuY3Rpb24gbG9uZ1N0YWNrVHJhY2VzQXR0YWNoRXh0cmFUcmFjZShlcnJvciwgaWdub3JlU2VsZikge1xuICAgIGlmIChjYW5BdHRhY2hUcmFjZShlcnJvcikpIHtcbiAgICAgICAgdmFyIHRyYWNlID0gdGhpcy5fdHJhY2U7XG4gICAgICAgIGlmICh0cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlU2VsZikgdHJhY2UgPSB0cmFjZS5fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFjZS5hdHRhY2hFeHRyYVRyYWNlKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmICghZXJyb3IuX19zdGFja0NsZWFuZWRfXykge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlU3RhY2tBbmRNZXNzYWdlKGVycm9yKTtcbiAgICAgICAgICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwic3RhY2tcIixcbiAgICAgICAgICAgICAgICBwYXJzZWQubWVzc2FnZSArIFwiXFxuXCIgKyBwYXJzZWQuc3RhY2suam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICB1dGlsLm5vdEVudW1lcmFibGVQcm9wKGVycm9yLCBcIl9fc3RhY2tDbGVhbmVkX19cIiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yZ290dGVuUmV0dXJucyhyZXR1cm5WYWx1ZSwgcHJvbWlzZUNyZWF0ZWQsIG5hbWUsIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50KSB7XG4gICAgaWYgKHJldHVyblZhbHVlID09PSB1bmRlZmluZWQgJiYgcHJvbWlzZUNyZWF0ZWQgIT09IG51bGwgJiZcbiAgICAgICAgd0ZvcmdvdHRlblJldHVybikge1xuICAgICAgICBpZiAocGFyZW50ICE9PSB1bmRlZmluZWQgJiYgcGFyZW50Ll9yZXR1cm5lZE5vblVuZGVmaW5lZCgpKSByZXR1cm47XG4gICAgICAgIGlmICgocHJvbWlzZS5fYml0RmllbGQgJiA2NTUzNSkgPT09IDApIHJldHVybjtcblxuICAgICAgICBpZiAobmFtZSkgbmFtZSA9IG5hbWUgKyBcIiBcIjtcbiAgICAgICAgdmFyIGhhbmRsZXJMaW5lID0gXCJcIjtcbiAgICAgICAgdmFyIGNyZWF0b3JMaW5lID0gXCJcIjtcbiAgICAgICAgaWYgKHByb21pc2VDcmVhdGVkLl90cmFjZSkge1xuICAgICAgICAgICAgdmFyIHRyYWNlTGluZXMgPSBwcm9taXNlQ3JlYXRlZC5fdHJhY2Uuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBjbGVhblN0YWNrKHRyYWNlTGluZXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVGcmFtZVBhdHRlcm4udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZU1hdGNoZXMgPSBsaW5lLm1hdGNoKHBhcnNlTGluZVBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZU1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJMaW5lICA9IFwiYXQgXCIgKyBsaW5lTWF0Y2hlc1sxXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI6XCIgKyBsaW5lTWF0Y2hlc1syXSArIFwiOlwiICsgbGluZU1hdGNoZXNbM10gKyBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0VXNlckxpbmUgPSBzdGFja1swXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNlTGluZXMubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2VMaW5lc1tpXSA9PT0gZmlyc3RVc2VyTGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRvckxpbmUgPSBcIlxcblwiICsgdHJhY2VMaW5lc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtc2cgPSBcImEgcHJvbWlzZSB3YXMgY3JlYXRlZCBpbiBhIFwiICsgbmFtZSArXG4gICAgICAgICAgICBcImhhbmRsZXIgXCIgKyBoYW5kbGVyTGluZSArIFwiYnV0IHdhcyBub3QgcmV0dXJuZWQgZnJvbSBpdCwgXCIgK1xuICAgICAgICAgICAgXCJzZWUgaHR0cDovL2dvby5nbC9yUnFNVXdcIiArXG4gICAgICAgICAgICBjcmVhdG9yTGluZTtcbiAgICAgICAgcHJvbWlzZS5fd2Fybihtc2csIHRydWUsIHByb21pc2VDcmVhdGVkKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQobmFtZSwgcmVwbGFjZW1lbnQpIHtcbiAgICB2YXIgbWVzc2FnZSA9IG5hbWUgK1xuICAgICAgICBcIiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIjtcbiAgICBpZiAocmVwbGFjZW1lbnQpIG1lc3NhZ2UgKz0gXCIgVXNlIFwiICsgcmVwbGFjZW1lbnQgKyBcIiBpbnN0ZWFkLlwiO1xuICAgIHJldHVybiB3YXJuKG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UsIHNob3VsZFVzZU93blRyYWNlLCBwcm9taXNlKSB7XG4gICAgaWYgKCFjb25maWcud2FybmluZ3MpIHJldHVybjtcbiAgICB2YXIgd2FybmluZyA9IG5ldyBXYXJuaW5nKG1lc3NhZ2UpO1xuICAgIHZhciBjdHg7XG4gICAgaWYgKHNob3VsZFVzZU93blRyYWNlKSB7XG4gICAgICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2Uod2FybmluZyk7XG4gICAgfSBlbHNlIGlmIChjb25maWcubG9uZ1N0YWNrVHJhY2VzICYmIChjdHggPSBQcm9taXNlLl9wZWVrQ29udGV4dCgpKSkge1xuICAgICAgICBjdHguYXR0YWNoRXh0cmFUcmFjZSh3YXJuaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VTdGFja0FuZE1lc3NhZ2Uod2FybmluZyk7XG4gICAgICAgIHdhcm5pbmcuc3RhY2sgPSBwYXJzZWQubWVzc2FnZSArIFwiXFxuXCIgKyBwYXJzZWQuc3RhY2suam9pbihcIlxcblwiKTtcbiAgICB9XG5cbiAgICBpZiAoIWFjdGl2ZUZpcmVFdmVudChcIndhcm5pbmdcIiwgd2FybmluZykpIHtcbiAgICAgICAgZm9ybWF0QW5kTG9nRXJyb3Iod2FybmluZywgXCJcIiwgdHJ1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWNvbnN0cnVjdFN0YWNrKG1lc3NhZ2UsIHN0YWNrcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBzdGFja3NbaV0ucHVzaChcIkZyb20gcHJldmlvdXMgZXZlbnQ6XCIpO1xuICAgICAgICBzdGFja3NbaV0gPSBzdGFja3NbaV0uam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCBzdGFja3MubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrc1tpXSA9IHN0YWNrc1tpXS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZSArIFwiXFxuXCIgKyBzdGFja3Muam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlT3JFbXB0eUp1bXBzKHN0YWNrcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzdGFja3NbaV0ubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAoKGkgKyAxIDwgc3RhY2tzLmxlbmd0aCkgJiYgc3RhY2tzW2ldWzBdID09PSBzdGFja3NbaSsxXVswXSkpIHtcbiAgICAgICAgICAgIHN0YWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNvbW1vblJvb3RzKHN0YWNrcykge1xuICAgIHZhciBjdXJyZW50ID0gc3RhY2tzWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc3RhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwcmV2ID0gc3RhY2tzW2ldO1xuICAgICAgICB2YXIgY3VycmVudExhc3RJbmRleCA9IGN1cnJlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnRMYXN0TGluZSA9IGN1cnJlbnRbY3VycmVudExhc3RJbmRleF07XG4gICAgICAgIHZhciBjb21tb25Sb290TWVldFBvaW50ID0gLTE7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IHByZXYubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgICAgIGlmIChwcmV2W2pdID09PSBjdXJyZW50TGFzdExpbmUpIHtcbiAgICAgICAgICAgICAgICBjb21tb25Sb290TWVldFBvaW50ID0gajtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSBjb21tb25Sb290TWVldFBvaW50OyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBwcmV2W2pdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRbY3VycmVudExhc3RJbmRleF0gPT09IGxpbmUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMYXN0SW5kZXgtLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IHByZXY7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbGVhblN0YWNrKHN0YWNrKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzdGFja1tpXTtcbiAgICAgICAgdmFyIGlzVHJhY2VMaW5lID0gXCIgICAgKE5vIHN0YWNrIHRyYWNlKVwiID09PSBsaW5lIHx8XG4gICAgICAgICAgICBzdGFja0ZyYW1lUGF0dGVybi50ZXN0KGxpbmUpO1xuICAgICAgICB2YXIgaXNJbnRlcm5hbEZyYW1lID0gaXNUcmFjZUxpbmUgJiYgc2hvdWxkSWdub3JlKGxpbmUpO1xuICAgICAgICBpZiAoaXNUcmFjZUxpbmUgJiYgIWlzSW50ZXJuYWxGcmFtZSkge1xuICAgICAgICAgICAgaWYgKGluZGVudFN0YWNrRnJhbWVzICYmIGxpbmUuY2hhckF0KDApICE9PSBcIiBcIikge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBcIiAgICBcIiArIGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzdGFja0ZyYW1lc0FzQXJyYXkoZXJyb3IpIHtcbiAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjay5yZXBsYWNlKC9cXHMrJC9nLCBcIlwiKS5zcGxpdChcIlxcblwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gc3RhY2tbaV07XG4gICAgICAgIGlmIChcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCIgPT09IGxpbmUgfHwgc3RhY2tGcmFtZVBhdHRlcm4udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPiAwICYmIGVycm9yLm5hbWUgIT0gXCJTeW50YXhFcnJvclwiKSB7XG4gICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoaSk7XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbn1cblxuZnVuY3Rpb24gcGFyc2VTdGFja0FuZE1lc3NhZ2UoZXJyb3IpIHtcbiAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICB2YXIgbWVzc2FnZSA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgc3RhY2sgPSB0eXBlb2Ygc3RhY2sgPT09IFwic3RyaW5nXCIgJiYgc3RhY2subGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gc3RhY2tGcmFtZXNBc0FycmF5KGVycm9yKSA6IFtcIiAgICAoTm8gc3RhY2sgdHJhY2UpXCJdO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiBlcnJvci5uYW1lID09IFwiU3ludGF4RXJyb3JcIiA/IHN0YWNrIDogY2xlYW5TdGFjayhzdGFjaylcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBbmRMb2dFcnJvcihlcnJvciwgdGl0bGUsIGlzU29mdCkge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgbWVzc2FnZTtcbiAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoZXJyb3IpKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aXRsZSArIGZvcm1hdFN0YWNrKHN0YWNrLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdGl0bGUgKyBTdHJpbmcoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJpbnRXYXJuaW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhtZXNzYWdlLCBpc1NvZnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS5sb2cgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaXJlUmVqZWN0aW9uRXZlbnQobmFtZSwgbG9jYWxIYW5kbGVyLCByZWFzb24sIHByb21pc2UpIHtcbiAgICB2YXIgbG9jYWxFdmVudEZpcmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbEhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbG9jYWxFdmVudEZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcInJlamVjdGlvbkhhbmRsZWRcIikge1xuICAgICAgICAgICAgICAgIGxvY2FsSGFuZGxlcihwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYWxIYW5kbGVyKHJlYXNvbiwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGFzeW5jLnRocm93TGF0ZXIoZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IFwidW5oYW5kbGVkUmVqZWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCFhY3RpdmVGaXJlRXZlbnQobmFtZSwgcmVhc29uLCBwcm9taXNlKSAmJiAhbG9jYWxFdmVudEZpcmVkKSB7XG4gICAgICAgICAgICBmb3JtYXRBbmRMb2dFcnJvcihyZWFzb24sIFwiVW5oYW5kbGVkIHJlamVjdGlvbiBcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVGaXJlRXZlbnQobmFtZSwgcHJvbWlzZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXROb25FcnJvcihvYmopIHtcbiAgICB2YXIgc3RyO1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc3RyID0gXCJbZnVuY3Rpb24gXCIgK1xuICAgICAgICAgICAgKG9iai5uYW1lIHx8IFwiYW5vbnltb3VzXCIpICtcbiAgICAgICAgICAgIFwiXVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IG9iaiAmJiB0eXBlb2Ygb2JqLnRvU3RyaW5nID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gb2JqLnRvU3RyaW5nKCkgOiB1dGlsLnRvU3RyaW5nKG9iaik7XG4gICAgICAgIHZhciBydXNlbGVzc1RvU3RyaW5nID0gL1xcW29iamVjdCBbYS16QS1aMC05JF9dK1xcXS87XG4gICAgICAgIGlmIChydXNlbGVzc1RvU3RyaW5nLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U3RyID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICAgICAgICAgICAgICBzdHIgPSBuZXdTdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaChlKSB7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc3RyID0gXCIoZW1wdHkgYXJyYXkpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChcIig8XCIgKyBzbmlwKHN0cikgKyBcIj4sIG5vIHN0YWNrIHRyYWNlKVwiKTtcbn1cblxuZnVuY3Rpb24gc25pcChzdHIpIHtcbiAgICB2YXIgbWF4Q2hhcnMgPSA0MTtcbiAgICBpZiAoc3RyLmxlbmd0aCA8IG1heENoYXJzKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIG1heENoYXJzIC0gMykgKyBcIi4uLlwiO1xufVxuXG5mdW5jdGlvbiBsb25nU3RhY2tUcmFjZXNJc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbnZhciBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9O1xudmFyIHBhcnNlTGluZUluZm9SZWdleCA9IC9bXFwvPFxcKF0oW146XFwvXSspOihcXGQrKTooPzpcXGQrKVxcKT9cXHMqJC87XG5mdW5jdGlvbiBwYXJzZUxpbmVJbmZvKGxpbmUpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2gocGFyc2VMaW5lSW5mb1JlZ2V4KTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoZXNbMV0sXG4gICAgICAgICAgICBsaW5lOiBwYXJzZUludChtYXRjaGVzWzJdLCAxMClcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldEJvdW5kcyhmaXJzdExpbmVFcnJvciwgbGFzdExpbmVFcnJvcikge1xuICAgIGlmICghbG9uZ1N0YWNrVHJhY2VzSXNTdXBwb3J0ZWQoKSkgcmV0dXJuO1xuICAgIHZhciBmaXJzdFN0YWNrTGluZXMgPSBmaXJzdExpbmVFcnJvci5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgbGFzdFN0YWNrTGluZXMgPSBsYXN0TGluZUVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBmaXJzdEluZGV4ID0gLTE7XG4gICAgdmFyIGxhc3RJbmRleCA9IC0xO1xuICAgIHZhciBmaXJzdEZpbGVOYW1lO1xuICAgIHZhciBsYXN0RmlsZU5hbWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8oZmlyc3RTdGFja0xpbmVzW2ldKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgZmlyc3RGaWxlTmFtZSA9IHJlc3VsdC5maWxlTmFtZTtcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdFN0YWNrTGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlTGluZUluZm8obGFzdFN0YWNrTGluZXNbaV0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBsYXN0RmlsZU5hbWUgPSByZXN1bHQuZmlsZU5hbWU7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSByZXN1bHQubGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmaXJzdEluZGV4IDwgMCB8fCBsYXN0SW5kZXggPCAwIHx8ICFmaXJzdEZpbGVOYW1lIHx8ICFsYXN0RmlsZU5hbWUgfHxcbiAgICAgICAgZmlyc3RGaWxlTmFtZSAhPT0gbGFzdEZpbGVOYW1lIHx8IGZpcnN0SW5kZXggPj0gbGFzdEluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIGlmIChibHVlYmlyZEZyYW1lUGF0dGVybi50ZXN0KGxpbmUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdmFyIGluZm8gPSBwYXJzZUxpbmVJbmZvKGxpbmUpO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKGluZm8uZmlsZU5hbWUgPT09IGZpcnN0RmlsZU5hbWUgJiZcbiAgICAgICAgICAgICAgICAoZmlyc3RJbmRleCA8PSBpbmZvLmxpbmUgJiYgaW5mby5saW5lIDw9IGxhc3RJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gQ2FwdHVyZWRUcmFjZShwYXJlbnQpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fcHJvbWlzZXNDcmVhdGVkID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5fbGVuZ3RoID0gMSArIChwYXJlbnQgPT09IHVuZGVmaW5lZCA/IDAgOiBwYXJlbnQuX2xlbmd0aCk7XG4gICAgY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ2FwdHVyZWRUcmFjZSk7XG4gICAgaWYgKGxlbmd0aCA+IDMyKSB0aGlzLnVuY3ljbGUoKTtcbn1cbnV0aWwuaW5oZXJpdHMoQ2FwdHVyZWRUcmFjZSwgRXJyb3IpO1xuQ29udGV4dC5DYXB0dXJlZFRyYWNlID0gQ2FwdHVyZWRUcmFjZTtcblxuQ2FwdHVyZWRUcmFjZS5wcm90b3R5cGUudW5jeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDIpIHJldHVybjtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgc3RhY2tUb0luZGV4ID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbm9kZSA9IHRoaXM7IG5vZGUgIT09IHVuZGVmaW5lZDsgKytpKSB7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLl9wYXJlbnQ7XG4gICAgfVxuICAgIGxlbmd0aCA9IHRoaXMuX2xlbmd0aCA9IGk7XG4gICAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBzdGFjayA9IG5vZGVzW2ldLnN0YWNrO1xuICAgICAgICBpZiAoc3RhY2tUb0luZGV4W3N0YWNrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGFja1RvSW5kZXhbc3RhY2tdID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjdXJyZW50U3RhY2sgPSBub2Rlc1tpXS5zdGFjaztcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhY2tUb0luZGV4W2N1cnJlbnRTdGFja107XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbaW5kZXggLSAxXS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIG5vZGVzW2luZGV4IC0gMV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2Rlc1tpXS5fcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbm9kZXNbaV0uX2xlbmd0aCA9IDE7XG4gICAgICAgICAgICB2YXIgY3ljbGVFZGdlTm9kZSA9IGkgPiAwID8gbm9kZXNbaSAtIDFdIDogdGhpcztcblxuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudCA9IG5vZGVzW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgY3ljbGVFZGdlTm9kZS5fcGFyZW50LnVuY3ljbGUoKTtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggPVxuICAgICAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9wYXJlbnQuX2xlbmd0aCArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN5Y2xlRWRnZU5vZGUuX3BhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjeWNsZUVkZ2VOb2RlLl9sZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGlsZExlbmd0aCA9IGN5Y2xlRWRnZU5vZGUuX2xlbmd0aCArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaSAtIDI7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbal0uX2xlbmd0aCA9IGN1cnJlbnRDaGlsZExlbmd0aDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2hpbGRMZW5ndGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkNhcHR1cmVkVHJhY2UucHJvdG90eXBlLmF0dGFjaEV4dHJhVHJhY2UgPSBmdW5jdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvci5fX3N0YWNrQ2xlYW5lZF9fKSByZXR1cm47XG4gICAgdGhpcy51bmN5Y2xlKCk7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlU3RhY2tBbmRNZXNzYWdlKGVycm9yKTtcbiAgICB2YXIgbWVzc2FnZSA9IHBhcnNlZC5tZXNzYWdlO1xuICAgIHZhciBzdGFja3MgPSBbcGFyc2VkLnN0YWNrXTtcblxuICAgIHZhciB0cmFjZSA9IHRoaXM7XG4gICAgd2hpbGUgKHRyYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RhY2tzLnB1c2goY2xlYW5TdGFjayh0cmFjZS5zdGFjay5zcGxpdChcIlxcblwiKSkpO1xuICAgICAgICB0cmFjZSA9IHRyYWNlLl9wYXJlbnQ7XG4gICAgfVxuICAgIHJlbW92ZUNvbW1vblJvb3RzKHN0YWNrcyk7XG4gICAgcmVtb3ZlRHVwbGljYXRlT3JFbXB0eUp1bXBzKHN0YWNrcyk7XG4gICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChlcnJvciwgXCJzdGFja1wiLCByZWNvbnN0cnVjdFN0YWNrKG1lc3NhZ2UsIHN0YWNrcykpO1xuICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AoZXJyb3IsIFwiX19zdGFja0NsZWFuZWRfX1wiLCB0cnVlKTtcbn07XG5cbnZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IChmdW5jdGlvbiBzdGFja0RldGVjdGlvbigpIHtcbiAgICB2YXIgdjhzdGFja0ZyYW1lUGF0dGVybiA9IC9eXFxzKmF0XFxzKi87XG4gICAgdmFyIHY4c3RhY2tGb3JtYXR0ZXIgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmIChlcnJvci5uYW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE5vbkVycm9yKGVycm9yKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBFcnJvci5zdGFja1RyYWNlTGltaXQgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgdHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gdjhzdGFja0ZyYW1lUGF0dGVybjtcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICB2YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTtcblxuICAgICAgICBzaG91bGRJZ25vcmUgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gYmx1ZWJpcmRGcmFtZVBhdHRlcm4udGVzdChsaW5lKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlY2VpdmVyLCBpZ25vcmVVbnRpbCkge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgICAgICBjYXB0dXJlU3RhY2tUcmFjZShyZWNlaXZlciwgaWdub3JlVW50aWwpO1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0IC09IDY7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcblxuICAgIGlmICh0eXBlb2YgZXJyLnN0YWNrID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIGVyci5zdGFjay5zcGxpdChcIlxcblwiKVswXS5pbmRleE9mKFwic3RhY2tEZXRlY3Rpb25AXCIpID49IDApIHtcbiAgICAgICAgc3RhY2tGcmFtZVBhdHRlcm4gPSAvQC87XG4gICAgICAgIGZvcm1hdFN0YWNrID0gdjhzdGFja0Zvcm1hdHRlcjtcbiAgICAgICAgaW5kZW50U3RhY2tGcmFtZXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgby5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBoYXNTdGFja0FmdGVyVGhyb3c7XG4gICAgdHJ5IHsgdGhyb3cgbmV3IEVycm9yKCk7IH1cbiAgICBjYXRjaChlKSB7XG4gICAgICAgIGhhc1N0YWNrQWZ0ZXJUaHJvdyA9IChcInN0YWNrXCIgaW4gZSk7XG4gICAgfVxuICAgIGlmICghKFwic3RhY2tcIiBpbiBlcnIpICYmIGhhc1N0YWNrQWZ0ZXJUaHJvdyAmJlxuICAgICAgICB0eXBlb2YgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHN0YWNrRnJhbWVQYXR0ZXJuID0gdjhzdGFja0ZyYW1lUGF0dGVybjtcbiAgICAgICAgZm9ybWF0U3RhY2sgPSB2OHN0YWNrRm9ybWF0dGVyO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2Uobykge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ICs9IDY7XG4gICAgICAgICAgICB0cnkgeyB0aHJvdyBuZXcgRXJyb3IoKTsgfVxuICAgICAgICAgICAgY2F0Y2goZSkgeyBvLnN0YWNrID0gZS5zdGFjazsgfVxuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0IC09IDY7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9ybWF0U3RhY2sgPSBmdW5jdGlvbihzdGFjaywgZXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFjayA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0YWNrO1xuXG4gICAgICAgIGlmICgodHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgICAgIGVycm9yLm5hbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3IudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0Tm9uRXJyb3IoZXJyb3IpO1xuICAgIH07XG5cbiAgICByZXR1cm4gbnVsbDtcblxufSkoW10pO1xuXG5pZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNvbnNvbGUud2FybiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9O1xuICAgIGlmICh1dGlsLmlzTm9kZSAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSkge1xuICAgICAgICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbihtZXNzYWdlLCBpc1NvZnQpIHtcbiAgICAgICAgICAgIHZhciBjb2xvciA9IGlzU29mdCA/IFwiXFx1MDAxYlszM21cIiA6IFwiXFx1MDAxYlszMW1cIjtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihjb2xvciArIG1lc3NhZ2UgKyBcIlxcdTAwMWJbMG1cXG5cIik7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICghdXRpbC5pc05vZGUgJiYgdHlwZW9mIChuZXcgRXJyb3IoKS5zdGFjaykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24obWVzc2FnZSwgaXNTb2Z0KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCIlY1wiICsgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU29mdCA/IFwiY29sb3I6IGRhcmtvcmFuZ2VcIiA6IFwiY29sb3I6IHJlZFwiKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbnZhciBjb25maWcgPSB7XG4gICAgd2FybmluZ3M6IHdhcm5pbmdzLFxuICAgIGxvbmdTdGFja1RyYWNlczogZmFsc2UsXG4gICAgY2FuY2VsbGF0aW9uOiBmYWxzZSxcbiAgICBtb25pdG9yaW5nOiBmYWxzZVxufTtcblxuaWYgKGxvbmdTdGFja1RyYWNlcykgUHJvbWlzZS5sb25nU3RhY2tUcmFjZXMoKTtcblxucmV0dXJuIHtcbiAgICBsb25nU3RhY2tUcmFjZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmxvbmdTdGFja1RyYWNlcztcbiAgICB9LFxuICAgIHdhcm5pbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy53YXJuaW5ncztcbiAgICB9LFxuICAgIGNhbmNlbGxhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcuY2FuY2VsbGF0aW9uO1xuICAgIH0sXG4gICAgbW9uaXRvcmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25maWcubW9uaXRvcmluZztcbiAgICB9LFxuICAgIHByb3BhZ2F0ZUZyb21GdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwcm9wYWdhdGVGcm9tRnVuY3Rpb247XG4gICAgfSxcbiAgICBib3VuZFZhbHVlRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYm91bmRWYWx1ZUZ1bmN0aW9uO1xuICAgIH0sXG4gICAgY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zOiBjaGVja0ZvcmdvdHRlblJldHVybnMsXG4gICAgc2V0Qm91bmRzOiBzZXRCb3VuZHMsXG4gICAgd2Fybjogd2FybixcbiAgICBkZXByZWNhdGVkOiBkZXByZWNhdGVkLFxuICAgIENhcHR1cmVkVHJhY2U6IENhcHR1cmVkVHJhY2UsXG4gICAgZmlyZURvbUV2ZW50OiBmaXJlRG9tRXZlbnQsXG4gICAgZmlyZUdsb2JhbEV2ZW50OiBmaXJlR2xvYmFsRXZlbnRcbn07XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/debuggability.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/direct_resolve.js":
/*!************************************************************!*\
  !*** ./node_modules/bluebird/js/release/direct_resolve.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nfunction returner() {\n    return this.value;\n}\nfunction thrower() {\n    throw this.reason;\n}\n\nPromise.prototype[\"return\"] =\nPromise.prototype.thenReturn = function (value) {\n    if (value instanceof Promise) value.suppressUnhandledRejections();\n    return this._then(\n        returner, undefined, undefined, {value: value}, undefined);\n};\n\nPromise.prototype[\"throw\"] =\nPromise.prototype.thenThrow = function (reason) {\n    return this._then(\n        thrower, undefined, undefined, {reason: reason}, undefined);\n};\n\nPromise.prototype.catchThrow = function (reason) {\n    if (arguments.length <= 1) {\n        return this._then(\n            undefined, thrower, undefined, {reason: reason}, undefined);\n    } else {\n        var _reason = arguments[1];\n        var handler = function() {throw _reason;};\n        return this.caught(reason, handler);\n    }\n};\n\nPromise.prototype.catchReturn = function (value) {\n    if (arguments.length <= 1) {\n        if (value instanceof Promise) value.suppressUnhandledRejections();\n        return this._then(\n            undefined, returner, undefined, {value: value}, undefined);\n    } else {\n        var _value = arguments[1];\n        if (_value instanceof Promise) _value.suppressUnhandledRejections();\n        var handler = function() {return _value;};\n        return this.caught(value, handler);\n    }\n};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9kaXJlY3RfcmVzb2x2ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL2RpcmVjdF9yZXNvbHZlLmpzP2JjZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFByb21pc2UpIHtcbmZ1bmN0aW9uIHJldHVybmVyKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xufVxuZnVuY3Rpb24gdGhyb3dlcigpIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGVbXCJyZXR1cm5cIl0gPVxuUHJvbWlzZS5wcm90b3R5cGUudGhlblJldHVybiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHZhbHVlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICByZXR1cm5lciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHt2YWx1ZTogdmFsdWV9LCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGVbXCJ0aHJvd1wiXSA9XG5Qcm9taXNlLnByb3RvdHlwZS50aGVuVGhyb3cgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oXG4gICAgICAgIHRocm93ZXIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7cmVhc29uOiByZWFzb259LCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hUaHJvdyA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICAgICAgdW5kZWZpbmVkLCB0aHJvd2VyLCB1bmRlZmluZWQsIHtyZWFzb246IHJlYXNvbn0sIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9yZWFzb24gPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24oKSB7dGhyb3cgX3JlYXNvbjt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jYXVnaHQocmVhc29uLCBoYW5kbGVyKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYXRjaFJldHVybiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkgdmFsdWUuc3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl90aGVuKFxuICAgICAgICAgICAgdW5kZWZpbmVkLCByZXR1cm5lciwgdW5kZWZpbmVkLCB7dmFsdWU6IHZhbHVlfSwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3ZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBpZiAoX3ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkgX3ZhbHVlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCkge3JldHVybiBfdmFsdWU7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2F1Z2h0KHZhbHVlLCBoYW5kbGVyKTtcbiAgICB9XG59O1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/direct_resolve.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/each.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/release/each.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseReduce = Promise.reduce;\nvar PromiseAll = Promise.all;\n\nfunction promiseAllThis() {\n    return PromiseAll(this);\n}\n\nfunction PromiseMapSeries(promises, fn) {\n    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);\n}\n\nPromise.prototype.each = function (fn) {\n    return PromiseReduce(this, fn, INTERNAL, 0)\n              ._then(promiseAllThis, undefined, undefined, this, undefined);\n};\n\nPromise.prototype.mapSeries = function (fn) {\n    return PromiseReduce(this, fn, INTERNAL, INTERNAL);\n};\n\nPromise.each = function (promises, fn) {\n    return PromiseReduce(promises, fn, INTERNAL, 0)\n              ._then(promiseAllThis, undefined, undefined, promises, undefined);\n};\n\nPromise.mapSeries = PromiseMapSeries;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9lYWNoLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZWFjaC5qcz9kZjY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCkge1xudmFyIFByb21pc2VSZWR1Y2UgPSBQcm9taXNlLnJlZHVjZTtcbnZhciBQcm9taXNlQWxsID0gUHJvbWlzZS5hbGw7XG5cbmZ1bmN0aW9uIHByb21pc2VBbGxUaGlzKCkge1xuICAgIHJldHVybiBQcm9taXNlQWxsKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBQcm9taXNlTWFwU2VyaWVzKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIElOVEVSTkFMKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgMClcbiAgICAgICAgICAgICAgLl90aGVuKHByb21pc2VBbGxUaGlzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm1hcFNlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHRoaXMsIGZuLCBJTlRFUk5BTCwgSU5URVJOQUwpO1xufTtcblxuUHJvbWlzZS5lYWNoID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbikge1xuICAgIHJldHVybiBQcm9taXNlUmVkdWNlKHByb21pc2VzLCBmbiwgSU5URVJOQUwsIDApXG4gICAgICAgICAgICAgIC5fdGhlbihwcm9taXNlQWxsVGhpcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb21pc2VzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5tYXBTZXJpZXMgPSBQcm9taXNlTWFwU2VyaWVzO1xufTtcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/each.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/errors.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/errors.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/bluebird/js/release/es5.js\");\nvar Objectfreeze = es5.freeze;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar inherits = util.inherits;\nvar notEnumerableProp = util.notEnumerableProp;\n\nfunction subError(nameProperty, defaultMessage) {\n    function SubError(message) {\n        if (!(this instanceof SubError)) return new SubError(message);\n        notEnumerableProp(this, \"message\",\n            typeof message === \"string\" ? message : defaultMessage);\n        notEnumerableProp(this, \"name\", nameProperty);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            Error.call(this);\n        }\n    }\n    inherits(SubError, Error);\n    return SubError;\n}\n\nvar _TypeError, _RangeError;\nvar Warning = subError(\"Warning\", \"warning\");\nvar CancellationError = subError(\"CancellationError\", \"cancellation error\");\nvar TimeoutError = subError(\"TimeoutError\", \"timeout error\");\nvar AggregateError = subError(\"AggregateError\", \"aggregate error\");\ntry {\n    _TypeError = TypeError;\n    _RangeError = RangeError;\n} catch(e) {\n    _TypeError = subError(\"TypeError\", \"type error\");\n    _RangeError = subError(\"RangeError\", \"range error\");\n}\n\nvar methods = (\"join pop push shift unshift slice filter forEach some \" +\n    \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\nfor (var i = 0; i < methods.length; ++i) {\n    if (typeof Array.prototype[methods[i]] === \"function\") {\n        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n    }\n}\n\nes5.defineProperty(AggregateError.prototype, \"length\", {\n    value: 0,\n    configurable: false,\n    writable: true,\n    enumerable: true\n});\nAggregateError.prototype[\"isOperational\"] = true;\nvar level = 0;\nAggregateError.prototype.toString = function() {\n    var indent = Array(level * 4 + 1).join(\" \");\n    var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n    level++;\n    indent = Array(level * 4 + 1).join(\" \");\n    for (var i = 0; i < this.length; ++i) {\n        var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n        var lines = str.split(\"\\n\");\n        for (var j = 0; j < lines.length; ++j) {\n            lines[j] = indent + lines[j];\n        }\n        str = lines.join(\"\\n\");\n        ret += str + \"\\n\";\n    }\n    level--;\n    return ret;\n};\n\nfunction OperationalError(message) {\n    if (!(this instanceof OperationalError))\n        return new OperationalError(message);\n    notEnumerableProp(this, \"name\", \"OperationalError\");\n    notEnumerableProp(this, \"message\", message);\n    this.cause = message;\n    this[\"isOperational\"] = true;\n\n    if (message instanceof Error) {\n        notEnumerableProp(this, \"message\", message.message);\n        notEnumerableProp(this, \"stack\", message.stack);\n    } else if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n    }\n\n}\ninherits(OperationalError, Error);\n\nvar errorTypes = Error[\"__BluebirdErrorTypes__\"];\nif (!errorTypes) {\n    errorTypes = Objectfreeze({\n        CancellationError: CancellationError,\n        TimeoutError: TimeoutError,\n        OperationalError: OperationalError,\n        RejectionError: OperationalError,\n        AggregateError: AggregateError\n    });\n    es5.defineProperty(Error, \"__BluebirdErrorTypes__\", {\n        value: errorTypes,\n        writable: false,\n        enumerable: false,\n        configurable: false\n    });\n}\n\nmodule.exports = {\n    Error: Error,\n    TypeError: _TypeError,\n    RangeError: _RangeError,\n    CancellationError: errorTypes.CancellationError,\n    OperationalError: errorTypes.OperationalError,\n    TimeoutError: errorTypes.TimeoutError,\n    AggregateError: errorTypes.AggregateError,\n    Warning: Warning\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9lcnJvcnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9lcnJvcnMuanM/NzI0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBlczUgPSByZXF1aXJlKFwiLi9lczVcIik7XG52YXIgT2JqZWN0ZnJlZXplID0gZXM1LmZyZWV6ZTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBpbmhlcml0cyA9IHV0aWwuaW5oZXJpdHM7XG52YXIgbm90RW51bWVyYWJsZVByb3AgPSB1dGlsLm5vdEVudW1lcmFibGVQcm9wO1xuXG5mdW5jdGlvbiBzdWJFcnJvcihuYW1lUHJvcGVydHksIGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgZnVuY3Rpb24gU3ViRXJyb3IobWVzc2FnZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3ViRXJyb3IpKSByZXR1cm4gbmV3IFN1YkVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcCh0aGlzLCBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IGRlZmF1bHRNZXNzYWdlKTtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJuYW1lXCIsIG5hbWVQcm9wZXJ0eSk7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaGVyaXRzKFN1YkVycm9yLCBFcnJvcik7XG4gICAgcmV0dXJuIFN1YkVycm9yO1xufVxuXG52YXIgX1R5cGVFcnJvciwgX1JhbmdlRXJyb3I7XG52YXIgV2FybmluZyA9IHN1YkVycm9yKFwiV2FybmluZ1wiLCBcIndhcm5pbmdcIik7XG52YXIgQ2FuY2VsbGF0aW9uRXJyb3IgPSBzdWJFcnJvcihcIkNhbmNlbGxhdGlvbkVycm9yXCIsIFwiY2FuY2VsbGF0aW9uIGVycm9yXCIpO1xudmFyIFRpbWVvdXRFcnJvciA9IHN1YkVycm9yKFwiVGltZW91dEVycm9yXCIsIFwidGltZW91dCBlcnJvclwiKTtcbnZhciBBZ2dyZWdhdGVFcnJvciA9IHN1YkVycm9yKFwiQWdncmVnYXRlRXJyb3JcIiwgXCJhZ2dyZWdhdGUgZXJyb3JcIik7XG50cnkge1xuICAgIF9UeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4gICAgX1JhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xufSBjYXRjaChlKSB7XG4gICAgX1R5cGVFcnJvciA9IHN1YkVycm9yKFwiVHlwZUVycm9yXCIsIFwidHlwZSBlcnJvclwiKTtcbiAgICBfUmFuZ2VFcnJvciA9IHN1YkVycm9yKFwiUmFuZ2VFcnJvclwiLCBcInJhbmdlIGVycm9yXCIpO1xufVxuXG52YXIgbWV0aG9kcyA9IChcImpvaW4gcG9wIHB1c2ggc2hpZnQgdW5zaGlmdCBzbGljZSBmaWx0ZXIgZm9yRWFjaCBzb21lIFwiICtcbiAgICBcImV2ZXJ5IG1hcCBpbmRleE9mIGxhc3RJbmRleE9mIHJlZHVjZSByZWR1Y2VSaWdodCBzb3J0IHJldmVyc2VcIikuc3BsaXQoXCIgXCIpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yLnByb3RvdHlwZVttZXRob2RzW2ldXSA9IEFycmF5LnByb3RvdHlwZVttZXRob2RzW2ldXTtcbiAgICB9XG59XG5cbmVzNS5kZWZpbmVQcm9wZXJ0eShBZ2dyZWdhdGVFcnJvci5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICB2YWx1ZTogMCxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbn0pO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlW1wiaXNPcGVyYXRpb25hbFwiXSA9IHRydWU7XG52YXIgbGV2ZWwgPSAwO1xuQWdncmVnYXRlRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGVudCA9IEFycmF5KGxldmVsICogNCArIDEpLmpvaW4oXCIgXCIpO1xuICAgIHZhciByZXQgPSBcIlxcblwiICsgaW5kZW50ICsgXCJBZ2dyZWdhdGVFcnJvciBvZjpcIiArIFwiXFxuXCI7XG4gICAgbGV2ZWwrKztcbiAgICBpbmRlbnQgPSBBcnJheShsZXZlbCAqIDQgKyAxKS5qb2luKFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXNbaV0gPT09IHRoaXMgPyBcIltDaXJjdWxhciBBZ2dyZWdhdGVFcnJvcl1cIiA6IHRoaXNbaV0gKyBcIlwiO1xuICAgICAgICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGxpbmVzW2pdID0gaW5kZW50ICsgbGluZXNbal07XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgcmV0ICs9IHN0ciArIFwiXFxuXCI7XG4gICAgfVxuICAgIGxldmVsLS07XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIE9wZXJhdGlvbmFsRXJyb3IobWVzc2FnZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPcGVyYXRpb25hbEVycm9yKSlcbiAgICAgICAgcmV0dXJuIG5ldyBPcGVyYXRpb25hbEVycm9yKG1lc3NhZ2UpO1xuICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwibmFtZVwiLCBcIk9wZXJhdGlvbmFsRXJyb3JcIik7XG4gICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBtZXNzYWdlO1xuICAgIHRoaXNbXCJpc09wZXJhdGlvbmFsXCJdID0gdHJ1ZTtcblxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbm90RW51bWVyYWJsZVByb3AodGhpcywgXCJtZXNzYWdlXCIsIG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHRoaXMsIFwic3RhY2tcIiwgbWVzc2FnZS5zdGFjayk7XG4gICAgfSBlbHNlIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbn1cbmluaGVyaXRzKE9wZXJhdGlvbmFsRXJyb3IsIEVycm9yKTtcblxudmFyIGVycm9yVHlwZXMgPSBFcnJvcltcIl9fQmx1ZWJpcmRFcnJvclR5cGVzX19cIl07XG5pZiAoIWVycm9yVHlwZXMpIHtcbiAgICBlcnJvclR5cGVzID0gT2JqZWN0ZnJlZXplKHtcbiAgICAgICAgQ2FuY2VsbGF0aW9uRXJyb3I6IENhbmNlbGxhdGlvbkVycm9yLFxuICAgICAgICBUaW1lb3V0RXJyb3I6IFRpbWVvdXRFcnJvcixcbiAgICAgICAgT3BlcmF0aW9uYWxFcnJvcjogT3BlcmF0aW9uYWxFcnJvcixcbiAgICAgICAgUmVqZWN0aW9uRXJyb3I6IE9wZXJhdGlvbmFsRXJyb3IsXG4gICAgICAgIEFnZ3JlZ2F0ZUVycm9yOiBBZ2dyZWdhdGVFcnJvclxuICAgIH0pO1xuICAgIGVzNS5kZWZpbmVQcm9wZXJ0eShFcnJvciwgXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCIsIHtcbiAgICAgICAgdmFsdWU6IGVycm9yVHlwZXMsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRXJyb3I6IEVycm9yLFxuICAgIFR5cGVFcnJvcjogX1R5cGVFcnJvcixcbiAgICBSYW5nZUVycm9yOiBfUmFuZ2VFcnJvcixcbiAgICBDYW5jZWxsYXRpb25FcnJvcjogZXJyb3JUeXBlcy5DYW5jZWxsYXRpb25FcnJvcixcbiAgICBPcGVyYXRpb25hbEVycm9yOiBlcnJvclR5cGVzLk9wZXJhdGlvbmFsRXJyb3IsXG4gICAgVGltZW91dEVycm9yOiBlcnJvclR5cGVzLlRpbWVvdXRFcnJvcixcbiAgICBBZ2dyZWdhdGVFcnJvcjogZXJyb3JUeXBlcy5BZ2dyZWdhdGVFcnJvcixcbiAgICBXYXJuaW5nOiBXYXJuaW5nXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/errors.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/es5.js":
/*!*************************************************!*\
  !*** ./node_modules/bluebird/js/release/es5.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var isES5 = (function(){\n    \"use strict\";\n    return this === undefined;\n})();\n\nif (isES5) {\n    module.exports = {\n        freeze: Object.freeze,\n        defineProperty: Object.defineProperty,\n        getDescriptor: Object.getOwnPropertyDescriptor,\n        keys: Object.keys,\n        names: Object.getOwnPropertyNames,\n        getPrototypeOf: Object.getPrototypeOf,\n        isArray: Array.isArray,\n        isES5: isES5,\n        propertyIsWritable: function(obj, prop) {\n            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n            return !!(!descriptor || descriptor.writable || descriptor.set);\n        }\n    };\n} else {\n    var has = {}.hasOwnProperty;\n    var str = {}.toString;\n    var proto = {}.constructor.prototype;\n\n    var ObjectKeys = function (o) {\n        var ret = [];\n        for (var key in o) {\n            if (has.call(o, key)) {\n                ret.push(key);\n            }\n        }\n        return ret;\n    };\n\n    var ObjectGetDescriptor = function(o, key) {\n        return {value: o[key]};\n    };\n\n    var ObjectDefineProperty = function (o, key, desc) {\n        o[key] = desc.value;\n        return o;\n    };\n\n    var ObjectFreeze = function (obj) {\n        return obj;\n    };\n\n    var ObjectGetPrototypeOf = function (obj) {\n        try {\n            return Object(obj).constructor.prototype;\n        }\n        catch (e) {\n            return proto;\n        }\n    };\n\n    var ArrayIsArray = function (obj) {\n        try {\n            return str.call(obj) === \"[object Array]\";\n        }\n        catch(e) {\n            return false;\n        }\n    };\n\n    module.exports = {\n        isArray: ArrayIsArray,\n        keys: ObjectKeys,\n        names: ObjectKeys,\n        defineProperty: ObjectDefineProperty,\n        getDescriptor: ObjectGetDescriptor,\n        freeze: ObjectFreeze,\n        getPrototypeOf: ObjectGetPrototypeOf,\n        isES5: isES5,\n        propertyIsWritable: function() {\n            return true;\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9lczUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9lczUuanM/ZWZmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNFUzUgPSAoZnVuY3Rpb24oKXtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICByZXR1cm4gdGhpcyA9PT0gdW5kZWZpbmVkO1xufSkoKTtcblxuaWYgKGlzRVM1KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGZyZWV6ZTogT2JqZWN0LmZyZWV6ZSxcbiAgICAgICAgZGVmaW5lUHJvcGVydHk6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgZ2V0RGVzY3JpcHRvcjogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICAgICAga2V5czogT2JqZWN0LmtleXMsXG4gICAgICAgIG5hbWVzOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgICAgICAgZ2V0UHJvdG90eXBlT2Y6IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICAgICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSxcbiAgICAgICAgaXNFUzU6IGlzRVM1LFxuICAgICAgICBwcm9wZXJ0eUlzV3JpdGFibGU6IGZ1bmN0aW9uKG9iaiwgcHJvcCkge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgICAgICAgICByZXR1cm4gISEoIWRlc2NyaXB0b3IgfHwgZGVzY3JpcHRvci53cml0YWJsZSB8fCBkZXNjcmlwdG9yLnNldCk7XG4gICAgICAgIH1cbiAgICB9O1xufSBlbHNlIHtcbiAgICB2YXIgaGFzID0ge30uaGFzT3duUHJvcGVydHk7XG4gICAgdmFyIHN0ciA9IHt9LnRvU3RyaW5nO1xuICAgIHZhciBwcm90byA9IHt9LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICAgIHZhciBPYmplY3RLZXlzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbykge1xuICAgICAgICAgICAgaWYgKGhhcy5jYWxsKG8sIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIHZhciBPYmplY3RHZXREZXNjcmlwdG9yID0gZnVuY3Rpb24obywga2V5KSB7XG4gICAgICAgIHJldHVybiB7dmFsdWU6IG9ba2V5XX07XG4gICAgfTtcblxuICAgIHZhciBPYmplY3REZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvLCBrZXksIGRlc2MpIHtcbiAgICAgICAgb1trZXldID0gZGVzYy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcblxuICAgIHZhciBPYmplY3RGcmVlemUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIHZhciBPYmplY3RHZXRQcm90b3R5cGVPZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qob2JqKS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgQXJyYXlJc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzQXJyYXk6IEFycmF5SXNBcnJheSxcbiAgICAgICAga2V5czogT2JqZWN0S2V5cyxcbiAgICAgICAgbmFtZXM6IE9iamVjdEtleXMsXG4gICAgICAgIGRlZmluZVByb3BlcnR5OiBPYmplY3REZWZpbmVQcm9wZXJ0eSxcbiAgICAgICAgZ2V0RGVzY3JpcHRvcjogT2JqZWN0R2V0RGVzY3JpcHRvcixcbiAgICAgICAgZnJlZXplOiBPYmplY3RGcmVlemUsXG4gICAgICAgIGdldFByb3RvdHlwZU9mOiBPYmplY3RHZXRQcm90b3R5cGVPZixcbiAgICAgICAgaXNFUzU6IGlzRVM1LFxuICAgICAgICBwcm9wZXJ0eUlzV3JpdGFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/es5.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/filter.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/filter.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseMap = Promise.map;\n\nPromise.prototype.filter = function (fn, options) {\n    return PromiseMap(this, fn, options, INTERNAL);\n};\n\nPromise.filter = function (promises, fn, options) {\n    return PromiseMap(promises, fn, options, INTERNAL);\n};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9maWx0ZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9maWx0ZXIuanM/YTBmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciBQcm9taXNlTWFwID0gUHJvbWlzZS5tYXA7XG5cblByb21pc2UucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBQcm9taXNlTWFwKHRoaXMsIGZuLCBvcHRpb25zLCBJTlRFUk5BTCk7XG59O1xuXG5Qcm9taXNlLmZpbHRlciA9IGZ1bmN0aW9uIChwcm9taXNlcywgZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gUHJvbWlzZU1hcChwcm9taXNlcywgZm4sIG9wdGlvbnMsIElOVEVSTkFMKTtcbn07XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/filter.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/finally.js":
/*!*****************************************************!*\
  !*** ./node_modules/bluebird/js/release/finally.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, tryConvertToPromise, NEXT_FILTER) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar CancellationError = Promise.CancellationError;\nvar errorObj = util.errorObj;\nvar catchFilter = __webpack_require__(/*! ./catch_filter */ \"./node_modules/bluebird/js/release/catch_filter.js\")(NEXT_FILTER);\n\nfunction PassThroughHandlerContext(promise, type, handler) {\n    this.promise = promise;\n    this.type = type;\n    this.handler = handler;\n    this.called = false;\n    this.cancelPromise = null;\n}\n\nPassThroughHandlerContext.prototype.isFinallyHandler = function() {\n    return this.type === 0;\n};\n\nfunction FinallyHandlerCancelReaction(finallyHandler) {\n    this.finallyHandler = finallyHandler;\n}\n\nFinallyHandlerCancelReaction.prototype._resultCancelled = function() {\n    checkCancel(this.finallyHandler);\n};\n\nfunction checkCancel(ctx, reason) {\n    if (ctx.cancelPromise != null) {\n        if (arguments.length > 1) {\n            ctx.cancelPromise._reject(reason);\n        } else {\n            ctx.cancelPromise._cancel();\n        }\n        ctx.cancelPromise = null;\n        return true;\n    }\n    return false;\n}\n\nfunction succeed() {\n    return finallyHandler.call(this, this.promise._target()._settledValue());\n}\nfunction fail(reason) {\n    if (checkCancel(this, reason)) return;\n    errorObj.e = reason;\n    return errorObj;\n}\nfunction finallyHandler(reasonOrValue) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    if (!this.called) {\n        this.called = true;\n        var ret = this.isFinallyHandler()\n            ? handler.call(promise._boundValue())\n            : handler.call(promise._boundValue(), reasonOrValue);\n        if (ret === NEXT_FILTER) {\n            return ret;\n        } else if (ret !== undefined) {\n            promise._setReturnedNonUndefined();\n            var maybePromise = tryConvertToPromise(ret, promise);\n            if (maybePromise instanceof Promise) {\n                if (this.cancelPromise != null) {\n                    if (maybePromise._isCancelled()) {\n                        var reason =\n                            new CancellationError(\"late cancellation observer\");\n                        promise._attachExtraTrace(reason);\n                        errorObj.e = reason;\n                        return errorObj;\n                    } else if (maybePromise.isPending()) {\n                        maybePromise._attachCancellationCallback(\n                            new FinallyHandlerCancelReaction(this));\n                    }\n                }\n                return maybePromise._then(\n                    succeed, fail, undefined, this, undefined);\n            }\n        }\n    }\n\n    if (promise.isRejected()) {\n        checkCancel(this);\n        errorObj.e = reasonOrValue;\n        return errorObj;\n    } else {\n        checkCancel(this);\n        return reasonOrValue;\n    }\n}\n\nPromise.prototype._passThrough = function(handler, type, success, fail) {\n    if (typeof handler !== \"function\") return this.then();\n    return this._then(success,\n                      fail,\n                      undefined,\n                      new PassThroughHandlerContext(this, type, handler),\n                      undefined);\n};\n\nPromise.prototype.lastly =\nPromise.prototype[\"finally\"] = function (handler) {\n    return this._passThrough(handler,\n                             0,\n                             finallyHandler,\n                             finallyHandler);\n};\n\n\nPromise.prototype.tap = function (handler) {\n    return this._passThrough(handler, 1, finallyHandler);\n};\n\nPromise.prototype.tapCatch = function (handlerOrPredicate) {\n    var len = arguments.length;\n    if(len === 1) {\n        return this._passThrough(handlerOrPredicate,\n                                 1,\n                                 undefined,\n                                 finallyHandler);\n    } else {\n         var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (util.isObject(item)) {\n                catchInstances[j++] = item;\n            } else {\n                return Promise.reject(new TypeError(\n                    \"tapCatch statement predicate: \"\n                    + \"expecting an object but got \" + util.classString(item)\n                ));\n            }\n        }\n        catchInstances.length = j;\n        var handler = arguments[i];\n        return this._passThrough(catchFilter(catchInstances, handler, this),\n                                 1,\n                                 undefined,\n                                 finallyHandler);\n    }\n\n};\n\nreturn PassThroughHandlerContext;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9maW5hbGx5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZmluYWxseS5qcz80YzcxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBORVhUX0ZJTFRFUikge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIENhbmNlbGxhdGlvbkVycm9yID0gUHJvbWlzZS5DYW5jZWxsYXRpb25FcnJvcjtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgY2F0Y2hGaWx0ZXIgPSByZXF1aXJlKFwiLi9jYXRjaF9maWx0ZXJcIikoTkVYVF9GSUxURVIpO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0KHByb21pc2UsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICB0aGlzLmNhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsUHJvbWlzZSA9IG51bGw7XG59XG5cblBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQucHJvdG90eXBlLmlzRmluYWxseUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSAwO1xufTtcblxuZnVuY3Rpb24gRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbihmaW5hbGx5SGFuZGxlcikge1xuICAgIHRoaXMuZmluYWxseUhhbmRsZXIgPSBmaW5hbGx5SGFuZGxlcjtcbn1cblxuRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbi5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGNoZWNrQ2FuY2VsKHRoaXMuZmluYWxseUhhbmRsZXIpO1xufTtcblxuZnVuY3Rpb24gY2hlY2tDYW5jZWwoY3R4LCByZWFzb24pIHtcbiAgICBpZiAoY3R4LmNhbmNlbFByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGN0eC5jYW5jZWxQcm9taXNlLl9yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5jYW5jZWxQcm9taXNlLl9jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2FuY2VsUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHN1Y2NlZWQoKSB7XG4gICAgcmV0dXJuIGZpbmFsbHlIYW5kbGVyLmNhbGwodGhpcywgdGhpcy5wcm9taXNlLl90YXJnZXQoKS5fc2V0dGxlZFZhbHVlKCkpO1xufVxuZnVuY3Rpb24gZmFpbChyZWFzb24pIHtcbiAgICBpZiAoY2hlY2tDYW5jZWwodGhpcywgcmVhc29uKSkgcmV0dXJuO1xuICAgIGVycm9yT2JqLmUgPSByZWFzb247XG4gICAgcmV0dXJuIGVycm9yT2JqO1xufVxuZnVuY3Rpb24gZmluYWxseUhhbmRsZXIocmVhc29uT3JWYWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyO1xuXG4gICAgaWYgKCF0aGlzLmNhbGxlZCkge1xuICAgICAgICB0aGlzLmNhbGxlZCA9IHRydWU7XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmlzRmluYWxseUhhbmRsZXIoKVxuICAgICAgICAgICAgPyBoYW5kbGVyLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpKVxuICAgICAgICAgICAgOiBoYW5kbGVyLmNhbGwocHJvbWlzZS5fYm91bmRWYWx1ZSgpLCByZWFzb25PclZhbHVlKTtcbiAgICAgICAgaWYgKHJldCA9PT0gTkVYVF9GSUxURVIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb21pc2UuX3NldFJldHVybmVkTm9uVW5kZWZpbmVkKCk7XG4gICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXQsIHByb21pc2UpO1xuICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5jZWxQcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZS5faXNDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IENhbmNlbGxhdGlvbkVycm9yKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck9iai5lID0gcmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1heWJlUHJvbWlzZS5pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9hdHRhY2hDYW5jZWxsYXRpb25DYWxsYmFjayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRmluYWxseUhhbmRsZXJDYW5jZWxSZWFjdGlvbih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZS5fdGhlbihcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VlZCwgZmFpbCwgdW5kZWZpbmVkLCB0aGlzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UuaXNSZWplY3RlZCgpKSB7XG4gICAgICAgIGNoZWNrQ2FuY2VsKHRoaXMpO1xuICAgICAgICBlcnJvck9iai5lID0gcmVhc29uT3JWYWx1ZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrQ2FuY2VsKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVhc29uT3JWYWx1ZTtcbiAgICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLl9wYXNzVGhyb3VnaCA9IGZ1bmN0aW9uKGhhbmRsZXIsIHR5cGUsIHN1Y2Nlc3MsIGZhaWwpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRoaXMudGhlbigpO1xuICAgIHJldHVybiB0aGlzLl90aGVuKHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgZmFpbCxcbiAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3IFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQodGhpcywgdHlwZSwgaGFuZGxlciksXG4gICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmxhc3RseSA9XG5Qcm9taXNlLnByb3RvdHlwZVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChoYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseUhhbmRsZXIpO1xufTtcblxuXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChoYW5kbGVyLCAxLCBmaW5hbGx5SGFuZGxlcik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50YXBDYXRjaCA9IGZ1bmN0aW9uIChoYW5kbGVyT3JQcmVkaWNhdGUpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZihsZW4gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bhc3NUaHJvdWdoKGhhbmRsZXJPclByZWRpY2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5SGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgIHZhciBjYXRjaEluc3RhbmNlcyA9IG5ldyBBcnJheShsZW4gLSAxKSxcbiAgICAgICAgICAgIGogPSAwLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgY2F0Y2hJbnN0YW5jZXNbaisrXSA9IGl0ZW07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcInRhcENhdGNoIHN0YXRlbWVudCBwcmVkaWNhdGU6IFwiXG4gICAgICAgICAgICAgICAgICAgICsgXCJleHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGl0ZW0pXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2hJbnN0YW5jZXMubGVuZ3RoID0gajtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXNzVGhyb3VnaChjYXRjaEZpbHRlcihjYXRjaEluc3RhbmNlcywgaGFuZGxlciwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseUhhbmRsZXIpO1xuICAgIH1cblxufTtcblxucmV0dXJuIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQ7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/finally.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/generators.js":
/*!********************************************************!*\
  !*** ./node_modules/bluebird/js/release/generators.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          apiRejection,\n                          INTERNAL,\n                          tryConvertToPromise,\n                          Proxyable,\n                          debug) {\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\");\nvar TypeError = errors.TypeError;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nvar yieldHandlers = [];\n\nfunction promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n    for (var i = 0; i < yieldHandlers.length; ++i) {\n        traceParent._pushContext();\n        var result = tryCatch(yieldHandlers[i])(value);\n        traceParent._popContext();\n        if (result === errorObj) {\n            traceParent._pushContext();\n            var ret = Promise.reject(errorObj.e);\n            traceParent._popContext();\n            return ret;\n        }\n        var maybePromise = tryConvertToPromise(result, traceParent);\n        if (maybePromise instanceof Promise) return maybePromise;\n    }\n    return null;\n}\n\nfunction PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n    if (debug.cancellation()) {\n        var internal = new Promise(INTERNAL);\n        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);\n        this._promise = internal.lastly(function() {\n            return _finallyPromise;\n        });\n        internal._captureStackTrace();\n        internal._setOnCancel(this);\n    } else {\n        var promise = this._promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n    }\n    this._stack = stack;\n    this._generatorFunction = generatorFunction;\n    this._receiver = receiver;\n    this._generator = undefined;\n    this._yieldHandlers = typeof yieldHandler === \"function\"\n        ? [yieldHandler].concat(yieldHandlers)\n        : yieldHandlers;\n    this._yieldedPromise = null;\n    this._cancellationPhase = false;\n}\nutil.inherits(PromiseSpawn, Proxyable);\n\nPromiseSpawn.prototype._isResolved = function() {\n    return this._promise === null;\n};\n\nPromiseSpawn.prototype._cleanup = function() {\n    this._promise = this._generator = null;\n    if (debug.cancellation() && this._finallyPromise !== null) {\n        this._finallyPromise._fulfill();\n        this._finallyPromise = null;\n    }\n};\n\nPromiseSpawn.prototype._promiseCancelled = function() {\n    if (this._isResolved()) return;\n    var implementsReturn = typeof this._generator[\"return\"] !== \"undefined\";\n\n    var result;\n    if (!implementsReturn) {\n        var reason = new Promise.CancellationError(\n            \"generator .return() sentinel\");\n        Promise.coroutine.returnSentinel = reason;\n        this._promise._attachExtraTrace(reason);\n        this._promise._pushContext();\n        result = tryCatch(this._generator[\"throw\"]).call(this._generator,\n                                                         reason);\n        this._promise._popContext();\n    } else {\n        this._promise._pushContext();\n        result = tryCatch(this._generator[\"return\"]).call(this._generator,\n                                                          undefined);\n        this._promise._popContext();\n    }\n    this._cancellationPhase = true;\n    this._yieldedPromise = null;\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._promiseFulfilled = function(value) {\n    this._yieldedPromise = null;\n    this._promise._pushContext();\n    var result = tryCatch(this._generator.next).call(this._generator, value);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._promiseRejected = function(reason) {\n    this._yieldedPromise = null;\n    this._promise._attachExtraTrace(reason);\n    this._promise._pushContext();\n    var result = tryCatch(this._generator[\"throw\"])\n        .call(this._generator, reason);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._resultCancelled = function() {\n    if (this._yieldedPromise instanceof Promise) {\n        var promise = this._yieldedPromise;\n        this._yieldedPromise = null;\n        promise.cancel();\n    }\n};\n\nPromiseSpawn.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseSpawn.prototype._run = function () {\n    this._generator = this._generatorFunction.call(this._receiver);\n    this._receiver =\n        this._generatorFunction = undefined;\n    this._promiseFulfilled(undefined);\n};\n\nPromiseSpawn.prototype._continue = function (result) {\n    var promise = this._promise;\n    if (result === errorObj) {\n        this._cleanup();\n        if (this._cancellationPhase) {\n            return promise.cancel();\n        } else {\n            return promise._rejectCallback(result.e, false);\n        }\n    }\n\n    var value = result.value;\n    if (result.done === true) {\n        this._cleanup();\n        if (this._cancellationPhase) {\n            return promise.cancel();\n        } else {\n            return promise._resolveCallback(value);\n        }\n    } else {\n        var maybePromise = tryConvertToPromise(value, this._promise);\n        if (!(maybePromise instanceof Promise)) {\n            maybePromise =\n                promiseFromYieldHandler(maybePromise,\n                                        this._yieldHandlers,\n                                        this._promise);\n            if (maybePromise === null) {\n                this._promiseRejected(\n                    new TypeError(\n                        \"A value %s was yielded that could not be treated as a promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\\u000a\".replace(\"%s\", String(value)) +\n                        \"From coroutine:\\u000a\" +\n                        this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")\n                    )\n                );\n                return;\n            }\n        }\n        maybePromise = maybePromise._target();\n        var bitField = maybePromise._bitField;\n        ;\n        if (((bitField & 50397184) === 0)) {\n            this._yieldedPromise = maybePromise;\n            maybePromise._proxy(this, null);\n        } else if (((bitField & 33554432) !== 0)) {\n            Promise._async.invoke(\n                this._promiseFulfilled, this, maybePromise._value()\n            );\n        } else if (((bitField & 16777216) !== 0)) {\n            Promise._async.invoke(\n                this._promiseRejected, this, maybePromise._reason()\n            );\n        } else {\n            this._promiseCancelled();\n        }\n    }\n};\n\nPromise.coroutine = function (generatorFunction, options) {\n    if (typeof generatorFunction !== \"function\") {\n        throw new TypeError(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var yieldHandler = Object(options).yieldHandler;\n    var PromiseSpawn$ = PromiseSpawn;\n    var stack = new Error().stack;\n    return function () {\n        var generator = generatorFunction.apply(this, arguments);\n        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,\n                                      stack);\n        var ret = spawn.promise();\n        spawn._generator = generator;\n        spawn._promiseFulfilled(undefined);\n        return ret;\n    };\n};\n\nPromise.coroutine.addYieldHandler = function(fn) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    yieldHandlers.push(fn);\n};\n\nPromise.spawn = function (generatorFunction) {\n    debug.deprecated(\"Promise.spawn()\", \"Promise.coroutine()\");\n    if (typeof generatorFunction !== \"function\") {\n        return apiRejection(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var spawn = new PromiseSpawn(generatorFunction, this);\n    var ret = spawn.promise();\n    spawn._run(Promise.spawn);\n    return ret;\n};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9nZW5lcmF0b3JzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvZ2VuZXJhdG9ycy5qcz9hODViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQcm94eWFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKSB7XG52YXIgZXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIFR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIHRyeUNhdGNoID0gdXRpbC50cnlDYXRjaDtcbnZhciB5aWVsZEhhbmRsZXJzID0gW107XG5cbmZ1bmN0aW9uIHByb21pc2VGcm9tWWllbGRIYW5kbGVyKHZhbHVlLCB5aWVsZEhhbmRsZXJzLCB0cmFjZVBhcmVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeWllbGRIYW5kbGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0cmFjZVBhcmVudC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHlpZWxkSGFuZGxlcnNbaV0pKHZhbHVlKTtcbiAgICAgICAgdHJhY2VQYXJlbnQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgIHRyYWNlUGFyZW50Ll9wdXNoQ29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHJldCA9IFByb21pc2UucmVqZWN0KGVycm9yT2JqLmUpO1xuICAgICAgICAgICAgdHJhY2VQYXJlbnQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocmVzdWx0LCB0cmFjZVBhcmVudCk7XG4gICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gbWF5YmVQcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvbWlzZVNwYXduKGdlbmVyYXRvckZ1bmN0aW9uLCByZWNlaXZlciwgeWllbGRIYW5kbGVyLCBzdGFjaykge1xuICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSkge1xuICAgICAgICB2YXIgaW50ZXJuYWwgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIHZhciBfZmluYWxseVByb21pc2UgPSB0aGlzLl9maW5hbGx5UHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZSA9IGludGVybmFsLmxhc3RseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmluYWxseVByb21pc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnRlcm5hbC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICAgICAgaW50ZXJuYWwuX3NldE9uQ2FuY2VsKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmN0aW9uO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fZ2VuZXJhdG9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3lpZWxkSGFuZGxlcnMgPSB0eXBlb2YgeWllbGRIYW5kbGVyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBbeWllbGRIYW5kbGVyXS5jb25jYXQoeWllbGRIYW5kbGVycylcbiAgICAgICAgOiB5aWVsZEhhbmRsZXJzO1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSA9IGZhbHNlO1xufVxudXRpbC5pbmhlcml0cyhQcm9taXNlU3Bhd24sIFByb3h5YWJsZSk7XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2lzUmVzb2x2ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZSA9PT0gbnVsbDtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wcm9taXNlID0gdGhpcy5fZ2VuZXJhdG9yID0gbnVsbDtcbiAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkgJiYgdGhpcy5fZmluYWxseVByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZmluYWxseVByb21pc2UuX2Z1bGZpbGwoKTtcbiAgICAgICAgdGhpcy5fZmluYWxseVByb21pc2UgPSBudWxsO1xuICAgIH1cbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5faXNSZXNvbHZlZCgpKSByZXR1cm47XG4gICAgdmFyIGltcGxlbWVudHNSZXR1cm4gPSB0eXBlb2YgdGhpcy5fZ2VuZXJhdG9yW1wicmV0dXJuXCJdICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAoIWltcGxlbWVudHNSZXR1cm4pIHtcbiAgICAgICAgdmFyIHJlYXNvbiA9IG5ldyBQcm9taXNlLkNhbmNlbGxhdGlvbkVycm9yKFxuICAgICAgICAgICAgXCJnZW5lcmF0b3IgLnJldHVybigpIHNlbnRpbmVsXCIpO1xuICAgICAgICBQcm9taXNlLmNvcm91dGluZS5yZXR1cm5TZW50aW5lbCA9IHJlYXNvbjtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgICAgICByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3JbXCJ0aHJvd1wiXSkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24pO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1wicmV0dXJuXCJdKS5jYWxsKHRoaXMuX2dlbmVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgfVxuICAgIHRoaXMuX2NhbmNlbGxhdGlvblBoYXNlID0gdHJ1ZTtcbiAgICB0aGlzLl95aWVsZGVkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLl9nZW5lcmF0b3IubmV4dCkuY2FsbCh0aGlzLl9nZW5lcmF0b3IsIHZhbHVlKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Byb21pc2VSZWplY3RlZCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIHRoaXMuX3lpZWxkZWRQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHJlYXNvbik7XG4gICAgdGhpcy5fcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2godGhpcy5fZ2VuZXJhdG9yW1widGhyb3dcIl0pXG4gICAgICAgIC5jYWxsKHRoaXMuX2dlbmVyYXRvciwgcmVhc29uKTtcbiAgICB0aGlzLl9wcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgdGhpcy5fY29udGludWUocmVzdWx0KTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl95aWVsZGVkUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl95aWVsZGVkUHJvbWlzZTtcbiAgICAgICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBudWxsO1xuICAgICAgICBwcm9taXNlLmNhbmNlbCgpO1xuICAgIH1cbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX3J1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9nZW5lcmF0b3IgPSB0aGlzLl9nZW5lcmF0b3JGdW5jdGlvbi5jYWxsKHRoaXMuX3JlY2VpdmVyKTtcbiAgICB0aGlzLl9yZWNlaXZlciA9XG4gICAgICAgIHRoaXMuX2dlbmVyYXRvckZ1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Byb21pc2VGdWxmaWxsZWQodW5kZWZpbmVkKTtcbn07XG5cblByb21pc2VTcGF3bi5wcm90b3R5cGUuX2NvbnRpbnVlID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZTtcbiAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iaikge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgIGlmICh0aGlzLl9jYW5jZWxsYXRpb25QaGFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVzdWx0LmUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICBpZiAocmVzdWx0LmRvbmUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICBpZiAodGhpcy5fY2FuY2VsbGF0aW9uUGhhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZSwgdGhpcy5fcHJvbWlzZSk7XG4gICAgICAgIGlmICghKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UgPVxuICAgICAgICAgICAgICAgIHByb21pc2VGcm9tWWllbGRIYW5kbGVyKG1heWJlUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl95aWVsZEhhbmRsZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2UpO1xuICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb21pc2VSZWplY3RlZChcbiAgICAgICAgICAgICAgICAgICAgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQSB2YWx1ZSAlcyB3YXMgeWllbGRlZCB0aGF0IGNvdWxkIG5vdCBiZSB0cmVhdGVkIGFzIGEgcHJvbWlzZVxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcXHUwMDBhXCIucmVwbGFjZShcIiVzXCIsIFN0cmluZyh2YWx1ZSkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRnJvbSBjb3JvdXRpbmU6XFx1MDAwYVwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDEsIC03KS5qb2luKFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UuX3RhcmdldCgpO1xuICAgICAgICB2YXIgYml0RmllbGQgPSBtYXliZVByb21pc2UuX2JpdEZpZWxkO1xuICAgICAgICA7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5feWllbGRlZFByb21pc2UgPSBtYXliZVByb21pc2U7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuX3Byb3h5KHRoaXMsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICBQcm9taXNlLl9hc3luYy5pbnZva2UoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZCwgdGhpcywgbWF5YmVQcm9taXNlLl92YWx1ZSgpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAxNjc3NzIxNikgIT09IDApKSB7XG4gICAgICAgICAgICBQcm9taXNlLl9hc3luYy5pbnZva2UoXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvbWlzZVJlamVjdGVkLCB0aGlzLCBtYXliZVByb21pc2UuX3JlYXNvbigpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcHJvbWlzZUNhbmNlbGxlZCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5jb3JvdXRpbmUgPSBmdW5jdGlvbiAoZ2VuZXJhdG9yRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGdlbmVyYXRvckZ1bmN0aW9uICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImdlbmVyYXRvckZ1bmN0aW9uIG11c3QgYmUgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIHZhciB5aWVsZEhhbmRsZXIgPSBPYmplY3Qob3B0aW9ucykueWllbGRIYW5kbGVyO1xuICAgIHZhciBQcm9taXNlU3Bhd24kID0gUHJvbWlzZVNwYXduO1xuICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBnZW5lcmF0b3JGdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgc3Bhd24gPSBuZXcgUHJvbWlzZVNwYXduJCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgeWllbGRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjayk7XG4gICAgICAgIHZhciByZXQgPSBzcGF3bi5wcm9taXNlKCk7XG4gICAgICAgIHNwYXduLl9nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgIHNwYXduLl9wcm9taXNlRnVsZmlsbGVkKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn07XG5cblByb21pc2UuY29yb3V0aW5lLmFkZFlpZWxkSGFuZGxlciA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICB5aWVsZEhhbmRsZXJzLnB1c2goZm4pO1xufTtcblxuUHJvbWlzZS5zcGF3biA9IGZ1bmN0aW9uIChnZW5lcmF0b3JGdW5jdGlvbikge1xuICAgIGRlYnVnLmRlcHJlY2F0ZWQoXCJQcm9taXNlLnNwYXduKClcIiwgXCJQcm9taXNlLmNvcm91dGluZSgpXCIpO1xuICAgIGlmICh0eXBlb2YgZ2VuZXJhdG9yRnVuY3Rpb24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZ2VuZXJhdG9yRnVuY3Rpb24gbXVzdCBiZSBhIGZ1bmN0aW9uXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHNwYXduID0gbmV3IFByb21pc2VTcGF3bihnZW5lcmF0b3JGdW5jdGlvbiwgdGhpcyk7XG4gICAgdmFyIHJldCA9IHNwYXduLnByb21pc2UoKTtcbiAgICBzcGF3bi5fcnVuKFByb21pc2Uuc3Bhd24pO1xuICAgIHJldHVybiByZXQ7XG59O1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/generators.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/join.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/release/join.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,\n         getDomain) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar canEvaluate = util.canEvaluate;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar reject;\n\nif (true) {\nif (canEvaluate) {\n    var thenCallback = function(i) {\n        return new Function(\"value\", \"holder\", \"                             \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = value;                                           \\n\\\n            holder.checkFulfillment(this);                                   \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var promiseSetter = function(i) {\n        return new Function(\"promise\", \"holder\", \"                           \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = promise;                                         \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var generateHolderClass = function(total) {\n        var props = new Array(total);\n        for (var i = 0; i < props.length; ++i) {\n            props[i] = \"this.p\" + (i+1);\n        }\n        var assignment = props.join(\" = \") + \" = null;\";\n        var cancellationCode= \"var promise;\\n\" + props.map(function(prop) {\n            return \"                                                         \\n\\\n                promise = \" + prop + \";                                      \\n\\\n                if (promise instanceof Promise) {                            \\n\\\n                    promise.cancel();                                        \\n\\\n                }                                                            \\n\\\n            \";\n        }).join(\"\\n\");\n        var passedArguments = props.join(\", \");\n        var name = \"Holder$\" + total;\n\n\n        var code = \"return function(tryCatch, errorObj, Promise, async) {    \\n\\\n            'use strict';                                                    \\n\\\n            function [TheName](fn) {                                         \\n\\\n                [TheProperties]                                              \\n\\\n                this.fn = fn;                                                \\n\\\n                this.asyncNeeded = true;                                     \\n\\\n                this.now = 0;                                                \\n\\\n            }                                                                \\n\\\n                                                                             \\n\\\n            [TheName].prototype._callFunction = function(promise) {          \\n\\\n                promise._pushContext();                                      \\n\\\n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \\n\\\n                promise._popContext();                                       \\n\\\n                if (ret === errorObj) {                                      \\n\\\n                    promise._rejectCallback(ret.e, false);                   \\n\\\n                } else {                                                     \\n\\\n                    promise._resolveCallback(ret);                           \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype.checkFulfillment = function(promise) {       \\n\\\n                var now = ++this.now;                                        \\n\\\n                if (now === [TheTotal]) {                                    \\n\\\n                    if (this.asyncNeeded) {                                  \\n\\\n                        async.invoke(this._callFunction, this, promise);     \\n\\\n                    } else {                                                 \\n\\\n                        this._callFunction(promise);                         \\n\\\n                    }                                                        \\n\\\n                                                                             \\n\\\n                }                                                            \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            [TheName].prototype._resultCancelled = function() {              \\n\\\n                [CancellationCode]                                           \\n\\\n            };                                                               \\n\\\n                                                                             \\n\\\n            return [TheName];                                                \\n\\\n        }(tryCatch, errorObj, Promise, async);                               \\n\\\n        \";\n\n        code = code.replace(/\\[TheName\\]/g, name)\n            .replace(/\\[TheTotal\\]/g, total)\n            .replace(/\\[ThePassedArguments\\]/g, passedArguments)\n            .replace(/\\[TheProperties\\]/g, assignment)\n            .replace(/\\[CancellationCode\\]/g, cancellationCode);\n\n        return new Function(\"tryCatch\", \"errorObj\", \"Promise\", \"async\", code)\n                           (tryCatch, errorObj, Promise, async);\n    };\n\n    var holderClasses = [];\n    var thenCallbacks = [];\n    var promiseSetters = [];\n\n    for (var i = 0; i < 8; ++i) {\n        holderClasses.push(generateHolderClass(i + 1));\n        thenCallbacks.push(thenCallback(i + 1));\n        promiseSetters.push(promiseSetter(i + 1));\n    }\n\n    reject = function (reason) {\n        this._reject(reason);\n    };\n}}\n\nPromise.join = function () {\n    var last = arguments.length - 1;\n    var fn;\n    if (last > 0 && typeof arguments[last] === \"function\") {\n        fn = arguments[last];\n        if (true) {\n            if (last <= 8 && canEvaluate) {\n                var ret = new Promise(INTERNAL);\n                ret._captureStackTrace();\n                var HolderClass = holderClasses[last - 1];\n                var holder = new HolderClass(fn);\n                var callbacks = thenCallbacks;\n\n                for (var i = 0; i < last; ++i) {\n                    var maybePromise = tryConvertToPromise(arguments[i], ret);\n                    if (maybePromise instanceof Promise) {\n                        maybePromise = maybePromise._target();\n                        var bitField = maybePromise._bitField;\n                        ;\n                        if (((bitField & 50397184) === 0)) {\n                            maybePromise._then(callbacks[i], reject,\n                                               undefined, ret, holder);\n                            promiseSetters[i](maybePromise, holder);\n                            holder.asyncNeeded = false;\n                        } else if (((bitField & 33554432) !== 0)) {\n                            callbacks[i].call(ret,\n                                              maybePromise._value(), holder);\n                        } else if (((bitField & 16777216) !== 0)) {\n                            ret._reject(maybePromise._reason());\n                        } else {\n                            ret._cancel();\n                        }\n                    } else {\n                        callbacks[i].call(ret, maybePromise, holder);\n                    }\n                }\n\n                if (!ret._isFateSealed()) {\n                    if (holder.asyncNeeded) {\n                        var domain = getDomain();\n                        if (domain !== null) {\n                            holder.fn = util.domainBind(domain, holder.fn);\n                        }\n                    }\n                    ret._setAsyncGuaranteed();\n                    ret._setOnCancel(holder);\n                }\n                return ret;\n            }\n        }\n    }\n    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];};\n    if (fn) args.pop();\n    var ret = new PromiseArray(args).promise();\n    return fn !== undefined ? ret.spread(fn) : ret;\n};\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9qb2luLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2Uvam9pbi5qcz82ZjVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgYXN5bmMsXG4gICAgICAgICBnZXREb21haW4pIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xudmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbnZhciByZWplY3Q7XG5cbmlmICghZmFsc2UpIHtcbmlmIChjYW5FdmFsdWF0ZSkge1xuICAgIHZhciB0aGVuQ2FsbGJhY2sgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJ2YWx1ZVwiLCBcImhvbGRlclwiLCBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGhvbGRlci5wSW5kZXggPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGhvbGRlci5jaGVja0Z1bGZpbGxtZW50KHRoaXMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIFwiLnJlcGxhY2UoL0luZGV4L2csIGkpKTtcbiAgICB9O1xuXG4gICAgdmFyIHByb21pc2VTZXR0ZXIgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJwcm9taXNlXCIsIFwiaG9sZGVyXCIsIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGhvbGRlci5wSW5kZXggPSBwcm9taXNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIFwiLnJlcGxhY2UoL0luZGV4L2csIGkpKTtcbiAgICB9O1xuXG4gICAgdmFyIGdlbmVyYXRlSG9sZGVyQ2xhc3MgPSBmdW5jdGlvbih0b3RhbCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBuZXcgQXJyYXkodG90YWwpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBwcm9wc1tpXSA9IFwidGhpcy5wXCIgKyAoaSsxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXNzaWdubWVudCA9IHByb3BzLmpvaW4oXCIgPSBcIikgKyBcIiA9IG51bGw7XCI7XG4gICAgICAgIHZhciBjYW5jZWxsYXRpb25Db2RlPSBcInZhciBwcm9taXNlO1xcblwiICsgcHJvcHMubWFwKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IFwiICsgcHJvcCArIFwiOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5jYW5jZWwoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIFwiO1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgICAgICB2YXIgcGFzc2VkQXJndW1lbnRzID0gcHJvcHMuam9pbihcIiwgXCIpO1xuICAgICAgICB2YXIgbmFtZSA9IFwiSG9sZGVyJFwiICsgdG90YWw7XG5cblxuICAgICAgICB2YXIgY29kZSA9IFwicmV0dXJuIGZ1bmN0aW9uKHRyeUNhdGNoLCBlcnJvck9iaiwgUHJvbWlzZSwgYXN5bmMpIHsgICAgXFxuXFxcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGZ1bmN0aW9uIFtUaGVOYW1lXShmbikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBbVGhlUHJvcGVydGllc10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICB0aGlzLmZuID0gZm47ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICB0aGlzLmFzeW5jTmVlZGVkID0gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICB0aGlzLm5vdyA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIFtUaGVOYW1lXS5wcm90b3R5cGUuX2NhbGxGdW5jdGlvbiA9IGZ1bmN0aW9uKHByb21pc2UpIHsgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gdHJ5Q2F0Y2godGhpcy5mbikoW1RoZVBhc3NlZEFyZ3VtZW50c10pOyAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9wb3BDb250ZXh0KCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmV0LmUsIGZhbHNlKTsgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVzb2x2ZUNhbGxiYWNrKHJldCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIFtUaGVOYW1lXS5wcm90b3R5cGUuY2hlY2tGdWxmaWxsbWVudCA9IGZ1bmN0aW9uKHByb21pc2UpIHsgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICB2YXIgbm93ID0gKyt0aGlzLm5vdzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBpZiAobm93ID09PSBbVGhlVG90YWxdKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXN5bmNOZWVkZWQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jLmludm9rZSh0aGlzLl9jYWxsRnVuY3Rpb24sIHRoaXMsIHByb21pc2UpOyAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxGdW5jdGlvbihwcm9taXNlKTsgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIFtUaGVOYW1lXS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkgeyAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICBbQ2FuY2VsbGF0aW9uQ29kZV0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHJldHVybiBbVGhlTmFtZV07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgfSh0cnlDYXRjaCwgZXJyb3JPYmosIFByb21pc2UsIGFzeW5jKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgXCI7XG5cbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZSgvXFxbVGhlTmFtZVxcXS9nLCBuYW1lKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcW1RoZVRvdGFsXFxdL2csIHRvdGFsKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcW1RoZVBhc3NlZEFyZ3VtZW50c1xcXS9nLCBwYXNzZWRBcmd1bWVudHMpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbVGhlUHJvcGVydGllc1xcXS9nLCBhc3NpZ25tZW50KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcW0NhbmNlbGxhdGlvbkNvZGVcXF0vZywgY2FuY2VsbGF0aW9uQ29kZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInRyeUNhdGNoXCIsIFwiZXJyb3JPYmpcIiwgXCJQcm9taXNlXCIsIFwiYXN5bmNcIiwgY29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICh0cnlDYXRjaCwgZXJyb3JPYmosIFByb21pc2UsIGFzeW5jKTtcbiAgICB9O1xuXG4gICAgdmFyIGhvbGRlckNsYXNzZXMgPSBbXTtcbiAgICB2YXIgdGhlbkNhbGxiYWNrcyA9IFtdO1xuICAgIHZhciBwcm9taXNlU2V0dGVycyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICAgICAgaG9sZGVyQ2xhc3Nlcy5wdXNoKGdlbmVyYXRlSG9sZGVyQ2xhc3MoaSArIDEpKTtcbiAgICAgICAgdGhlbkNhbGxiYWNrcy5wdXNoKHRoZW5DYWxsYmFjayhpICsgMSkpO1xuICAgICAgICBwcm9taXNlU2V0dGVycy5wdXNoKHByb21pc2VTZXR0ZXIoaSArIDEpKTtcbiAgICB9XG5cbiAgICByZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xuICAgIH07XG59fVxuXG5Qcm9taXNlLmpvaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhc3QgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgZm47XG4gICAgaWYgKGxhc3QgPiAwICYmIHR5cGVvZiBhcmd1bWVudHNbbGFzdF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBmbiA9IGFyZ3VtZW50c1tsYXN0XTtcbiAgICAgICAgaWYgKCFmYWxzZSkge1xuICAgICAgICAgICAgaWYgKGxhc3QgPD0gOCAmJiBjYW5FdmFsdWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgICAgICAgICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgIHZhciBIb2xkZXJDbGFzcyA9IGhvbGRlckNsYXNzZXNbbGFzdCAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBob2xkZXIgPSBuZXcgSG9sZGVyQ2xhc3MoZm4pO1xuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSB0aGVuQ2FsbGJhY2tzO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UoYXJndW1lbnRzW2ldLCByZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiaXRGaWVsZCA9IG1heWJlUHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3RoZW4oY2FsbGJhY2tzW2ldLCByZWplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgcmV0LCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VTZXR0ZXJzW2ldKG1heWJlUHJvbWlzZSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuYXN5bmNOZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChyZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl92YWx1ZSgpLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5fcmVqZWN0KG1heWJlUHJvbWlzZS5fcmVhc29uKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQuX2NhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwocmV0LCBtYXliZVByb21pc2UsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJldC5faXNGYXRlU2VhbGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5hc3luY05lZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5mbiA9IHV0aWwuZG9tYWluQmluZChkb21haW4sIGhvbGRlci5mbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9zZXRPbkNhbmNlbChob2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciAkX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7dmFyIGFyZ3MgPSBuZXcgQXJyYXkoJF9sZW4pOyBmb3IodmFyICRfaSA9IDA7ICRfaSA8ICRfbGVuOyArKyRfaSkge2FyZ3NbJF9pXSA9IGFyZ3VtZW50c1skX2ldO307XG4gICAgaWYgKGZuKSBhcmdzLnBvcCgpO1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZUFycmF5KGFyZ3MpLnByb21pc2UoKTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IHJldC5zcHJlYWQoZm4pIDogcmV0O1xufTtcblxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/join.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/map.js":
/*!*************************************************!*\
  !*** ./node_modules/bluebird/js/release/map.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL,\n                          debug) {\nvar getDomain = Promise._getDomain;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar async = Promise._async;\n\nfunction MappingPromiseArray(promises, fn, limit, _filter) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    var domain = getDomain();\n    this._callback = domain === null ? fn : util.domainBind(domain, fn);\n    this._preservedValues = _filter === INTERNAL\n        ? new Array(this.length())\n        : null;\n    this._limit = limit;\n    this._inFlight = 0;\n    this._queue = [];\n    async.invoke(this._asyncInit, this, undefined);\n}\nutil.inherits(MappingPromiseArray, PromiseArray);\n\nMappingPromiseArray.prototype._asyncInit = function() {\n    this._init$(undefined, -2);\n};\n\nMappingPromiseArray.prototype._init = function () {};\n\nMappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var limit = this._limit;\n\n    if (index < 0) {\n        index = (index * -1) - 1;\n        values[index] = value;\n        if (limit >= 1) {\n            this._inFlight--;\n            this._drainQueue();\n            if (this._isResolved()) return true;\n        }\n    } else {\n        if (limit >= 1 && this._inFlight >= limit) {\n            values[index] = value;\n            this._queue.push(index);\n            return false;\n        }\n        if (preservedValues !== null) preservedValues[index] = value;\n\n        var promise = this._promise;\n        var callback = this._callback;\n        var receiver = promise._boundValue();\n        promise._pushContext();\n        var ret = tryCatch(callback).call(receiver, value, index, length);\n        var promiseCreated = promise._popContext();\n        debug.checkForgottenReturns(\n            ret,\n            promiseCreated,\n            preservedValues !== null ? \"Promise.filter\" : \"Promise.map\",\n            promise\n        );\n        if (ret === errorObj) {\n            this._reject(ret.e);\n            return true;\n        }\n\n        var maybePromise = tryConvertToPromise(ret, this._promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            var bitField = maybePromise._bitField;\n            ;\n            if (((bitField & 50397184) === 0)) {\n                if (limit >= 1) this._inFlight++;\n                values[index] = maybePromise;\n                maybePromise._proxy(this, (index + 1) * -1);\n                return false;\n            } else if (((bitField & 33554432) !== 0)) {\n                ret = maybePromise._value();\n            } else if (((bitField & 16777216) !== 0)) {\n                this._reject(maybePromise._reason());\n                return true;\n            } else {\n                this._cancel();\n                return true;\n            }\n        }\n        values[index] = ret;\n    }\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= length) {\n        if (preservedValues !== null) {\n            this._filter(values, preservedValues);\n        } else {\n            this._resolve(values);\n        }\n        return true;\n    }\n    return false;\n};\n\nMappingPromiseArray.prototype._drainQueue = function () {\n    var queue = this._queue;\n    var limit = this._limit;\n    var values = this._values;\n    while (queue.length > 0 && this._inFlight < limit) {\n        if (this._isResolved()) return;\n        var index = queue.pop();\n        this._promiseFulfilled(values[index], index);\n    }\n};\n\nMappingPromiseArray.prototype._filter = function (booleans, values) {\n    var len = values.length;\n    var ret = new Array(len);\n    var j = 0;\n    for (var i = 0; i < len; ++i) {\n        if (booleans[i]) ret[j++] = values[i];\n    }\n    ret.length = j;\n    this._resolve(ret);\n};\n\nMappingPromiseArray.prototype.preservedValues = function () {\n    return this._preservedValues;\n};\n\nfunction map(promises, fn, options, _filter) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n\n    var limit = 0;\n    if (options !== undefined) {\n        if (typeof options === \"object\" && options !== null) {\n            if (typeof options.concurrency !== \"number\") {\n                return Promise.reject(\n                    new TypeError(\"'concurrency' must be a number but it is \" +\n                                    util.classString(options.concurrency)));\n            }\n            limit = options.concurrency;\n        } else {\n            return Promise.reject(new TypeError(\n                            \"options argument must be an object but it is \" +\n                             util.classString(options)));\n        }\n    }\n    limit = typeof limit === \"number\" &&\n        isFinite(limit) && limit >= 1 ? limit : 0;\n    return new MappingPromiseArray(promises, fn, limit, _filter).promise();\n}\n\nPromise.prototype.map = function (fn, options) {\n    return map(this, fn, options, null);\n};\n\nPromise.map = function (promises, fn, options, _filter) {\n    return map(promises, fn, options, _filter);\n};\n\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9tYXAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9tYXAuanM/MDgyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Zykge1xudmFyIGdldERvbWFpbiA9IFByb21pc2UuX2dldERvbWFpbjtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xudmFyIGFzeW5jID0gUHJvbWlzZS5fYXN5bmM7XG5cbmZ1bmN0aW9uIE1hcHBpbmdQcm9taXNlQXJyYXkocHJvbWlzZXMsIGZuLCBsaW1pdCwgX2ZpbHRlcikge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHByb21pc2VzKTtcbiAgICB0aGlzLl9wcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHZhciBkb21haW4gPSBnZXREb21haW4oKTtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGRvbWFpbiA9PT0gbnVsbCA/IGZuIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZm4pO1xuICAgIHRoaXMuX3ByZXNlcnZlZFZhbHVlcyA9IF9maWx0ZXIgPT09IElOVEVSTkFMXG4gICAgICAgID8gbmV3IEFycmF5KHRoaXMubGVuZ3RoKCkpXG4gICAgICAgIDogbnVsbDtcbiAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgIHRoaXMuX2luRmxpZ2h0ID0gMDtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIGFzeW5jLmludm9rZSh0aGlzLl9hc3luY0luaXQsIHRoaXMsIHVuZGVmaW5lZCk7XG59XG51dGlsLmluaGVyaXRzKE1hcHBpbmdQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9hc3luY0luaXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9pbml0JCh1bmRlZmluZWQsIC0yKTtcbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKCkge307XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdmFyIHByZXNlcnZlZFZhbHVlcyA9IHRoaXMuX3ByZXNlcnZlZFZhbHVlcztcbiAgICB2YXIgbGltaXQgPSB0aGlzLl9saW1pdDtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSAoaW5kZXggKiAtMSkgLSAxO1xuICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIGlmIChsaW1pdCA+PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9pbkZsaWdodC0tO1xuICAgICAgICAgICAgdGhpcy5fZHJhaW5RdWV1ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGltaXQgPj0gMSAmJiB0aGlzLl9pbkZsaWdodCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcXVldWUucHVzaChpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXNlcnZlZFZhbHVlcyAhPT0gbnVsbCkgcHJlc2VydmVkVmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuXG4gICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5fcHJvbWlzZTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5fY2FsbGJhY2s7XG4gICAgICAgIHZhciByZWNlaXZlciA9IHByb21pc2UuX2JvdW5kVmFsdWUoKTtcbiAgICAgICAgcHJvbWlzZS5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHJldCA9IHRyeUNhdGNoKGNhbGxiYWNrKS5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHByb21pc2UuX3BvcENvbnRleHQoKTtcbiAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgcHJvbWlzZUNyZWF0ZWQsXG4gICAgICAgICAgICBwcmVzZXJ2ZWRWYWx1ZXMgIT09IG51bGwgPyBcIlByb21pc2UuZmlsdGVyXCIgOiBcIlByb21pc2UubWFwXCIsXG4gICAgICAgICAgICBwcm9taXNlXG4gICAgICAgICk7XG4gICAgICAgIGlmIChyZXQgPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3QocmV0LmUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXQsIHRoaXMuX3Byb21pc2UpO1xuICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgbWF5YmVQcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcbiAgICAgICAgICAgIHZhciBiaXRGaWVsZCA9IG1heWJlUHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGltaXQgPj0gMSkgdGhpcy5faW5GbGlnaHQrKztcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gbWF5YmVQcm9taXNlO1xuICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZS5fcHJveHkodGhpcywgKGluZGV4ICsgMSkgKiAtMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIHJldCA9IG1heWJlUHJvbWlzZS5fdmFsdWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QobWF5YmVQcm9taXNlLl9yZWFzb24oKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1tpbmRleF0gPSByZXQ7XG4gICAgfVxuICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgIGlmICh0b3RhbFJlc29sdmVkID49IGxlbmd0aCkge1xuICAgICAgICBpZiAocHJlc2VydmVkVmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXIodmFsdWVzLCBwcmVzZXJ2ZWRWYWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5NYXBwaW5nUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fZHJhaW5RdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgICB2YXIgbGltaXQgPSB0aGlzLl9saW1pdDtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy5fdmFsdWVzO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwICYmIHRoaXMuX2luRmxpZ2h0IDwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuO1xuICAgICAgICB2YXIgaW5kZXggPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZCh2YWx1ZXNbaW5kZXhdLCBpbmRleCk7XG4gICAgfVxufTtcblxuTWFwcGluZ1Byb21pc2VBcnJheS5wcm90b3R5cGUuX2ZpbHRlciA9IGZ1bmN0aW9uIChib29sZWFucywgdmFsdWVzKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShsZW4pO1xuICAgIHZhciBqID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGlmIChib29sZWFuc1tpXSkgcmV0W2orK10gPSB2YWx1ZXNbaV07XG4gICAgfVxuICAgIHJldC5sZW5ndGggPSBqO1xuICAgIHRoaXMuX3Jlc29sdmUocmV0KTtcbn07XG5cbk1hcHBpbmdQcm9taXNlQXJyYXkucHJvdG90eXBlLnByZXNlcnZlZFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlc2VydmVkVmFsdWVzO1xufTtcblxuZnVuY3Rpb24gbWFwKHByb21pc2VzLCBmbiwgb3B0aW9ucywgX2ZpbHRlcikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG5cbiAgICB2YXIgbGltaXQgPSAwO1xuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb25jdXJyZW5jeSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgICAgICAgbmV3IFR5cGVFcnJvcihcIidjb25jdXJyZW5jeScgbXVzdCBiZSBhIG51bWJlciBidXQgaXQgaXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhvcHRpb25zLmNvbmN1cnJlbmN5KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGltaXQgPSBvcHRpb25zLmNvbmN1cnJlbmN5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcHRpb25zIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0IGJ1dCBpdCBpcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY2xhc3NTdHJpbmcob3B0aW9ucykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaW1pdCA9IHR5cGVvZiBsaW1pdCA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICBpc0Zpbml0ZShsaW1pdCkgJiYgbGltaXQgPj0gMSA/IGxpbWl0IDogMDtcbiAgICByZXR1cm4gbmV3IE1hcHBpbmdQcm9taXNlQXJyYXkocHJvbWlzZXMsIGZuLCBsaW1pdCwgX2ZpbHRlcikucHJvbWlzZSgpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbWFwKHRoaXMsIGZuLCBvcHRpb25zLCBudWxsKTtcbn07XG5cblByb21pc2UubWFwID0gZnVuY3Rpb24gKHByb21pc2VzLCBmbiwgb3B0aW9ucywgX2ZpbHRlcikge1xuICAgIHJldHVybiBtYXAocHJvbWlzZXMsIGZuLCBvcHRpb25zLCBfZmlsdGVyKTtcbn07XG5cblxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/map.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/method.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/method.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\n\nPromise.method = function (fn) {\n    if (typeof fn !== \"function\") {\n        throw new Promise.TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    return function () {\n        var ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._pushContext();\n        var value = tryCatch(fn).apply(this, arguments);\n        var promiseCreated = ret._popContext();\n        debug.checkForgottenReturns(\n            value, promiseCreated, \"Promise.method\", ret);\n        ret._resolveFromSyncValue(value);\n        return ret;\n    };\n};\n\nPromise.attempt = Promise[\"try\"] = function (fn) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._pushContext();\n    var value;\n    if (arguments.length > 1) {\n        debug.deprecated(\"calling Promise.try with more than 1 argument\");\n        var arg = arguments[1];\n        var ctx = arguments[2];\n        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)\n                                  : tryCatch(fn).call(ctx, arg);\n    } else {\n        value = tryCatch(fn)();\n    }\n    var promiseCreated = ret._popContext();\n    debug.checkForgottenReturns(\n        value, promiseCreated, \"Promise.try\", ret);\n    ret._resolveFromSyncValue(value);\n    return ret;\n};\n\nPromise.prototype._resolveFromSyncValue = function (value) {\n    if (value === util.errorObj) {\n        this._rejectCallback(value.e, false);\n    } else {\n        this._resolveCallback(value, true);\n    }\n};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9tZXRob2QuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9tZXRob2QuanM/OTYzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbmZ1bmN0aW9uKFByb21pc2UsIElOVEVSTkFMLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sIGRlYnVnKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuXG5Qcm9taXNlLm1ldGhvZCA9IGZ1bmN0aW9uIChmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgUHJvbWlzZS5UeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIHJldC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdHJ5Q2F0Y2goZm4pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBwcm9taXNlQ3JlYXRlZCA9IHJldC5fcG9wQ29udGV4dCgpO1xuICAgICAgICBkZWJ1Zy5jaGVja0ZvcmdvdHRlblJldHVybnMoXG4gICAgICAgICAgICB2YWx1ZSwgcHJvbWlzZUNyZWF0ZWQsIFwiUHJvbWlzZS5tZXRob2RcIiwgcmV0KTtcbiAgICAgICAgcmV0Ll9yZXNvbHZlRnJvbVN5bmNWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbn07XG5cblByb21pc2UuYXR0ZW1wdCA9IFByb21pc2VbXCJ0cnlcIl0gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGZuKSk7XG4gICAgfVxuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHJldC5fcHVzaENvbnRleHQoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGRlYnVnLmRlcHJlY2F0ZWQoXCJjYWxsaW5nIFByb21pc2UudHJ5IHdpdGggbW9yZSB0aGFuIDEgYXJndW1lbnRcIik7XG4gICAgICAgIHZhciBhcmcgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBjdHggPSBhcmd1bWVudHNbMl07XG4gICAgICAgIHZhbHVlID0gdXRpbC5pc0FycmF5KGFyZykgPyB0cnlDYXRjaChmbikuYXBwbHkoY3R4LCBhcmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnlDYXRjaChmbikuY2FsbChjdHgsIGFyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB0cnlDYXRjaChmbikoKTtcbiAgICB9XG4gICAgdmFyIHByb21pc2VDcmVhdGVkID0gcmV0Ll9wb3BDb250ZXh0KCk7XG4gICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICB2YWx1ZSwgcHJvbWlzZUNyZWF0ZWQsIFwiUHJvbWlzZS50cnlcIiwgcmV0KTtcbiAgICByZXQuX3Jlc29sdmVGcm9tU3luY1ZhbHVlKHZhbHVlKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Jlc29sdmVGcm9tU3luY1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1dGlsLmVycm9yT2JqKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdENhbGxiYWNrKHZhbHVlLmUsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUsIHRydWUpO1xuICAgIH1cbn07XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/method.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/nodeback.js":
/*!******************************************************!*\
  !*** ./node_modules/bluebird/js/release/nodeback.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\");\nvar OperationalError = errors.OperationalError;\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/bluebird/js/release/es5.js\");\n\nfunction isUntypedError(obj) {\n    return obj instanceof Error &&\n        es5.getPrototypeOf(obj) === Error.prototype;\n}\n\nvar rErrorKey = /^(?:name|message|stack|cause)$/;\nfunction wrapAsOperationalError(obj) {\n    var ret;\n    if (isUntypedError(obj)) {\n        ret = new OperationalError(obj);\n        ret.name = obj.name;\n        ret.message = obj.message;\n        ret.stack = obj.stack;\n        var keys = es5.keys(obj);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!rErrorKey.test(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    util.markAsOriginatingFromRejection(obj);\n    return obj;\n}\n\nfunction nodebackForPromise(promise, multiArgs) {\n    return function(err, value) {\n        if (promise === null) return;\n        if (err) {\n            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n            promise._attachExtraTrace(wrapped);\n            promise._reject(wrapped);\n        } else if (!multiArgs) {\n            promise._fulfill(value);\n        } else {\n            var $_len = arguments.length;var args = new Array(Math.max($_len - 1, 0)); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];};\n            promise._fulfill(args);\n        }\n        promise = null;\n    };\n}\n\nmodule.exports = nodebackForPromise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9ub2RlYmFjay5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL25vZGViYWNrLmpzP2NiNTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgbWF5YmVXcmFwQXNFcnJvciA9IHV0aWwubWF5YmVXcmFwQXNFcnJvcjtcbnZhciBlcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG52YXIgT3BlcmF0aW9uYWxFcnJvciA9IGVycm9ycy5PcGVyYXRpb25hbEVycm9yO1xudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcblxuZnVuY3Rpb24gaXNVbnR5cGVkRXJyb3Iob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgIGVzNS5nZXRQcm90b3R5cGVPZihvYmopID09PSBFcnJvci5wcm90b3R5cGU7XG59XG5cbnZhciByRXJyb3JLZXkgPSAvXig/Om5hbWV8bWVzc2FnZXxzdGFja3xjYXVzZSkkLztcbmZ1bmN0aW9uIHdyYXBBc09wZXJhdGlvbmFsRXJyb3Iob2JqKSB7XG4gICAgdmFyIHJldDtcbiAgICBpZiAoaXNVbnR5cGVkRXJyb3Iob2JqKSkge1xuICAgICAgICByZXQgPSBuZXcgT3BlcmF0aW9uYWxFcnJvcihvYmopO1xuICAgICAgICByZXQubmFtZSA9IG9iai5uYW1lO1xuICAgICAgICByZXQubWVzc2FnZSA9IG9iai5tZXNzYWdlO1xuICAgICAgICByZXQuc3RhY2sgPSBvYmouc3RhY2s7XG4gICAgICAgIHZhciBrZXlzID0gZXM1LmtleXMob2JqKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghckVycm9yS2V5LnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgdXRpbC5tYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24ob2JqKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSwgbXVsdGlBcmdzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVyciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHByb21pc2UgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdmFyIHdyYXBwZWQgPSB3cmFwQXNPcGVyYXRpb25hbEVycm9yKG1heWJlV3JhcEFzRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICBwcm9taXNlLl9hdHRhY2hFeHRyYVRyYWNlKHdyYXBwZWQpO1xuICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHdyYXBwZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKCFtdWx0aUFyZ3MpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyICRfbGVuID0gYXJndW1lbnRzLmxlbmd0aDt2YXIgYXJncyA9IG5ldyBBcnJheShNYXRoLm1heCgkX2xlbiAtIDEsIDApKTsgZm9yKHZhciAkX2kgPSAxOyAkX2kgPCAkX2xlbjsgKyskX2kpIHthcmdzWyRfaSAtIDFdID0gYXJndW1lbnRzWyRfaV07fTtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub2RlYmFja0ZvclByb21pc2U7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/nodeback.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/nodeify.js":
/*!*****************************************************!*\
  !*** ./node_modules/bluebird/js/release/nodeify.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar async = Promise._async;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction spreadAdapter(val, nodeback) {\n    var promise = this;\n    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\n    var ret =\n        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nfunction successAdapter(val, nodeback) {\n    var promise = this;\n    var receiver = promise._boundValue();\n    var ret = val === undefined\n        ? tryCatch(nodeback).call(receiver, null)\n        : tryCatch(nodeback).call(receiver, null, val);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\nfunction errorAdapter(reason, nodeback) {\n    var promise = this;\n    if (!reason) {\n        var newReason = new Error(reason + \"\");\n        newReason.cause = reason;\n        reason = newReason;\n    }\n    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nPromise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,\n                                                                     options) {\n    if (typeof nodeback == \"function\") {\n        var adapter = successAdapter;\n        if (options !== undefined && Object(options).spread) {\n            adapter = spreadAdapter;\n        }\n        this._then(\n            adapter,\n            errorAdapter,\n            undefined,\n            this,\n            nodeback\n        );\n    }\n    return this;\n};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9ub2RlaWZ5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2Uvbm9kZWlmeS5qcz8yZDE5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgYXN5bmMgPSBQcm9taXNlLl9hc3luYztcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG52YXIgZXJyb3JPYmogPSB1dGlsLmVycm9yT2JqO1xuXG5mdW5jdGlvbiBzcHJlYWRBZGFwdGVyKHZhbCwgbm9kZWJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgaWYgKCF1dGlsLmlzQXJyYXkodmFsKSkgcmV0dXJuIHN1Y2Nlc3NBZGFwdGVyLmNhbGwocHJvbWlzZSwgdmFsLCBub2RlYmFjayk7XG4gICAgdmFyIHJldCA9XG4gICAgICAgIHRyeUNhdGNoKG5vZGViYWNrKS5hcHBseShwcm9taXNlLl9ib3VuZFZhbHVlKCksIFtudWxsXS5jb25jYXQodmFsKSk7XG4gICAgaWYgKHJldCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgYXN5bmMudGhyb3dMYXRlcihyZXQuZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzdWNjZXNzQWRhcHRlcih2YWwsIG5vZGViYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciByZWNlaXZlciA9IHByb21pc2UuX2JvdW5kVmFsdWUoKTtcbiAgICB2YXIgcmV0ID0gdmFsID09PSB1bmRlZmluZWRcbiAgICAgICAgPyB0cnlDYXRjaChub2RlYmFjaykuY2FsbChyZWNlaXZlciwgbnVsbClcbiAgICAgICAgOiB0cnlDYXRjaChub2RlYmFjaykuY2FsbChyZWNlaXZlciwgbnVsbCwgdmFsKTtcbiAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKHJldC5lKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlcnJvckFkYXB0ZXIocmVhc29uLCBub2RlYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKHJlYXNvbiArIFwiXCIpO1xuICAgICAgICBuZXdSZWFzb24uY2F1c2UgPSByZWFzb247XG4gICAgICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgICB9XG4gICAgdmFyIHJldCA9IHRyeUNhdGNoKG5vZGViYWNrKS5jYWxsKHByb21pc2UuX2JvdW5kVmFsdWUoKSwgcmVhc29uKTtcbiAgICBpZiAocmV0ID09PSBlcnJvck9iaikge1xuICAgICAgICBhc3luYy50aHJvd0xhdGVyKHJldC5lKTtcbiAgICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLmFzQ2FsbGJhY2sgPSBQcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKG5vZGViYWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygbm9kZWJhY2sgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBhZGFwdGVyID0gc3VjY2Vzc0FkYXB0ZXI7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgT2JqZWN0KG9wdGlvbnMpLnNwcmVhZCkge1xuICAgICAgICAgICAgYWRhcHRlciA9IHNwcmVhZEFkYXB0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGhlbihcbiAgICAgICAgICAgIGFkYXB0ZXIsXG4gICAgICAgICAgICBlcnJvckFkYXB0ZXIsXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgbm9kZWJhY2tcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/nodeify.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/promise.js":
/*!*****************************************************!*\
  !*** ./node_modules/bluebird/js/release/promise.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function() {\nvar makeSelfResolutionError = function () {\n    return new TypeError(\"circular promise resolution chain\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n};\nvar reflectHandler = function() {\n    return new Promise.PromiseInspection(this._target());\n};\nvar apiRejection = function(msg) {\n    return Promise.reject(new TypeError(msg));\n};\nfunction Proxyable() {}\nvar UNDEFINED_BINDING = {};\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\n\nvar getDomain;\nif (util.isNode) {\n    getDomain = function() {\n        var ret = process.domain;\n        if (ret === undefined) ret = null;\n        return ret;\n    };\n} else {\n    getDomain = function() {\n        return null;\n    };\n}\nutil.notEnumerableProp(Promise, \"_getDomain\", getDomain);\n\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/bluebird/js/release/es5.js\");\nvar Async = __webpack_require__(/*! ./async */ \"./node_modules/bluebird/js/release/async.js\");\nvar async = new Async();\nes5.defineProperty(Promise, \"_async\", {value: async});\nvar errors = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\");\nvar TypeError = Promise.TypeError = errors.TypeError;\nPromise.RangeError = errors.RangeError;\nvar CancellationError = Promise.CancellationError = errors.CancellationError;\nPromise.TimeoutError = errors.TimeoutError;\nPromise.OperationalError = errors.OperationalError;\nPromise.RejectionError = errors.OperationalError;\nPromise.AggregateError = errors.AggregateError;\nvar INTERNAL = function(){};\nvar APPLY = {};\nvar NEXT_FILTER = {};\nvar tryConvertToPromise = __webpack_require__(/*! ./thenables */ \"./node_modules/bluebird/js/release/thenables.js\")(Promise, INTERNAL);\nvar PromiseArray =\n    __webpack_require__(/*! ./promise_array */ \"./node_modules/bluebird/js/release/promise_array.js\")(Promise, INTERNAL,\n                               tryConvertToPromise, apiRejection, Proxyable);\nvar Context = __webpack_require__(/*! ./context */ \"./node_modules/bluebird/js/release/context.js\")(Promise);\n /*jshint unused:false*/\nvar createContext = Context.create;\nvar debug = __webpack_require__(/*! ./debuggability */ \"./node_modules/bluebird/js/release/debuggability.js\")(Promise, Context);\nvar CapturedTrace = debug.CapturedTrace;\nvar PassThroughHandlerContext =\n    __webpack_require__(/*! ./finally */ \"./node_modules/bluebird/js/release/finally.js\")(Promise, tryConvertToPromise, NEXT_FILTER);\nvar catchFilter = __webpack_require__(/*! ./catch_filter */ \"./node_modules/bluebird/js/release/catch_filter.js\")(NEXT_FILTER);\nvar nodebackForPromise = __webpack_require__(/*! ./nodeback */ \"./node_modules/bluebird/js/release/nodeback.js\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nfunction check(self, executor) {\n    if (self == null || self.constructor !== Promise) {\n        throw new TypeError(\"the promise constructor cannot be invoked directly\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    if (typeof executor !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(executor));\n    }\n\n}\n\nfunction Promise(executor) {\n    if (executor !== INTERNAL) {\n        check(this, executor);\n    }\n    this._bitField = 0;\n    this._fulfillmentHandler0 = undefined;\n    this._rejectionHandler0 = undefined;\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._resolveFromExecutor(executor);\n    this._promiseCreated();\n    this._fireEvent(\"promiseCreated\", this);\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n    var len = arguments.length;\n    if (len > 1) {\n        var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (util.isObject(item)) {\n                catchInstances[j++] = item;\n            } else {\n                return apiRejection(\"Catch statement predicate: \" +\n                    \"expecting an object but got \" + util.classString(item));\n            }\n        }\n        catchInstances.length = j;\n        fn = arguments[i];\n        return this.then(undefined, catchFilter(catchInstances, fn, this));\n    }\n    return this.then(undefined, fn);\n};\n\nPromise.prototype.reflect = function () {\n    return this._then(reflectHandler,\n        reflectHandler, undefined, this, undefined);\n};\n\nPromise.prototype.then = function (didFulfill, didReject) {\n    if (debug.warnings() && arguments.length > 0 &&\n        typeof didFulfill !== \"function\" &&\n        typeof didReject !== \"function\") {\n        var msg = \".then() only accepts functions but was passed: \" +\n                util.classString(didFulfill);\n        if (arguments.length > 1) {\n            msg += \", \" + util.classString(didReject);\n        }\n        this._warn(msg);\n    }\n    return this._then(didFulfill, didReject, undefined, undefined, undefined);\n};\n\nPromise.prototype.done = function (didFulfill, didReject) {\n    var promise =\n        this._then(didFulfill, didReject, undefined, undefined, undefined);\n    promise._setIsFinal();\n};\n\nPromise.prototype.spread = function (fn) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    return this.all()._then(fn, undefined, undefined, APPLY, undefined);\n};\n\nPromise.prototype.toJSON = function () {\n    var ret = {\n        isFulfilled: false,\n        isRejected: false,\n        fulfillmentValue: undefined,\n        rejectionReason: undefined\n    };\n    if (this.isFulfilled()) {\n        ret.fulfillmentValue = this.value();\n        ret.isFulfilled = true;\n    } else if (this.isRejected()) {\n        ret.rejectionReason = this.reason();\n        ret.isRejected = true;\n    }\n    return ret;\n};\n\nPromise.prototype.all = function () {\n    if (arguments.length > 0) {\n        this._warn(\".all() was passed arguments but it does not take any\");\n    }\n    return new PromiseArray(this).promise();\n};\n\nPromise.prototype.error = function (fn) {\n    return this.caught(util.originatesFromRejection, fn);\n};\n\nPromise.getNewLibraryCopy = module.exports;\n\nPromise.is = function (val) {\n    return val instanceof Promise;\n};\n\nPromise.fromNode = Promise.fromCallback = function(fn) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs\n                                         : false;\n    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));\n    if (result === errorObj) {\n        ret._rejectCallback(result.e, true);\n    }\n    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();\n    return ret;\n};\n\nPromise.all = function (promises) {\n    return new PromiseArray(promises).promise();\n};\n\nPromise.cast = function (obj) {\n    var ret = tryConvertToPromise(obj);\n    if (!(ret instanceof Promise)) {\n        ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._setFulfilled();\n        ret._rejectionHandler0 = obj;\n    }\n    return ret;\n};\n\nPromise.resolve = Promise.fulfilled = Promise.cast;\n\nPromise.reject = Promise.rejected = function (reason) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._rejectCallback(reason, true);\n    return ret;\n};\n\nPromise.setScheduler = function(fn) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    return async.setScheduler(fn);\n};\n\nPromise.prototype._then = function (\n    didFulfill,\n    didReject,\n    _,    receiver,\n    internalData\n) {\n    var haveInternalData = internalData !== undefined;\n    var promise = haveInternalData ? internalData : new Promise(INTERNAL);\n    var target = this._target();\n    var bitField = target._bitField;\n\n    if (!haveInternalData) {\n        promise._propagateFrom(this, 3);\n        promise._captureStackTrace();\n        if (receiver === undefined &&\n            ((this._bitField & 2097152) !== 0)) {\n            if (!((bitField & 50397184) === 0)) {\n                receiver = this._boundValue();\n            } else {\n                receiver = target === this ? undefined : this._boundTo;\n            }\n        }\n        this._fireEvent(\"promiseChained\", this, promise);\n    }\n\n    var domain = getDomain();\n    if (!((bitField & 50397184) === 0)) {\n        var handler, value, settler = target._settlePromiseCtx;\n        if (((bitField & 33554432) !== 0)) {\n            value = target._rejectionHandler0;\n            handler = didFulfill;\n        } else if (((bitField & 16777216) !== 0)) {\n            value = target._fulfillmentHandler0;\n            handler = didReject;\n            target._unsetRejectionIsUnhandled();\n        } else {\n            settler = target._settlePromiseLateCancellationObserver;\n            value = new CancellationError(\"late cancellation observer\");\n            target._attachExtraTrace(value);\n            handler = didReject;\n        }\n\n        async.invoke(settler, target, {\n            handler: domain === null ? handler\n                : (typeof handler === \"function\" &&\n                    util.domainBind(domain, handler)),\n            promise: promise,\n            receiver: receiver,\n            value: value\n        });\n    } else {\n        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);\n    }\n\n    return promise;\n};\n\nPromise.prototype._length = function () {\n    return this._bitField & 65535;\n};\n\nPromise.prototype._isFateSealed = function () {\n    return (this._bitField & 117506048) !== 0;\n};\n\nPromise.prototype._isFollowing = function () {\n    return (this._bitField & 67108864) === 67108864;\n};\n\nPromise.prototype._setLength = function (len) {\n    this._bitField = (this._bitField & -65536) |\n        (len & 65535);\n};\n\nPromise.prototype._setFulfilled = function () {\n    this._bitField = this._bitField | 33554432;\n    this._fireEvent(\"promiseFulfilled\", this);\n};\n\nPromise.prototype._setRejected = function () {\n    this._bitField = this._bitField | 16777216;\n    this._fireEvent(\"promiseRejected\", this);\n};\n\nPromise.prototype._setFollowing = function () {\n    this._bitField = this._bitField | 67108864;\n    this._fireEvent(\"promiseResolved\", this);\n};\n\nPromise.prototype._setIsFinal = function () {\n    this._bitField = this._bitField | 4194304;\n};\n\nPromise.prototype._isFinal = function () {\n    return (this._bitField & 4194304) > 0;\n};\n\nPromise.prototype._unsetCancelled = function() {\n    this._bitField = this._bitField & (~65536);\n};\n\nPromise.prototype._setCancelled = function() {\n    this._bitField = this._bitField | 65536;\n    this._fireEvent(\"promiseCancelled\", this);\n};\n\nPromise.prototype._setWillBeCancelled = function() {\n    this._bitField = this._bitField | 8388608;\n};\n\nPromise.prototype._setAsyncGuaranteed = function() {\n    if (async.hasCustomScheduler()) return;\n    this._bitField = this._bitField | 134217728;\n};\n\nPromise.prototype._receiverAt = function (index) {\n    var ret = index === 0 ? this._receiver0 : this[\n            index * 4 - 4 + 3];\n    if (ret === UNDEFINED_BINDING) {\n        return undefined;\n    } else if (ret === undefined && this._isBound()) {\n        return this._boundValue();\n    }\n    return ret;\n};\n\nPromise.prototype._promiseAt = function (index) {\n    return this[\n            index * 4 - 4 + 2];\n};\n\nPromise.prototype._fulfillmentHandlerAt = function (index) {\n    return this[\n            index * 4 - 4 + 0];\n};\n\nPromise.prototype._rejectionHandlerAt = function (index) {\n    return this[\n            index * 4 - 4 + 1];\n};\n\nPromise.prototype._boundValue = function() {};\n\nPromise.prototype._migrateCallback0 = function (follower) {\n    var bitField = follower._bitField;\n    var fulfill = follower._fulfillmentHandler0;\n    var reject = follower._rejectionHandler0;\n    var promise = follower._promise0;\n    var receiver = follower._receiverAt(0);\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\n};\n\nPromise.prototype._migrateCallbackAt = function (follower, index) {\n    var fulfill = follower._fulfillmentHandlerAt(index);\n    var reject = follower._rejectionHandlerAt(index);\n    var promise = follower._promiseAt(index);\n    var receiver = follower._receiverAt(index);\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, promise, receiver, null);\n};\n\nPromise.prototype._addCallbacks = function (\n    fulfill,\n    reject,\n    promise,\n    receiver,\n    domain\n) {\n    var index = this._length();\n\n    if (index >= 65535 - 4) {\n        index = 0;\n        this._setLength(0);\n    }\n\n    if (index === 0) {\n        this._promise0 = promise;\n        this._receiver0 = receiver;\n        if (typeof fulfill === \"function\") {\n            this._fulfillmentHandler0 =\n                domain === null ? fulfill : util.domainBind(domain, fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this._rejectionHandler0 =\n                domain === null ? reject : util.domainBind(domain, reject);\n        }\n    } else {\n        var base = index * 4 - 4;\n        this[base + 2] = promise;\n        this[base + 3] = receiver;\n        if (typeof fulfill === \"function\") {\n            this[base + 0] =\n                domain === null ? fulfill : util.domainBind(domain, fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this[base + 1] =\n                domain === null ? reject : util.domainBind(domain, reject);\n        }\n    }\n    this._setLength(index + 1);\n    return index;\n};\n\nPromise.prototype._proxy = function (proxyable, arg) {\n    this._addCallbacks(undefined, undefined, arg, proxyable, null);\n};\n\nPromise.prototype._resolveCallback = function(value, shouldBind) {\n    if (((this._bitField & 117506048) !== 0)) return;\n    if (value === this)\n        return this._rejectCallback(makeSelfResolutionError(), false);\n    var maybePromise = tryConvertToPromise(value, this);\n    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n\n    if (shouldBind) this._propagateFrom(maybePromise, 2);\n\n    var promise = maybePromise._target();\n\n    if (promise === this) {\n        this._reject(makeSelfResolutionError());\n        return;\n    }\n\n    var bitField = promise._bitField;\n    if (((bitField & 50397184) === 0)) {\n        var len = this._length();\n        if (len > 0) promise._migrateCallback0(this);\n        for (var i = 1; i < len; ++i) {\n            promise._migrateCallbackAt(this, i);\n        }\n        this._setFollowing();\n        this._setLength(0);\n        this._setFollowee(promise);\n    } else if (((bitField & 33554432) !== 0)) {\n        this._fulfill(promise._value());\n    } else if (((bitField & 16777216) !== 0)) {\n        this._reject(promise._reason());\n    } else {\n        var reason = new CancellationError(\"late cancellation observer\");\n        promise._attachExtraTrace(reason);\n        this._reject(reason);\n    }\n};\n\nPromise.prototype._rejectCallback =\nfunction(reason, synchronous, ignoreNonErrorWarnings) {\n    var trace = util.ensureErrorObject(reason);\n    var hasStack = trace === reason;\n    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {\n        var message = \"a promise was rejected with a non-error: \" +\n            util.classString(reason);\n        this._warn(message, true);\n    }\n    this._attachExtraTrace(trace, synchronous ? hasStack : false);\n    this._reject(reason);\n};\n\nPromise.prototype._resolveFromExecutor = function (executor) {\n    if (executor === INTERNAL) return;\n    var promise = this;\n    this._captureStackTrace();\n    this._pushContext();\n    var synchronous = true;\n    var r = this._execute(executor, function(value) {\n        promise._resolveCallback(value);\n    }, function (reason) {\n        promise._rejectCallback(reason, synchronous);\n    });\n    synchronous = false;\n    this._popContext();\n\n    if (r !== undefined) {\n        promise._rejectCallback(r, true);\n    }\n};\n\nPromise.prototype._settlePromiseFromHandler = function (\n    handler, receiver, value, promise\n) {\n    var bitField = promise._bitField;\n    if (((bitField & 65536) !== 0)) return;\n    promise._pushContext();\n    var x;\n    if (receiver === APPLY) {\n        if (!value || typeof value.length !== \"number\") {\n            x = errorObj;\n            x.e = new TypeError(\"cannot .spread() a non-array: \" +\n                                    util.classString(value));\n        } else {\n            x = tryCatch(handler).apply(this._boundValue(), value);\n        }\n    } else {\n        x = tryCatch(handler).call(receiver, value);\n    }\n    var promiseCreated = promise._popContext();\n    bitField = promise._bitField;\n    if (((bitField & 65536) !== 0)) return;\n\n    if (x === NEXT_FILTER) {\n        promise._reject(value);\n    } else if (x === errorObj) {\n        promise._rejectCallback(x.e, false);\n    } else {\n        debug.checkForgottenReturns(x, promiseCreated, \"\",  promise, this);\n        promise._resolveCallback(x);\n    }\n};\n\nPromise.prototype._target = function() {\n    var ret = this;\n    while (ret._isFollowing()) ret = ret._followee();\n    return ret;\n};\n\nPromise.prototype._followee = function() {\n    return this._rejectionHandler0;\n};\n\nPromise.prototype._setFollowee = function(promise) {\n    this._rejectionHandler0 = promise;\n};\n\nPromise.prototype._settlePromise = function(promise, handler, receiver, value) {\n    var isPromise = promise instanceof Promise;\n    var bitField = this._bitField;\n    var asyncGuaranteed = ((bitField & 134217728) !== 0);\n    if (((bitField & 65536) !== 0)) {\n        if (isPromise) promise._invokeInternalOnCancel();\n\n        if (receiver instanceof PassThroughHandlerContext &&\n            receiver.isFinallyHandler()) {\n            receiver.cancelPromise = promise;\n            if (tryCatch(handler).call(receiver, value) === errorObj) {\n                promise._reject(errorObj.e);\n            }\n        } else if (handler === reflectHandler) {\n            promise._fulfill(reflectHandler.call(receiver));\n        } else if (receiver instanceof Proxyable) {\n            receiver._promiseCancelled(promise);\n        } else if (isPromise || promise instanceof PromiseArray) {\n            promise._cancel();\n        } else {\n            receiver.cancel();\n        }\n    } else if (typeof handler === \"function\") {\n        if (!isPromise) {\n            handler.call(receiver, value, promise);\n        } else {\n            if (asyncGuaranteed) promise._setAsyncGuaranteed();\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (receiver instanceof Proxyable) {\n        if (!receiver._isResolved()) {\n            if (((bitField & 33554432) !== 0)) {\n                receiver._promiseFulfilled(value, promise);\n            } else {\n                receiver._promiseRejected(value, promise);\n            }\n        }\n    } else if (isPromise) {\n        if (asyncGuaranteed) promise._setAsyncGuaranteed();\n        if (((bitField & 33554432) !== 0)) {\n            promise._fulfill(value);\n        } else {\n            promise._reject(value);\n        }\n    }\n};\n\nPromise.prototype._settlePromiseLateCancellationObserver = function(ctx) {\n    var handler = ctx.handler;\n    var promise = ctx.promise;\n    var receiver = ctx.receiver;\n    var value = ctx.value;\n    if (typeof handler === \"function\") {\n        if (!(promise instanceof Promise)) {\n            handler.call(receiver, value, promise);\n        } else {\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (promise instanceof Promise) {\n        promise._reject(value);\n    }\n};\n\nPromise.prototype._settlePromiseCtx = function(ctx) {\n    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);\n};\n\nPromise.prototype._settlePromise0 = function(handler, value, bitField) {\n    var promise = this._promise0;\n    var receiver = this._receiverAt(0);\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._settlePromise(promise, handler, receiver, value);\n};\n\nPromise.prototype._clearCallbackDataAtIndex = function(index) {\n    var base = index * 4 - 4;\n    this[base + 2] =\n    this[base + 3] =\n    this[base + 0] =\n    this[base + 1] = undefined;\n};\n\nPromise.prototype._fulfill = function (value) {\n    var bitField = this._bitField;\n    if (((bitField & 117506048) >>> 16)) return;\n    if (value === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._reject(err);\n    }\n    this._setFulfilled();\n    this._rejectionHandler0 = value;\n\n    if ((bitField & 65535) > 0) {\n        if (((bitField & 134217728) !== 0)) {\n            this._settlePromises();\n        } else {\n            async.settlePromises(this);\n        }\n    }\n};\n\nPromise.prototype._reject = function (reason) {\n    var bitField = this._bitField;\n    if (((bitField & 117506048) >>> 16)) return;\n    this._setRejected();\n    this._fulfillmentHandler0 = reason;\n\n    if (this._isFinal()) {\n        return async.fatalError(reason, util.isNode);\n    }\n\n    if ((bitField & 65535) > 0) {\n        async.settlePromises(this);\n    } else {\n        this._ensurePossibleRejectionHandled();\n    }\n};\n\nPromise.prototype._fulfillPromises = function (len, value) {\n    for (var i = 1; i < len; i++) {\n        var handler = this._fulfillmentHandlerAt(i);\n        var promise = this._promiseAt(i);\n        var receiver = this._receiverAt(i);\n        this._clearCallbackDataAtIndex(i);\n        this._settlePromise(promise, handler, receiver, value);\n    }\n};\n\nPromise.prototype._rejectPromises = function (len, reason) {\n    for (var i = 1; i < len; i++) {\n        var handler = this._rejectionHandlerAt(i);\n        var promise = this._promiseAt(i);\n        var receiver = this._receiverAt(i);\n        this._clearCallbackDataAtIndex(i);\n        this._settlePromise(promise, handler, receiver, reason);\n    }\n};\n\nPromise.prototype._settlePromises = function () {\n    var bitField = this._bitField;\n    var len = (bitField & 65535);\n\n    if (len > 0) {\n        if (((bitField & 16842752) !== 0)) {\n            var reason = this._fulfillmentHandler0;\n            this._settlePromise0(this._rejectionHandler0, reason, bitField);\n            this._rejectPromises(len, reason);\n        } else {\n            var value = this._rejectionHandler0;\n            this._settlePromise0(this._fulfillmentHandler0, value, bitField);\n            this._fulfillPromises(len, value);\n        }\n        this._setLength(0);\n    }\n    this._clearCancellationData();\n};\n\nPromise.prototype._settledValue = function() {\n    var bitField = this._bitField;\n    if (((bitField & 33554432) !== 0)) {\n        return this._rejectionHandler0;\n    } else if (((bitField & 16777216) !== 0)) {\n        return this._fulfillmentHandler0;\n    }\n};\n\nfunction deferResolve(v) {this.promise._resolveCallback(v);}\nfunction deferReject(v) {this.promise._rejectCallback(v, false);}\n\nPromise.defer = Promise.pending = function() {\n    debug.deprecated(\"Promise.defer\", \"new Promise\");\n    var promise = new Promise(INTERNAL);\n    return {\n        promise: promise,\n        resolve: deferResolve,\n        reject: deferReject\n    };\n};\n\nutil.notEnumerableProp(Promise,\n                       \"_makeSelfResolutionError\",\n                       makeSelfResolutionError);\n\n__webpack_require__(/*! ./method */ \"./node_modules/bluebird/js/release/method.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection,\n    debug);\n__webpack_require__(/*! ./bind */ \"./node_modules/bluebird/js/release/bind.js\")(Promise, INTERNAL, tryConvertToPromise, debug);\n__webpack_require__(/*! ./cancel */ \"./node_modules/bluebird/js/release/cancel.js\")(Promise, PromiseArray, apiRejection, debug);\n__webpack_require__(/*! ./direct_resolve */ \"./node_modules/bluebird/js/release/direct_resolve.js\")(Promise);\n__webpack_require__(/*! ./synchronous_inspection */ \"./node_modules/bluebird/js/release/synchronous_inspection.js\")(Promise);\n__webpack_require__(/*! ./join */ \"./node_modules/bluebird/js/release/join.js\")(\n    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);\nPromise.Promise = Promise;\nPromise.version = \"3.5.1\";\n__webpack_require__(/*! ./map.js */ \"./node_modules/bluebird/js/release/map.js\")(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n__webpack_require__(/*! ./call_get.js */ \"./node_modules/bluebird/js/release/call_get.js\")(Promise);\n__webpack_require__(/*! ./using.js */ \"./node_modules/bluebird/js/release/using.js\")(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);\n__webpack_require__(/*! ./timers.js */ \"./node_modules/bluebird/js/release/timers.js\")(Promise, INTERNAL, debug);\n__webpack_require__(/*! ./generators.js */ \"./node_modules/bluebird/js/release/generators.js\")(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);\n__webpack_require__(/*! ./nodeify.js */ \"./node_modules/bluebird/js/release/nodeify.js\")(Promise);\n__webpack_require__(/*! ./promisify.js */ \"./node_modules/bluebird/js/release/promisify.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./props.js */ \"./node_modules/bluebird/js/release/props.js\")(Promise, PromiseArray, tryConvertToPromise, apiRejection);\n__webpack_require__(/*! ./race.js */ \"./node_modules/bluebird/js/release/race.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n__webpack_require__(/*! ./reduce.js */ \"./node_modules/bluebird/js/release/reduce.js\")(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);\n__webpack_require__(/*! ./settle.js */ \"./node_modules/bluebird/js/release/settle.js\")(Promise, PromiseArray, debug);\n__webpack_require__(/*! ./some.js */ \"./node_modules/bluebird/js/release/some.js\")(Promise, PromiseArray, apiRejection);\n__webpack_require__(/*! ./filter.js */ \"./node_modules/bluebird/js/release/filter.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./each.js */ \"./node_modules/bluebird/js/release/each.js\")(Promise, INTERNAL);\n__webpack_require__(/*! ./any.js */ \"./node_modules/bluebird/js/release/any.js\")(Promise);\n                                                         \n    util.toFastProperties(Promise);                                          \n    util.toFastProperties(Promise.prototype);                                \n    function fillTypes(value) {                                              \n        var p = new Promise(INTERNAL);                                       \n        p._fulfillmentHandler0 = value;                                      \n        p._rejectionHandler0 = value;                                        \n        p._promise0 = value;                                                 \n        p._receiver0 = value;                                                \n    }                                                                        \n    // Complete slack tracking, opt out of field-type tracking and           \n    // stabilize map                                                         \n    fillTypes({a: 1});                                                       \n    fillTypes({b: 2});                                                       \n    fillTypes({c: 3});                                                       \n    fillTypes(1);                                                            \n    fillTypes(function(){});                                                 \n    fillTypes(undefined);                                                    \n    fillTypes(false);                                                        \n    fillTypes(new Promise(INTERNAL));                                        \n    debug.setBounds(Async.firstLineError, util.lastLineError);               \n    return Promise;                                                          \n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcHJvbWlzZS5qcz8zYmI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbnZhciBtYWtlU2VsZlJlc29sdXRpb25FcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihcImNpcmN1bGFyIHByb21pc2UgcmVzb2x1dGlvbiBjaGFpblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG59O1xudmFyIHJlZmxlY3RIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHRoaXMuX3RhcmdldCgpKTtcbn07XG52YXIgYXBpUmVqZWN0aW9uID0gZnVuY3Rpb24obXNnKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IobXNnKSk7XG59O1xuZnVuY3Rpb24gUHJveHlhYmxlKCkge31cbnZhciBVTkRFRklORURfQklORElORyA9IHt9O1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgZ2V0RG9tYWluO1xuaWYgKHV0aWwuaXNOb2RlKSB7XG4gICAgZ2V0RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXQgPSBwcm9jZXNzLmRvbWFpbjtcbiAgICAgICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSByZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59IGVsc2Uge1xuICAgIGdldERvbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxudXRpbC5ub3RFbnVtZXJhYmxlUHJvcChQcm9taXNlLCBcIl9nZXREb21haW5cIiwgZ2V0RG9tYWluKTtcblxudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcbnZhciBBc3luYyA9IHJlcXVpcmUoXCIuL2FzeW5jXCIpO1xudmFyIGFzeW5jID0gbmV3IEFzeW5jKCk7XG5lczUuZGVmaW5lUHJvcGVydHkoUHJvbWlzZSwgXCJfYXN5bmNcIiwge3ZhbHVlOiBhc3luY30pO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBUeXBlRXJyb3IgPSBQcm9taXNlLlR5cGVFcnJvciA9IGVycm9ycy5UeXBlRXJyb3I7XG5Qcm9taXNlLlJhbmdlRXJyb3IgPSBlcnJvcnMuUmFuZ2VFcnJvcjtcbnZhciBDYW5jZWxsYXRpb25FcnJvciA9IFByb21pc2UuQ2FuY2VsbGF0aW9uRXJyb3IgPSBlcnJvcnMuQ2FuY2VsbGF0aW9uRXJyb3I7XG5Qcm9taXNlLlRpbWVvdXRFcnJvciA9IGVycm9ycy5UaW1lb3V0RXJyb3I7XG5Qcm9taXNlLk9wZXJhdGlvbmFsRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuUmVqZWN0aW9uRXJyb3IgPSBlcnJvcnMuT3BlcmF0aW9uYWxFcnJvcjtcblByb21pc2UuQWdncmVnYXRlRXJyb3IgPSBlcnJvcnMuQWdncmVnYXRlRXJyb3I7XG52YXIgSU5URVJOQUwgPSBmdW5jdGlvbigpe307XG52YXIgQVBQTFkgPSB7fTtcbnZhciBORVhUX0ZJTFRFUiA9IHt9O1xudmFyIHRyeUNvbnZlcnRUb1Byb21pc2UgPSByZXF1aXJlKFwiLi90aGVuYWJsZXNcIikoUHJvbWlzZSwgSU5URVJOQUwpO1xudmFyIFByb21pc2VBcnJheSA9XG4gICAgcmVxdWlyZShcIi4vcHJvbWlzZV9hcnJheVwiKShQcm9taXNlLCBJTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlDb252ZXJ0VG9Qcm9taXNlLCBhcGlSZWplY3Rpb24sIFByb3h5YWJsZSk7XG52YXIgQ29udGV4dCA9IHJlcXVpcmUoXCIuL2NvbnRleHRcIikoUHJvbWlzZSk7XG4gLypqc2hpbnQgdW51c2VkOmZhbHNlKi9cbnZhciBjcmVhdGVDb250ZXh0ID0gQ29udGV4dC5jcmVhdGU7XG52YXIgZGVidWcgPSByZXF1aXJlKFwiLi9kZWJ1Z2dhYmlsaXR5XCIpKFByb21pc2UsIENvbnRleHQpO1xudmFyIENhcHR1cmVkVHJhY2UgPSBkZWJ1Zy5DYXB0dXJlZFRyYWNlO1xudmFyIFBhc3NUaHJvdWdoSGFuZGxlckNvbnRleHQgPVxuICAgIHJlcXVpcmUoXCIuL2ZpbmFsbHlcIikoUHJvbWlzZSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgTkVYVF9GSUxURVIpO1xudmFyIGNhdGNoRmlsdGVyID0gcmVxdWlyZShcIi4vY2F0Y2hfZmlsdGVyXCIpKE5FWFRfRklMVEVSKTtcbnZhciBub2RlYmFja0ZvclByb21pc2UgPSByZXF1aXJlKFwiLi9ub2RlYmFja1wiKTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuZnVuY3Rpb24gY2hlY2soc2VsZiwgZXhlY3V0b3IpIHtcbiAgICBpZiAoc2VsZiA9PSBudWxsIHx8IHNlbGYuY29uc3RydWN0b3IgIT09IFByb21pc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoZSBwcm9taXNlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBpbnZva2VkIGRpcmVjdGx5XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhleGVjdXRvcikpO1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgaWYgKGV4ZWN1dG9yICE9PSBJTlRFUk5BTCkge1xuICAgICAgICBjaGVjayh0aGlzLCBleGVjdXRvcik7XG4gICAgfVxuICAgIHRoaXMuX2JpdEZpZWxkID0gMDtcbiAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Byb21pc2UwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JlY2VpdmVyMCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZXNvbHZlRnJvbUV4ZWN1dG9yKGV4ZWN1dG9yKTtcbiAgICB0aGlzLl9wcm9taXNlQ3JlYXRlZCgpO1xuICAgIHRoaXMuX2ZpcmVFdmVudChcInByb21pc2VDcmVhdGVkXCIsIHRoaXMpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5jYXVnaHQgPSBQcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgdmFyIGNhdGNoSW5zdGFuY2VzID0gbmV3IEFycmF5KGxlbiAtIDEpLFxuICAgICAgICAgICAgaiA9IDAsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBjYXRjaEluc3RhbmNlc1tqKytdID0gaXRlbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcIkNhdGNoIHN0YXRlbWVudCBwcmVkaWNhdGU6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJleHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKGl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaEluc3RhbmNlcy5sZW5ndGggPSBqO1xuICAgICAgICBmbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNhdGNoRmlsdGVyKGNhdGNoSW5zdGFuY2VzLCBmbiwgdGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgZm4pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmVmbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbihyZWZsZWN0SGFuZGxlcixcbiAgICAgICAgcmVmbGVjdEhhbmRsZXIsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgaWYgKGRlYnVnLndhcm5pbmdzKCkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgdHlwZW9mIGRpZEZ1bGZpbGwgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2YgZGlkUmVqZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiLnRoZW4oKSBvbmx5IGFjY2VwdHMgZnVuY3Rpb25zIGJ1dCB3YXMgcGFzc2VkOiBcIiArXG4gICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyhkaWRGdWxmaWxsKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBtc2cgKz0gXCIsIFwiICsgdXRpbC5jbGFzc1N0cmluZyhkaWRSZWplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dhcm4obXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RoZW4oZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZGlkRnVsZmlsbCwgZGlkUmVqZWN0KSB7XG4gICAgdmFyIHByb21pc2UgPVxuICAgICAgICB0aGlzLl90aGVuKGRpZEZ1bGZpbGwsIGRpZFJlamVjdCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgcHJvbWlzZS5fc2V0SXNGaW5hbCgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGwoKS5fdGhlbihmbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIEFQUExZLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXQgPSB7XG4gICAgICAgIGlzRnVsZmlsbGVkOiBmYWxzZSxcbiAgICAgICAgaXNSZWplY3RlZDogZmFsc2UsXG4gICAgICAgIGZ1bGZpbGxtZW50VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgcmVqZWN0aW9uUmVhc29uOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmICh0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgcmV0LmZ1bGZpbGxtZW50VmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgIHJldC5pc0Z1bGZpbGxlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICByZXQucmVqZWN0aW9uUmVhc29uID0gdGhpcy5yZWFzb24oKTtcbiAgICAgICAgcmV0LmlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl93YXJuKFwiLmFsbCgpIHdhcyBwYXNzZWQgYXJndW1lbnRzIGJ1dCBpdCBkb2VzIG5vdCB0YWtlIGFueVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlQXJyYXkodGhpcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5jYXVnaHQodXRpbC5vcmlnaW5hdGVzRnJvbVJlamVjdGlvbiwgZm4pO1xufTtcblxuUHJvbWlzZS5nZXROZXdMaWJyYXJ5Q29weSA9IG1vZHVsZS5leHBvcnRzO1xuXG5Qcm9taXNlLmlzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBQcm9taXNlO1xufTtcblxuUHJvbWlzZS5mcm9tTm9kZSA9IFByb21pc2UuZnJvbUNhbGxiYWNrID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB2YXIgbXVsdGlBcmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAhIU9iamVjdChhcmd1bWVudHNbMV0pLm11bHRpQXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaChmbikobm9kZWJhY2tGb3JQcm9taXNlKHJldCwgbXVsdGlBcmdzKSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcmV0Ll9yZWplY3RDYWxsYmFjayhyZXN1bHQuZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICghcmV0Ll9pc0ZhdGVTZWFsZWQoKSkgcmV0Ll9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VBcnJheShwcm9taXNlcykucHJvbWlzZSgpO1xufTtcblxuUHJvbWlzZS5jYXN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXQgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKG9iaik7XG4gICAgaWYgKCEocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICByZXQuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIHJldC5fc2V0RnVsZmlsbGVkKCk7XG4gICAgICAgIHJldC5fcmVqZWN0aW9uSGFuZGxlcjAgPSBvYmo7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG5Qcm9taXNlLnJlc29sdmUgPSBQcm9taXNlLmZ1bGZpbGxlZCA9IFByb21pc2UuY2FzdDtcblxuUHJvbWlzZS5yZWplY3QgPSBQcm9taXNlLnJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgcmV0Ll9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHJldC5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCB0cnVlKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5zZXRTY2hlZHVsZXIgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzeW5jLnNldFNjaGVkdWxlcihmbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fdGhlbiA9IGZ1bmN0aW9uIChcbiAgICBkaWRGdWxmaWxsLFxuICAgIGRpZFJlamVjdCxcbiAgICBfLCAgICByZWNlaXZlcixcbiAgICBpbnRlcm5hbERhdGFcbikge1xuICAgIHZhciBoYXZlSW50ZXJuYWxEYXRhID0gaW50ZXJuYWxEYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIHByb21pc2UgPSBoYXZlSW50ZXJuYWxEYXRhID8gaW50ZXJuYWxEYXRhIDogbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB2YXIgYml0RmllbGQgPSB0YXJnZXQuX2JpdEZpZWxkO1xuXG4gICAgaWYgKCFoYXZlSW50ZXJuYWxEYXRhKSB7XG4gICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20odGhpcywgMyk7XG4gICAgICAgIHByb21pc2UuX2NhcHR1cmVTdGFja1RyYWNlKCk7XG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoKHRoaXMuX2JpdEZpZWxkICYgMjA5NzE1MikgIT09IDApKSB7XG4gICAgICAgICAgICBpZiAoISgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB0aGlzLl9ib3VuZFZhbHVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyID0gdGFyZ2V0ID09PSB0aGlzID8gdW5kZWZpbmVkIDogdGhpcy5fYm91bmRUbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2hhaW5lZFwiLCB0aGlzLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICB2YXIgZG9tYWluID0gZ2V0RG9tYWluKCk7XG4gICAgaWYgKCEoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB2YXIgaGFuZGxlciwgdmFsdWUsIHNldHRsZXIgPSB0YXJnZXQuX3NldHRsZVByb21pc2VDdHg7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0YXJnZXQuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZEZ1bGZpbGw7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGFyZ2V0Ll9mdWxmaWxsbWVudEhhbmRsZXIwO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZFJlamVjdDtcbiAgICAgICAgICAgIHRhcmdldC5fdW5zZXRSZWplY3Rpb25Jc1VuaGFuZGxlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0dGxlciA9IHRhcmdldC5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlcjtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IENhbmNlbGxhdGlvbkVycm9yKFwibGF0ZSBjYW5jZWxsYXRpb24gb2JzZXJ2ZXJcIik7XG4gICAgICAgICAgICB0YXJnZXQuX2F0dGFjaEV4dHJhVHJhY2UodmFsdWUpO1xuICAgICAgICAgICAgaGFuZGxlciA9IGRpZFJlamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jLmludm9rZShzZXR0bGVyLCB0YXJnZXQsIHtcbiAgICAgICAgICAgIGhhbmRsZXI6IGRvbWFpbiA9PT0gbnVsbCA/IGhhbmRsZXJcbiAgICAgICAgICAgICAgICA6ICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZG9tYWluQmluZChkb21haW4sIGhhbmRsZXIpKSxcbiAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICByZWNlaXZlcjogcmVjZWl2ZXIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Ll9hZGRDYWxsYmFja3MoZGlkRnVsZmlsbCwgZGlkUmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgZG9tYWluKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpdEZpZWxkICYgNjU1MzU7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGYXRlU2VhbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMTc1MDYwNDgpICE9PSAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2lzRm9sbG93aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA2NzEwODg2NCkgPT09IDY3MTA4ODY0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9ICh0aGlzLl9iaXRGaWVsZCAmIC02NTUzNikgfFxuICAgICAgICAobGVuICYgNjU1MzUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMzM1NTQ0MzI7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZUZ1bGZpbGxlZFwiLCB0aGlzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXRSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgMTY3NzcyMTY7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlamVjdGVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9iaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkIHwgNjcxMDg4NjQ7XG4gICAgdGhpcy5fZmlyZUV2ZW50KFwicHJvbWlzZVJlc29sdmVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldElzRmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCB8IDQxOTQzMDQ7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5faXNGaW5hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNDE5NDMwNCkgPiAwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Vuc2V0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZCAmICh+NjU1MzYpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldENhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA2NTUzNjtcbiAgICB0aGlzLl9maXJlRXZlbnQoXCJwcm9taXNlQ2FuY2VsbGVkXCIsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldFdpbGxCZUNhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCA4Mzg4NjA4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEFzeW5jR3VhcmFudGVlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChhc3luYy5oYXNDdXN0b21TY2hlZHVsZXIoKSkgcmV0dXJuO1xuICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMzQyMTc3Mjg7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVjZWl2ZXJBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciByZXQgPSBpbmRleCA9PT0gMCA/IHRoaXMuX3JlY2VpdmVyMCA6IHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgM107XG4gICAgaWYgKHJldCA9PT0gVU5ERUZJTkVEX0JJTkRJTkcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHJldCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2lzQm91bmQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb21pc2VBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzW1xuICAgICAgICAgICAgaW5kZXggKiA0IC0gNCArIDJdO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxtZW50SGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgMF07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0aW9uSGFuZGxlckF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXNbXG4gICAgICAgICAgICBpbmRleCAqIDQgLSA0ICsgMV07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYm91bmRWYWx1ZSA9IGZ1bmN0aW9uKCkge307XG5cblByb21pc2UucHJvdG90eXBlLl9taWdyYXRlQ2FsbGJhY2swID0gZnVuY3Rpb24gKGZvbGxvd2VyKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gZm9sbG93ZXIuX2JpdEZpZWxkO1xuICAgIHZhciBmdWxmaWxsID0gZm9sbG93ZXIuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgdmFyIHJlamVjdCA9IGZvbGxvd2VyLl9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICB2YXIgcHJvbWlzZSA9IGZvbGxvd2VyLl9wcm9taXNlMDtcbiAgICB2YXIgcmVjZWl2ZXIgPSBmb2xsb3dlci5fcmVjZWl2ZXJBdCgwKTtcbiAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSBVTkRFRklORURfQklORElORztcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fbWlncmF0ZUNhbGxiYWNrQXQgPSBmdW5jdGlvbiAoZm9sbG93ZXIsIGluZGV4KSB7XG4gICAgdmFyIGZ1bGZpbGwgPSBmb2xsb3dlci5fZnVsZmlsbG1lbnRIYW5kbGVyQXQoaW5kZXgpO1xuICAgIHZhciByZWplY3QgPSBmb2xsb3dlci5fcmVqZWN0aW9uSGFuZGxlckF0KGluZGV4KTtcbiAgICB2YXIgcHJvbWlzZSA9IGZvbGxvd2VyLl9wcm9taXNlQXQoaW5kZXgpO1xuICAgIHZhciByZWNlaXZlciA9IGZvbGxvd2VyLl9yZWNlaXZlckF0KGluZGV4KTtcbiAgICBpZiAocmVjZWl2ZXIgPT09IHVuZGVmaW5lZCkgcmVjZWl2ZXIgPSBVTkRFRklORURfQklORElORztcbiAgICB0aGlzLl9hZGRDYWxsYmFja3MoZnVsZmlsbCwgcmVqZWN0LCBwcm9taXNlLCByZWNlaXZlciwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fYWRkQ2FsbGJhY2tzID0gZnVuY3Rpb24gKFxuICAgIGZ1bGZpbGwsXG4gICAgcmVqZWN0LFxuICAgIHByb21pc2UsXG4gICAgcmVjZWl2ZXIsXG4gICAgZG9tYWluXG4pIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9sZW5ndGgoKTtcblxuICAgIGlmIChpbmRleCA+PSA2NTUzNSAtIDQpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9zZXRMZW5ndGgoMCk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Byb21pc2UwID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIwID0gcmVjZWl2ZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZnVsZmlsbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsbWVudEhhbmRsZXIwID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyBmdWxmaWxsIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZnVsZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0aW9uSGFuZGxlcjAgPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IHJlamVjdCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmFzZSA9IGluZGV4ICogNCAtIDQ7XG4gICAgICAgIHRoaXNbYmFzZSArIDJdID0gcHJvbWlzZTtcbiAgICAgICAgdGhpc1tiYXNlICsgM10gPSByZWNlaXZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmdWxmaWxsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICAgICAgICAgICAgICBkb21haW4gPT09IG51bGwgPyBmdWxmaWxsIDogdXRpbC5kb21haW5CaW5kKGRvbWFpbiwgZnVsZmlsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpc1tiYXNlICsgMV0gPVxuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gbnVsbCA/IHJlamVjdCA6IHV0aWwuZG9tYWluQmluZChkb21haW4sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc2V0TGVuZ3RoKGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIGluZGV4O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3Byb3h5ID0gZnVuY3Rpb24gKHByb3h5YWJsZSwgYXJnKSB7XG4gICAgdGhpcy5fYWRkQ2FsbGJhY2tzKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcmcsIHByb3h5YWJsZSwgbnVsbCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUNhbGxiYWNrID0gZnVuY3Rpb24odmFsdWUsIHNob3VsZEJpbmQpIHtcbiAgICBpZiAoKCh0aGlzLl9iaXRGaWVsZCAmIDExNzUwNjA0OCkgIT09IDApKSByZXR1cm47XG4gICAgaWYgKHZhbHVlID09PSB0aGlzKVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0Q2FsbGJhY2sobWFrZVNlbGZSZXNvbHV0aW9uRXJyb3IoKSwgZmFsc2UpO1xuICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHZhbHVlLCB0aGlzKTtcbiAgICBpZiAoIShtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkgcmV0dXJuIHRoaXMuX2Z1bGZpbGwodmFsdWUpO1xuXG4gICAgaWYgKHNob3VsZEJpbmQpIHRoaXMuX3Byb3BhZ2F0ZUZyb20obWF5YmVQcm9taXNlLCAyKTtcblxuICAgIHZhciBwcm9taXNlID0gbWF5YmVQcm9taXNlLl90YXJnZXQoKTtcblxuICAgIGlmIChwcm9taXNlID09PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuX3JlamVjdChtYWtlU2VsZlJlc29sdXRpb25FcnJvcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiaXRGaWVsZCA9IHByb21pc2UuX2JpdEZpZWxkO1xuICAgIGlmICgoKGJpdEZpZWxkICYgNTAzOTcxODQpID09PSAwKSkge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoKCk7XG4gICAgICAgIGlmIChsZW4gPiAwKSBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2swKHRoaXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9taWdyYXRlQ2FsbGJhY2tBdCh0aGlzLCBpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRGb2xsb3dpbmcoKTtcbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgICAgICB0aGlzLl9zZXRGb2xsb3dlZShwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgIHRoaXMuX2Z1bGZpbGwocHJvbWlzZS5fdmFsdWUoKSk7XG4gICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICB0aGlzLl9yZWplY3QocHJvbWlzZS5fcmVhc29uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZWFzb24gPSBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoXCJsYXRlIGNhbmNlbGxhdGlvbiBvYnNlcnZlclwiKTtcbiAgICAgICAgcHJvbWlzZS5fYXR0YWNoRXh0cmFUcmFjZShyZWFzb24pO1xuICAgICAgICB0aGlzLl9yZWplY3QocmVhc29uKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVqZWN0Q2FsbGJhY2sgPVxuZnVuY3Rpb24ocmVhc29uLCBzeW5jaHJvbm91cywgaWdub3JlTm9uRXJyb3JXYXJuaW5ncykge1xuICAgIHZhciB0cmFjZSA9IHV0aWwuZW5zdXJlRXJyb3JPYmplY3QocmVhc29uKTtcbiAgICB2YXIgaGFzU3RhY2sgPSB0cmFjZSA9PT0gcmVhc29uO1xuICAgIGlmICghaGFzU3RhY2sgJiYgIWlnbm9yZU5vbkVycm9yV2FybmluZ3MgJiYgZGVidWcud2FybmluZ3MoKSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiYSBwcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgbm9uLWVycm9yOiBcIiArXG4gICAgICAgICAgICB1dGlsLmNsYXNzU3RyaW5nKHJlYXNvbik7XG4gICAgICAgIHRoaXMuX3dhcm4obWVzc2FnZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UodHJhY2UsIHN5bmNocm9ub3VzID8gaGFzU3RhY2sgOiBmYWxzZSk7XG4gICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fcmVzb2x2ZUZyb21FeGVjdXRvciA9IGZ1bmN0aW9uIChleGVjdXRvcikge1xuICAgIGlmIChleGVjdXRvciA9PT0gSU5URVJOQUwpIHJldHVybjtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdGhpcy5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB0aGlzLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciBzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgdmFyIHIgPSB0aGlzLl9leGVjdXRlKGV4ZWN1dG9yLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVhc29uLCBzeW5jaHJvbm91cyk7XG4gICAgfSk7XG4gICAgc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICB0aGlzLl9wb3BDb250ZXh0KCk7XG5cbiAgICBpZiAociAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHIsIHRydWUpO1xuICAgIH1cbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIgPSBmdW5jdGlvbiAoXG4gICAgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlXG4pIHtcbiAgICB2YXIgYml0RmllbGQgPSBwcm9taXNlLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDY1NTM2KSAhPT0gMCkpIHJldHVybjtcbiAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciB4O1xuICAgIGlmIChyZWNlaXZlciA9PT0gQVBQTFkpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB4ID0gZXJyb3JPYmo7XG4gICAgICAgICAgICB4LmUgPSBuZXcgVHlwZUVycm9yKFwiY2Fubm90IC5zcHJlYWQoKSBhIG5vbi1hcnJheTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jbGFzc1N0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmFwcGx5KHRoaXMuX2JvdW5kVmFsdWUoKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFyIHByb21pc2VDcmVhdGVkID0gcHJvbWlzZS5fcG9wQ29udGV4dCgpO1xuICAgIGJpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSByZXR1cm47XG5cbiAgICBpZiAoeCA9PT0gTkVYVF9GSUxURVIpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHggPT09IGVycm9yT2JqKSB7XG4gICAgICAgIHByb21pc2UuX3JlamVjdENhbGxiYWNrKHguZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnLmNoZWNrRm9yZ290dGVuUmV0dXJucyh4LCBwcm9taXNlQ3JlYXRlZCwgXCJcIiwgIHByb21pc2UsIHRoaXMpO1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2soeCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3RhcmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXQgPSB0aGlzO1xuICAgIHdoaWxlIChyZXQuX2lzRm9sbG93aW5nKCkpIHJldCA9IHJldC5fZm9sbG93ZWUoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2ZvbGxvd2VlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3NldEZvbGxvd2VlID0gZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwID0gcHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVQcm9taXNlID0gZnVuY3Rpb24ocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKSB7XG4gICAgdmFyIGlzUHJvbWlzZSA9IHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlO1xuICAgIHZhciBiaXRGaWVsZCA9IHRoaXMuX2JpdEZpZWxkO1xuICAgIHZhciBhc3luY0d1YXJhbnRlZWQgPSAoKGJpdEZpZWxkICYgMTM0MjE3NzI4KSAhPT0gMCk7XG4gICAgaWYgKCgoYml0RmllbGQgJiA2NTUzNikgIT09IDApKSB7XG4gICAgICAgIGlmIChpc1Byb21pc2UpIHByb21pc2UuX2ludm9rZUludGVybmFsT25DYW5jZWwoKTtcblxuICAgICAgICBpZiAocmVjZWl2ZXIgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaEhhbmRsZXJDb250ZXh0ICYmXG4gICAgICAgICAgICByZWNlaXZlci5pc0ZpbmFsbHlIYW5kbGVyKCkpIHtcbiAgICAgICAgICAgIHJlY2VpdmVyLmNhbmNlbFByb21pc2UgPSBwcm9taXNlO1xuICAgICAgICAgICAgaWYgKHRyeUNhdGNoKGhhbmRsZXIpLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9yZWplY3QoZXJyb3JPYmouZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9PT0gcmVmbGVjdEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHByb21pc2UuX2Z1bGZpbGwocmVmbGVjdEhhbmRsZXIuY2FsbChyZWNlaXZlcikpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyIGluc3RhbmNlb2YgUHJveHlhYmxlKSB7XG4gICAgICAgICAgICByZWNlaXZlci5fcHJvbWlzZUNhbmNlbGxlZChwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UgfHwgcHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2VBcnJheSkge1xuICAgICAgICAgICAgcHJvbWlzZS5fY2FuY2VsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNlaXZlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAoIWlzUHJvbWlzZSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2VGcm9tSGFuZGxlcihoYW5kbGVyLCByZWNlaXZlciwgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWNlaXZlciBpbnN0YW5jZW9mIFByb3h5YWJsZSkge1xuICAgICAgICBpZiAoIXJlY2VpdmVyLl9pc1Jlc29sdmVkKCkpIHtcbiAgICAgICAgICAgIGlmICgoKGJpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyLl9wcm9taXNlRnVsZmlsbGVkKHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIuX3Byb21pc2VSZWplY3RlZCh2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICBpZiAoYXN5bmNHdWFyYW50ZWVkKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb21pc2UuX3JlamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUxhdGVDYW5jZWxsYXRpb25PYnNlcnZlciA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHZhciBoYW5kbGVyID0gY3R4LmhhbmRsZXI7XG4gICAgdmFyIHByb21pc2UgPSBjdHgucHJvbWlzZTtcbiAgICB2YXIgcmVjZWl2ZXIgPSBjdHgucmVjZWl2ZXI7XG4gICAgdmFyIHZhbHVlID0gY3R4LnZhbHVlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGlmICghKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHJlY2VpdmVyLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlRnJvbUhhbmRsZXIoaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0KHZhbHVlKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZUN0eCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UoY3R4LnByb21pc2UsIGN0eC5oYW5kbGVyLCBjdHgucmVjZWl2ZXIsIGN0eC52YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZTAgPSBmdW5jdGlvbihoYW5kbGVyLCB2YWx1ZSwgYml0RmllbGQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2UwO1xuICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoMCk7XG4gICAgdGhpcy5fcHJvbWlzZTAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVjZWl2ZXIwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NldHRsZVByb21pc2UocHJvbWlzZSwgaGFuZGxlciwgcmVjZWl2ZXIsIHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9jbGVhckNhbGxiYWNrRGF0YUF0SW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHZhciBiYXNlID0gaW5kZXggKiA0IC0gNDtcbiAgICB0aGlzW2Jhc2UgKyAyXSA9XG4gICAgdGhpc1tiYXNlICsgM10gPVxuICAgIHRoaXNbYmFzZSArIDBdID1cbiAgICB0aGlzW2Jhc2UgKyAxXSA9IHVuZGVmaW5lZDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgaWYgKCgoYml0RmllbGQgJiAxMTc1MDYwNDgpID4+PiAxNikpIHJldHVybjtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMpIHtcbiAgICAgICAgdmFyIGVyciA9IG1ha2VTZWxmUmVzb2x1dGlvbkVycm9yKCk7XG4gICAgICAgIHRoaXMuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdChlcnIpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRGdWxmaWxsZWQoKTtcbiAgICB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCA9IHZhbHVlO1xuXG4gICAgaWYgKChiaXRGaWVsZCAmIDY1NTM1KSA+IDApIHtcbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiAxMzQyMTc3MjgpICE9PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLnNldHRsZVByb21pc2VzKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDExNzUwNjA0OCkgPj4+IDE2KSkgcmV0dXJuO1xuICAgIHRoaXMuX3NldFJlamVjdGVkKCk7XG4gICAgdGhpcy5fZnVsZmlsbG1lbnRIYW5kbGVyMCA9IHJlYXNvbjtcblxuICAgIGlmICh0aGlzLl9pc0ZpbmFsKCkpIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLmZhdGFsRXJyb3IocmVhc29uLCB1dGlsLmlzTm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKChiaXRGaWVsZCAmIDY1NTM1KSA+IDApIHtcbiAgICAgICAgYXN5bmMuc2V0dGxlUHJvbWlzZXModGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlUG9zc2libGVSZWplY3Rpb25IYW5kbGVkKCk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX2Z1bGZpbGxQcm9taXNlcyA9IGZ1bmN0aW9uIChsZW4sIHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlckF0KGkpO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3Byb21pc2VBdChpKTtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gdGhpcy5fcmVjZWl2ZXJBdChpKTtcbiAgICAgICAgdGhpcy5fY2xlYXJDYWxsYmFja0RhdGFBdEluZGV4KGkpO1xuICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlKHByb21pc2UsIGhhbmRsZXIsIHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgfVxufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuX3JlamVjdFByb21pc2VzID0gZnVuY3Rpb24gKGxlbiwgcmVhc29uKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX3JlamVjdGlvbkhhbmRsZXJBdChpKTtcbiAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlQXQoaSk7XG4gICAgICAgIHZhciByZWNlaXZlciA9IHRoaXMuX3JlY2VpdmVyQXQoaSk7XG4gICAgICAgIHRoaXMuX2NsZWFyQ2FsbGJhY2tEYXRhQXRJbmRleChpKTtcbiAgICAgICAgdGhpcy5fc2V0dGxlUHJvbWlzZShwcm9taXNlLCBoYW5kbGVyLCByZWNlaXZlciwgcmVhc29uKTtcbiAgICB9XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5fc2V0dGxlUHJvbWlzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJpdEZpZWxkID0gdGhpcy5fYml0RmllbGQ7XG4gICAgdmFyIGxlbiA9IChiaXRGaWVsZCAmIDY1NTM1KTtcblxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGlmICgoKGJpdEZpZWxkICYgMTY4NDI3NTIpICE9PSAwKSkge1xuICAgICAgICAgICAgdmFyIHJlYXNvbiA9IHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgICAgICAgICB0aGlzLl9zZXR0bGVQcm9taXNlMCh0aGlzLl9yZWplY3Rpb25IYW5kbGVyMCwgcmVhc29uLCBiaXRGaWVsZCk7XG4gICAgICAgICAgICB0aGlzLl9yZWplY3RQcm9taXNlcyhsZW4sIHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9yZWplY3Rpb25IYW5kbGVyMDtcbiAgICAgICAgICAgIHRoaXMuX3NldHRsZVByb21pc2UwKHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjAsIHZhbHVlLCBiaXRGaWVsZCk7XG4gICAgICAgICAgICB0aGlzLl9mdWxmaWxsUHJvbWlzZXMobGVuLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0TGVuZ3RoKDApO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhckNhbmNlbGxhdGlvbkRhdGEoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9zZXR0bGVkVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYml0RmllbGQgPSB0aGlzLl9iaXRGaWVsZDtcbiAgICBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlamVjdGlvbkhhbmRsZXIwO1xuICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bGZpbGxtZW50SGFuZGxlcjA7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZGVmZXJSZXNvbHZlKHYpIHt0aGlzLnByb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2KTt9XG5mdW5jdGlvbiBkZWZlclJlamVjdCh2KSB7dGhpcy5wcm9taXNlLl9yZWplY3RDYWxsYmFjayh2LCBmYWxzZSk7fVxuXG5Qcm9taXNlLmRlZmVyID0gUHJvbWlzZS5wZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIlByb21pc2UuZGVmZXJcIiwgXCJuZXcgUHJvbWlzZVwiKTtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9taXNlOiBwcm9taXNlLFxuICAgICAgICByZXNvbHZlOiBkZWZlclJlc29sdmUsXG4gICAgICAgIHJlamVjdDogZGVmZXJSZWplY3RcbiAgICB9O1xufTtcblxudXRpbC5ub3RFbnVtZXJhYmxlUHJvcChQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICBcIl9tYWtlU2VsZlJlc29sdXRpb25FcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICBtYWtlU2VsZlJlc29sdXRpb25FcnJvcik7XG5cbnJlcXVpcmUoXCIuL21ldGhvZFwiKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uLFxuICAgIGRlYnVnKTtcbnJlcXVpcmUoXCIuL2JpbmRcIikoUHJvbWlzZSwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIGRlYnVnKTtcbnJlcXVpcmUoXCIuL2NhbmNlbFwiKShQcm9taXNlLCBQcm9taXNlQXJyYXksIGFwaVJlamVjdGlvbiwgZGVidWcpO1xucmVxdWlyZShcIi4vZGlyZWN0X3Jlc29sdmVcIikoUHJvbWlzZSk7XG5yZXF1aXJlKFwiLi9zeW5jaHJvbm91c19pbnNwZWN0aW9uXCIpKFByb21pc2UpO1xucmVxdWlyZShcIi4vam9pblwiKShcbiAgICBQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBhc3luYywgZ2V0RG9tYWluKTtcblByb21pc2UuUHJvbWlzZSA9IFByb21pc2U7XG5Qcm9taXNlLnZlcnNpb24gPSBcIjMuNS4xXCI7XG5yZXF1aXJlKCcuL21hcC5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgYXBpUmVqZWN0aW9uLCB0cnlDb252ZXJ0VG9Qcm9taXNlLCBJTlRFUk5BTCwgZGVidWcpO1xucmVxdWlyZSgnLi9jYWxsX2dldC5qcycpKFByb21pc2UpO1xucmVxdWlyZSgnLi91c2luZy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgdHJ5Q29udmVydFRvUHJvbWlzZSwgY3JlYXRlQ29udGV4dCwgSU5URVJOQUwsIGRlYnVnKTtcbnJlcXVpcmUoJy4vdGltZXJzLmpzJykoUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKTtcbnJlcXVpcmUoJy4vZ2VuZXJhdG9ycy5qcycpKFByb21pc2UsIGFwaVJlamVjdGlvbiwgSU5URVJOQUwsIHRyeUNvbnZlcnRUb1Byb21pc2UsIFByb3h5YWJsZSwgZGVidWcpO1xucmVxdWlyZSgnLi9ub2RlaWZ5LmpzJykoUHJvbWlzZSk7XG5yZXF1aXJlKCcuL3Byb21pc2lmeS5qcycpKFByb21pc2UsIElOVEVSTkFMKTtcbnJlcXVpcmUoJy4vcHJvcHMuanMnKShQcm9taXNlLCBQcm9taXNlQXJyYXksIHRyeUNvbnZlcnRUb1Byb21pc2UsIGFwaVJlamVjdGlvbik7XG5yZXF1aXJlKCcuL3JhY2UuanMnKShQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKTtcbnJlcXVpcmUoJy4vcmVkdWNlLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsIElOVEVSTkFMLCBkZWJ1Zyk7XG5yZXF1aXJlKCcuL3NldHRsZS5qcycpKFByb21pc2UsIFByb21pc2VBcnJheSwgZGVidWcpO1xucmVxdWlyZSgnLi9zb21lLmpzJykoUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pO1xucmVxdWlyZSgnLi9maWx0ZXIuanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5yZXF1aXJlKCcuL2VhY2guanMnKShQcm9taXNlLCBJTlRFUk5BTCk7XG5yZXF1aXJlKCcuL2FueS5qcycpKFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgdXRpbC50b0Zhc3RQcm9wZXJ0aWVzKFByb21pc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIHV0aWwudG9GYXN0UHJvcGVydGllcyhQcm9taXNlLnByb3RvdHlwZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmdW5jdGlvbiBmaWxsVHlwZXModmFsdWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciBwID0gbmV3IFByb21pc2UoSU5URVJOQUwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9mdWxmaWxsbWVudEhhbmRsZXIwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgcC5fcmVqZWN0aW9uSGFuZGxlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHAuX3Byb21pc2UwID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBwLl9yZWNlaXZlcjAgPSB2YWx1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgLy8gQ29tcGxldGUgc2xhY2sgdHJhY2tpbmcsIG9wdCBvdXQgb2YgZmllbGQtdHlwZSB0cmFja2luZyBhbmQgICAgICAgICAgIFxuICAgIC8vIHN0YWJpbGl6ZSBtYXAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoe2E6IDF9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKHtiOiAyfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh7YzogM30pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoMSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKGZ1bmN0aW9uKCl7fSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGZpbGxUeXBlcyh1bmRlZmluZWQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICBmaWxsVHlwZXMoZmFsc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgZmlsbFR5cGVzKG5ldyBQcm9taXNlKElOVEVSTkFMKSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgIGRlYnVnLnNldEJvdW5kcyhBc3luYy5maXJzdExpbmVFcnJvciwgdXRpbC5sYXN0TGluZUVycm9yKTsgICAgICAgICAgICAgICBcbiAgICByZXR1cm4gUHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG5cbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/promise.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/promise_array.js":
/*!***********************************************************!*\
  !*** ./node_modules/bluebird/js/release/promise_array.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise,\n    apiRejection, Proxyable) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar isArray = util.isArray;\n\nfunction toResolutionValue(val) {\n    switch(val) {\n    case -2: return [];\n    case -3: return {};\n    case -6: return new Map();\n    }\n}\n\nfunction PromiseArray(values) {\n    var promise = this._promise = new Promise(INTERNAL);\n    if (values instanceof Promise) {\n        promise._propagateFrom(values, 3);\n    }\n    promise._setOnCancel(this);\n    this._values = values;\n    this._length = 0;\n    this._totalResolved = 0;\n    this._init(undefined, -2);\n}\nutil.inherits(PromiseArray, Proxyable);\n\nPromiseArray.prototype.length = function () {\n    return this._length;\n};\n\nPromiseArray.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\n    var values = tryConvertToPromise(this._values, this._promise);\n    if (values instanceof Promise) {\n        values = values._target();\n        var bitField = values._bitField;\n        ;\n        this._values = values;\n\n        if (((bitField & 50397184) === 0)) {\n            this._promise._setAsyncGuaranteed();\n            return values._then(\n                init,\n                this._reject,\n                undefined,\n                this,\n                resolveValueIfEmpty\n           );\n        } else if (((bitField & 33554432) !== 0)) {\n            values = values._value();\n        } else if (((bitField & 16777216) !== 0)) {\n            return this._reject(values._reason());\n        } else {\n            return this._cancel();\n        }\n    }\n    values = util.asArray(values);\n    if (values === null) {\n        var err = apiRejection(\n            \"expecting an array or an iterable object but got \" + util.classString(values)).reason();\n        this._promise._rejectCallback(err, false);\n        return;\n    }\n\n    if (values.length === 0) {\n        if (resolveValueIfEmpty === -5) {\n            this._resolveEmptyArray();\n        }\n        else {\n            this._resolve(toResolutionValue(resolveValueIfEmpty));\n        }\n        return;\n    }\n    this._iterate(values);\n};\n\nPromiseArray.prototype._iterate = function(values) {\n    var len = this.getActualLength(values.length);\n    this._length = len;\n    this._values = this.shouldCopyValues() ? new Array(len) : this._values;\n    var result = this._promise;\n    var isResolved = false;\n    var bitField = null;\n    for (var i = 0; i < len; ++i) {\n        var maybePromise = tryConvertToPromise(values[i], result);\n\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            bitField = maybePromise._bitField;\n        } else {\n            bitField = null;\n        }\n\n        if (isResolved) {\n            if (bitField !== null) {\n                maybePromise.suppressUnhandledRejections();\n            }\n        } else if (bitField !== null) {\n            if (((bitField & 50397184) === 0)) {\n                maybePromise._proxy(this, i);\n                this._values[i] = maybePromise;\n            } else if (((bitField & 33554432) !== 0)) {\n                isResolved = this._promiseFulfilled(maybePromise._value(), i);\n            } else if (((bitField & 16777216) !== 0)) {\n                isResolved = this._promiseRejected(maybePromise._reason(), i);\n            } else {\n                isResolved = this._promiseCancelled(i);\n            }\n        } else {\n            isResolved = this._promiseFulfilled(maybePromise, i);\n        }\n    }\n    if (!isResolved) result._setAsyncGuaranteed();\n};\n\nPromiseArray.prototype._isResolved = function () {\n    return this._values === null;\n};\n\nPromiseArray.prototype._resolve = function (value) {\n    this._values = null;\n    this._promise._fulfill(value);\n};\n\nPromiseArray.prototype._cancel = function() {\n    if (this._isResolved() || !this._promise._isCancellable()) return;\n    this._values = null;\n    this._promise._cancel();\n};\n\nPromiseArray.prototype._reject = function (reason) {\n    this._values = null;\n    this._promise._rejectCallback(reason, false);\n};\n\nPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n        return true;\n    }\n    return false;\n};\n\nPromiseArray.prototype._promiseCancelled = function() {\n    this._cancel();\n    return true;\n};\n\nPromiseArray.prototype._promiseRejected = function (reason) {\n    this._totalResolved++;\n    this._reject(reason);\n    return true;\n};\n\nPromiseArray.prototype._resultCancelled = function() {\n    if (this._isResolved()) return;\n    var values = this._values;\n    this._cancel();\n    if (values instanceof Promise) {\n        values.cancel();\n    } else {\n        for (var i = 0; i < values.length; ++i) {\n            if (values[i] instanceof Promise) {\n                values[i].cancel();\n            }\n        }\n    }\n};\n\nPromiseArray.prototype.shouldCopyValues = function () {\n    return true;\n};\n\nPromiseArray.prototype.getActualLength = function (len) {\n    return len;\n};\n\nreturn PromiseArray;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNlX2FycmF5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcHJvbWlzZV9hcnJheS5qcz9jN2JiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSxcbiAgICBhcGlSZWplY3Rpb24sIFByb3h5YWJsZSkge1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGlzQXJyYXkgPSB1dGlsLmlzQXJyYXk7XG5cbmZ1bmN0aW9uIHRvUmVzb2x1dGlvblZhbHVlKHZhbCkge1xuICAgIHN3aXRjaCh2YWwpIHtcbiAgICBjYXNlIC0yOiByZXR1cm4gW107XG4gICAgY2FzZSAtMzogcmV0dXJuIHt9O1xuICAgIGNhc2UgLTY6IHJldHVybiBuZXcgTWFwKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBQcm9taXNlQXJyYXkodmFsdWVzKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UuX3Byb3BhZ2F0ZUZyb20odmFsdWVzLCAzKTtcbiAgICB9XG4gICAgcHJvbWlzZS5fc2V0T25DYW5jZWwodGhpcyk7XG4gICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fdG90YWxSZXNvbHZlZCA9IDA7XG4gICAgdGhpcy5faW5pdCh1bmRlZmluZWQsIC0yKTtcbn1cbnV0aWwuaW5oZXJpdHMoUHJvbWlzZUFycmF5LCBQcm94eWFibGUpO1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5wcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoXywgcmVzb2x2ZVZhbHVlSWZFbXB0eSkge1xuICAgIHZhciB2YWx1ZXMgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXMuX3ZhbHVlcywgdGhpcy5fcHJvbWlzZSk7XG4gICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFsdWVzID0gdmFsdWVzLl90YXJnZXQoKTtcbiAgICAgICAgdmFyIGJpdEZpZWxkID0gdmFsdWVzLl9iaXRGaWVsZDtcbiAgICAgICAgO1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICAgICAgaWYgKCgoYml0RmllbGQgJiA1MDM5NzE4NCkgPT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMuX3RoZW4oXG4gICAgICAgICAgICAgICAgaW5pdCxcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3QsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlSWZFbXB0eVxuICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKCgoYml0RmllbGQgJiAzMzU1NDQzMikgIT09IDApKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuX3ZhbHVlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDE2Nzc3MjE2KSAhPT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWplY3QodmFsdWVzLl9yZWFzb24oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzID0gdXRpbC5hc0FycmF5KHZhbHVlcyk7XG4gICAgaWYgKHZhbHVlcyA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgZXJyID0gYXBpUmVqZWN0aW9uKFxuICAgICAgICAgICAgXCJleHBlY3RpbmcgYW4gYXJyYXkgb3IgYW4gaXRlcmFibGUgb2JqZWN0IGJ1dCBnb3QgXCIgKyB1dGlsLmNsYXNzU3RyaW5nKHZhbHVlcykpLnJlYXNvbigpO1xuICAgICAgICB0aGlzLl9wcm9taXNlLl9yZWplY3RDYWxsYmFjayhlcnIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChyZXNvbHZlVmFsdWVJZkVtcHR5ID09PSAtNSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5QXJyYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodG9SZXNvbHV0aW9uVmFsdWUocmVzb2x2ZVZhbHVlSWZFbXB0eSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faXRlcmF0ZSh2YWx1ZXMpO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIHZhciBsZW4gPSB0aGlzLmdldEFjdHVhbExlbmd0aCh2YWx1ZXMubGVuZ3RoKTtcbiAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gICAgdGhpcy5fdmFsdWVzID0gdGhpcy5zaG91bGRDb3B5VmFsdWVzKCkgPyBuZXcgQXJyYXkobGVuKSA6IHRoaXMuX3ZhbHVlcztcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcHJvbWlzZTtcbiAgICB2YXIgaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIHZhciBiaXRGaWVsZCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZSh2YWx1ZXNbaV0sIHJlc3VsdCk7XG5cbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgICAgICBiaXRGaWVsZCA9IG1heWJlUHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiaXRGaWVsZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgaWYgKGJpdEZpZWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLnN1cHByZXNzVW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGJpdEZpZWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKChiaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX3Byb3h5KHRoaXMsIGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpXSA9IG1heWJlUHJvbWlzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKChiaXRGaWVsZCAmIDMzNTU0NDMyKSAhPT0gMCkpIHtcbiAgICAgICAgICAgICAgICBpc1Jlc29sdmVkID0gdGhpcy5fcHJvbWlzZUZ1bGZpbGxlZChtYXliZVByb21pc2UuX3ZhbHVlKCksIGkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoKGJpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlUmVqZWN0ZWQobWF5YmVQcm9taXNlLl9yZWFzb24oKSwgaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0aGlzLl9wcm9taXNlQ2FuY2VsbGVkKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRoaXMuX3Byb21pc2VGdWxmaWxsZWQobWF5YmVQcm9taXNlLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzUmVzb2x2ZWQpIHJlc3VsdC5fc2V0QXN5bmNHdWFyYW50ZWVkKCk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9pc1Jlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMgPT09IG51bGw7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9mdWxmaWxsKHZhbHVlKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX2NhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkgfHwgIXRoaXMuX3Byb21pc2UuX2lzQ2FuY2VsbGFibGUoKSkgcmV0dXJuO1xuICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5fcHJvbWlzZS5fY2FuY2VsKCk7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbiAgICB0aGlzLl9wcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZWFzb24sIGZhbHNlKTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgIHZhciB0b3RhbFJlc29sdmVkID0gKyt0aGlzLl90b3RhbFJlc29sdmVkO1xuICAgIGlmICh0b3RhbFJlc29sdmVkID49IHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlQ2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVqZWN0ZWQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhpcy5fdG90YWxSZXNvbHZlZCsrO1xuICAgIHRoaXMuX3JlamVjdChyZWFzb24pO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2lzUmVzb2x2ZWQoKSkgcmV0dXJuO1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XG4gICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdmFsdWVzLmNhbmNlbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW2ldIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpXS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuc2hvdWxkQ29weVZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblByb21pc2VBcnJheS5wcm90b3R5cGUuZ2V0QWN0dWFsTGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgIHJldHVybiBsZW47XG59O1xuXG5yZXR1cm4gUHJvbWlzZUFycmF5O1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/promise_array.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/promisify.js":
/*!*******************************************************!*\
  !*** ./node_modules/bluebird/js/release/promisify.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar THIS = {};\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar nodebackForPromise = __webpack_require__(/*! ./nodeback */ \"./node_modules/bluebird/js/release/nodeback.js\");\nvar withAppended = util.withAppended;\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar canEvaluate = util.canEvaluate;\nvar TypeError = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\").TypeError;\nvar defaultSuffix = \"Async\";\nvar defaultPromisified = {__isPromisified__: true};\nvar noCopyProps = [\n    \"arity\",    \"length\",\n    \"name\",\n    \"arguments\",\n    \"caller\",\n    \"callee\",\n    \"prototype\",\n    \"__isPromisified__\"\n];\nvar noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n\nvar defaultFilter = function(name) {\n    return util.isIdentifier(name) &&\n        name.charAt(0) !== \"_\" &&\n        name !== \"constructor\";\n};\n\nfunction propsFilter(key) {\n    return !noCopyPropsPattern.test(key);\n}\n\nfunction isPromisified(fn) {\n    try {\n        return fn.__isPromisified__ === true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n\nfunction hasPromisified(obj, key, suffix) {\n    var val = util.getDataPropertyOrDefault(obj, key + suffix,\n                                            defaultPromisified);\n    return val ? isPromisified(val) : false;\n}\nfunction checkValid(ret, suffix, suffixRegexp) {\n    for (var i = 0; i < ret.length; i += 2) {\n        var key = ret[i];\n        if (suffixRegexp.test(key)) {\n            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n            for (var j = 0; j < ret.length; j += 2) {\n                if (ret[j] === keyWithoutAsyncSuffix) {\n                    throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\"\n                        .replace(\"%s\", suffix));\n                }\n            }\n        }\n    }\n}\n\nfunction promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n    var keys = util.inheritedDataKeys(obj);\n    var ret = [];\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var value = obj[key];\n        var passesDefaultFilter = filter === defaultFilter\n            ? true : defaultFilter(key, value, obj);\n        if (typeof value === \"function\" &&\n            !isPromisified(value) &&\n            !hasPromisified(obj, key, suffix) &&\n            filter(key, value, obj, passesDefaultFilter)) {\n            ret.push(key, value);\n        }\n    }\n    checkValid(ret, suffix, suffixRegexp);\n    return ret;\n}\n\nvar escapeIdentRegex = function(str) {\n    return str.replace(/([$])/, \"\\\\$\");\n};\n\nvar makeNodePromisifiedEval;\nif (true) {\nvar switchCaseArgumentOrder = function(likelyArgumentCount) {\n    var ret = [likelyArgumentCount];\n    var min = Math.max(0, likelyArgumentCount - 1 - 3);\n    for(var i = likelyArgumentCount - 1; i >= min; --i) {\n        ret.push(i);\n    }\n    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {\n        ret.push(i);\n    }\n    return ret;\n};\n\nvar argumentSequence = function(argumentCount) {\n    return util.filledRange(argumentCount, \"_arg\", \"\");\n};\n\nvar parameterDeclaration = function(parameterCount) {\n    return util.filledRange(\n        Math.max(parameterCount, 3), \"_arg\", \"\");\n};\n\nvar parameterCount = function(fn) {\n    if (typeof fn.length === \"number\") {\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n    }\n    return 0;\n};\n\nmakeNodePromisifiedEval =\nfunction(callback, receiver, originalName, fn, _, multiArgs) {\n    var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n    var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n    var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\n    function generateCallForArgumentCount(count) {\n        var args = argumentSequence(count).join(\", \");\n        var comma = count > 0 ? \", \" : \"\";\n        var ret;\n        if (shouldProxyThis) {\n            ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n        } else {\n            ret = receiver === undefined\n                ? \"ret = callback({{args}}, nodeback); break;\\n\"\n                : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n        }\n        return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n    }\n\n    function generateArgumentSwitchCase() {\n        var ret = \"\";\n        for (var i = 0; i < argumentOrder.length; ++i) {\n            ret += \"case \" + argumentOrder[i] +\":\" +\n                generateCallForArgumentCount(argumentOrder[i]);\n        }\n\n        ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", (shouldProxyThis\n                                ? \"ret = callback.apply(this, args);\\n\"\n                                : \"ret = callback.apply(receiver, args);\\n\"));\n        return ret;\n    }\n\n    var getFunctionCode = typeof callback === \"string\"\n                                ? (\"this != null ? this['\"+callback+\"'] : fn\")\n                                : \"fn\";\n    var body = \"'use strict';                                                \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise, \" + multiArgs + \");   \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\n\\\n        return ret;                                                          \\n\\\n    \".replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase())\n        .replace(\"[GetFunctionCode]\", getFunctionCode);\n    body = body.replace(\"Parameters\", parameterDeclaration(newParameterCount));\n    return new Function(\"Promise\",\n                        \"fn\",\n                        \"receiver\",\n                        \"withAppended\",\n                        \"maybeWrapAsError\",\n                        \"nodebackForPromise\",\n                        \"tryCatch\",\n                        \"errorObj\",\n                        \"notEnumerableProp\",\n                        \"INTERNAL\",\n                        body)(\n                    Promise,\n                    fn,\n                    receiver,\n                    withAppended,\n                    maybeWrapAsError,\n                    nodebackForPromise,\n                    util.tryCatch,\n                    util.errorObj,\n                    util.notEnumerableProp,\n                    INTERNAL);\n};\n}\n\nfunction makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {\n    var defaultThis = (function() {return this;})();\n    var method = callback;\n    if (typeof method === \"string\") {\n        callback = fn;\n    }\n    function promisified() {\n        var _receiver = receiver;\n        if (receiver === THIS) _receiver = this;\n        var promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n        var cb = typeof method === \"string\" && this !== defaultThis\n            ? this[method] : callback;\n        var fn = nodebackForPromise(promise, multiArgs);\n        try {\n            cb.apply(_receiver, withAppended(arguments, fn));\n        } catch(e) {\n            promise._rejectCallback(maybeWrapAsError(e), true, true);\n        }\n        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();\n        return promise;\n    }\n    util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n    return promisified;\n}\n\nvar makeNodePromisified = canEvaluate\n    ? makeNodePromisifiedEval\n    : makeNodePromisifiedClosure;\n\nfunction promisifyAll(obj, suffix, filter, promisifier, multiArgs) {\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n    var methods =\n        promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n    for (var i = 0, len = methods.length; i < len; i+= 2) {\n        var key = methods[i];\n        var fn = methods[i+1];\n        var promisifiedKey = key + suffix;\n        if (promisifier === makeNodePromisified) {\n            obj[promisifiedKey] =\n                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n        } else {\n            var promisified = promisifier(fn, function() {\n                return makeNodePromisified(key, THIS, key,\n                                           fn, suffix, multiArgs);\n            });\n            util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n            obj[promisifiedKey] = promisified;\n        }\n    }\n    util.toFastProperties(obj);\n    return obj;\n}\n\nfunction promisify(callback, receiver, multiArgs) {\n    return makeNodePromisified(callback, receiver, undefined,\n                                callback, null, multiArgs);\n}\n\nPromise.promisify = function (fn, options) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"expecting a function but got \" + util.classString(fn));\n    }\n    if (isPromisified(fn)) {\n        return fn;\n    }\n    options = Object(options);\n    var receiver = options.context === undefined ? THIS : options.context;\n    var multiArgs = !!options.multiArgs;\n    var ret = promisify(fn, receiver, multiArgs);\n    util.copyDescriptors(fn, ret, propsFilter);\n    return ret;\n};\n\nPromise.promisifyAll = function (target, options) {\n    if (typeof target !== \"function\" && typeof target !== \"object\") {\n        throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    options = Object(options);\n    var multiArgs = !!options.multiArgs;\n    var suffix = options.suffix;\n    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n    var filter = options.filter;\n    if (typeof filter !== \"function\") filter = defaultFilter;\n    var promisifier = options.promisifier;\n    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n    if (!util.isIdentifier(suffix)) {\n        throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n\n    var keys = util.inheritedDataKeys(target);\n    for (var i = 0; i < keys.length; ++i) {\n        var value = target[keys[i]];\n        if (keys[i] !== \"constructor\" &&\n            util.isClass(value)) {\n            promisifyAll(value.prototype, suffix, filter, promisifier,\n                multiArgs);\n            promisifyAll(value, suffix, filter, promisifier, multiArgs);\n        }\n    }\n\n    return promisifyAll(target, suffix, filter, promisifier, multiArgs);\n};\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNpZnkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9taXNpZnkuanM/YjYyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciBUSElTID0ge307XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgbm9kZWJhY2tGb3JQcm9taXNlID0gcmVxdWlyZShcIi4vbm9kZWJhY2tcIik7XG52YXIgd2l0aEFwcGVuZGVkID0gdXRpbC53aXRoQXBwZW5kZWQ7XG52YXIgbWF5YmVXcmFwQXNFcnJvciA9IHV0aWwubWF5YmVXcmFwQXNFcnJvcjtcbnZhciBjYW5FdmFsdWF0ZSA9IHV0aWwuY2FuRXZhbHVhdGU7XG52YXIgVHlwZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpLlR5cGVFcnJvcjtcbnZhciBkZWZhdWx0U3VmZml4ID0gXCJBc3luY1wiO1xudmFyIGRlZmF1bHRQcm9taXNpZmllZCA9IHtfX2lzUHJvbWlzaWZpZWRfXzogdHJ1ZX07XG52YXIgbm9Db3B5UHJvcHMgPSBbXG4gICAgXCJhcml0eVwiLCAgICBcImxlbmd0aFwiLFxuICAgIFwibmFtZVwiLFxuICAgIFwiYXJndW1lbnRzXCIsXG4gICAgXCJjYWxsZXJcIixcbiAgICBcImNhbGxlZVwiLFxuICAgIFwicHJvdG90eXBlXCIsXG4gICAgXCJfX2lzUHJvbWlzaWZpZWRfX1wiXG5dO1xudmFyIG5vQ29weVByb3BzUGF0dGVybiA9IG5ldyBSZWdFeHAoXCJeKD86XCIgKyBub0NvcHlQcm9wcy5qb2luKFwifFwiKSArIFwiKSRcIik7XG5cbnZhciBkZWZhdWx0RmlsdGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB1dGlsLmlzSWRlbnRpZmllcihuYW1lKSAmJlxuICAgICAgICBuYW1lLmNoYXJBdCgwKSAhPT0gXCJfXCIgJiZcbiAgICAgICAgbmFtZSAhPT0gXCJjb25zdHJ1Y3RvclwiO1xufTtcblxuZnVuY3Rpb24gcHJvcHNGaWx0ZXIoa2V5KSB7XG4gICAgcmV0dXJuICFub0NvcHlQcm9wc1BhdHRlcm4udGVzdChrZXkpO1xufVxuXG5mdW5jdGlvbiBpc1Byb21pc2lmaWVkKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuLl9faXNQcm9taXNpZmllZF9fID09PSB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNQcm9taXNpZmllZChvYmosIGtleSwgc3VmZml4KSB7XG4gICAgdmFyIHZhbCA9IHV0aWwuZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0KG9iaiwga2V5ICsgc3VmZml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvbWlzaWZpZWQpO1xuICAgIHJldHVybiB2YWwgPyBpc1Byb21pc2lmaWVkKHZhbCkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsaWQocmV0LCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXRbaV07XG4gICAgICAgIGlmIChzdWZmaXhSZWdleHAudGVzdChrZXkpKSB7XG4gICAgICAgICAgICB2YXIga2V5V2l0aG91dEFzeW5jU3VmZml4ID0ga2V5LnJlcGxhY2Uoc3VmZml4UmVnZXhwLCBcIlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmV0Lmxlbmd0aDsgaiArPSAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldFtqXSA9PT0ga2V5V2l0aG91dEFzeW5jU3VmZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcHJvbWlzaWZ5IGFuIEFQSSB0aGF0IGhhcyBub3JtYWwgbWV0aG9kcyB3aXRoICclcyctc3VmZml4XFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcIiVzXCIsIHN1ZmZpeCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZpYWJsZU1ldGhvZHMob2JqLCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCwgZmlsdGVyKSB7XG4gICAgdmFyIGtleXMgPSB1dGlsLmluaGVyaXRlZERhdGFLZXlzKG9iaik7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIHZhciBwYXNzZXNEZWZhdWx0RmlsdGVyID0gZmlsdGVyID09PSBkZWZhdWx0RmlsdGVyXG4gICAgICAgICAgICA/IHRydWUgOiBkZWZhdWx0RmlsdGVyKGtleSwgdmFsdWUsIG9iaik7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgIWlzUHJvbWlzaWZpZWQodmFsdWUpICYmXG4gICAgICAgICAgICAhaGFzUHJvbWlzaWZpZWQob2JqLCBrZXksIHN1ZmZpeCkgJiZcbiAgICAgICAgICAgIGZpbHRlcihrZXksIHZhbHVlLCBvYmosIHBhc3Nlc0RlZmF1bHRGaWx0ZXIpKSB7XG4gICAgICAgICAgICByZXQucHVzaChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1ZhbGlkKHJldCwgc3VmZml4LCBzdWZmaXhSZWdleHApO1xuICAgIHJldHVybiByZXQ7XG59XG5cbnZhciBlc2NhcGVJZGVudFJlZ2V4ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWyRdKS8sIFwiXFxcXCRcIik7XG59O1xuXG52YXIgbWFrZU5vZGVQcm9taXNpZmllZEV2YWw7XG5pZiAoIWZhbHNlKSB7XG52YXIgc3dpdGNoQ2FzZUFyZ3VtZW50T3JkZXIgPSBmdW5jdGlvbihsaWtlbHlBcmd1bWVudENvdW50KSB7XG4gICAgdmFyIHJldCA9IFtsaWtlbHlBcmd1bWVudENvdW50XTtcbiAgICB2YXIgbWluID0gTWF0aC5tYXgoMCwgbGlrZWx5QXJndW1lbnRDb3VudCAtIDEgLSAzKTtcbiAgICBmb3IodmFyIGkgPSBsaWtlbHlBcmd1bWVudENvdW50IC0gMTsgaSA+PSBtaW47IC0taSkge1xuICAgICAgICByZXQucHVzaChpKTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gbGlrZWx5QXJndW1lbnRDb3VudCArIDE7IGkgPD0gMzsgKytpKSB7XG4gICAgICAgIHJldC5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxudmFyIGFyZ3VtZW50U2VxdWVuY2UgPSBmdW5jdGlvbihhcmd1bWVudENvdW50KSB7XG4gICAgcmV0dXJuIHV0aWwuZmlsbGVkUmFuZ2UoYXJndW1lbnRDb3VudCwgXCJfYXJnXCIsIFwiXCIpO1xufTtcblxudmFyIHBhcmFtZXRlckRlY2xhcmF0aW9uID0gZnVuY3Rpb24ocGFyYW1ldGVyQ291bnQpIHtcbiAgICByZXR1cm4gdXRpbC5maWxsZWRSYW5nZShcbiAgICAgICAgTWF0aC5tYXgocGFyYW1ldGVyQ291bnQsIDMpLCBcIl9hcmdcIiwgXCJcIik7XG59O1xuXG52YXIgcGFyYW1ldGVyQ291bnQgPSBmdW5jdGlvbihmbikge1xuICAgIGlmICh0eXBlb2YgZm4ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihmbi5sZW5ndGgsIDEwMjMgKyAxKSwgMCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxubWFrZU5vZGVQcm9taXNpZmllZEV2YWwgPVxuZnVuY3Rpb24oY2FsbGJhY2ssIHJlY2VpdmVyLCBvcmlnaW5hbE5hbWUsIGZuLCBfLCBtdWx0aUFyZ3MpIHtcbiAgICB2YXIgbmV3UGFyYW1ldGVyQ291bnQgPSBNYXRoLm1heCgwLCBwYXJhbWV0ZXJDb3VudChmbikgLSAxKTtcbiAgICB2YXIgYXJndW1lbnRPcmRlciA9IHN3aXRjaENhc2VBcmd1bWVudE9yZGVyKG5ld1BhcmFtZXRlckNvdW50KTtcbiAgICB2YXIgc2hvdWxkUHJveHlUaGlzID0gdHlwZW9mIGNhbGxiYWNrID09PSBcInN0cmluZ1wiIHx8IHJlY2VpdmVyID09PSBUSElTO1xuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDYWxsRm9yQXJndW1lbnRDb3VudChjb3VudCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50U2VxdWVuY2UoY291bnQpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdmFyIGNvbW1hID0gY291bnQgPiAwID8gXCIsIFwiIDogXCJcIjtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgaWYgKHNob3VsZFByb3h5VGhpcykge1xuICAgICAgICAgICAgcmV0ID0gXCJyZXQgPSBjYWxsYmFjay5jYWxsKHRoaXMsIHt7YXJnc319LCBub2RlYmFjayk7IGJyZWFrO1xcblwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gcmVjZWl2ZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gXCJyZXQgPSBjYWxsYmFjayh7e2FyZ3N9fSwgbm9kZWJhY2spOyBicmVhaztcXG5cIlxuICAgICAgICAgICAgICAgIDogXCJyZXQgPSBjYWxsYmFjay5jYWxsKHJlY2VpdmVyLCB7e2FyZ3N9fSwgbm9kZWJhY2spOyBicmVhaztcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0LnJlcGxhY2UoXCJ7e2FyZ3N9fVwiLCBhcmdzKS5yZXBsYWNlKFwiLCBcIiwgY29tbWEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQXJndW1lbnRTd2l0Y2hDYXNlKCkge1xuICAgICAgICB2YXIgcmV0ID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudE9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXQgKz0gXCJjYXNlIFwiICsgYXJndW1lbnRPcmRlcltpXSArXCI6XCIgK1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQ2FsbEZvckFyZ3VtZW50Q291bnQoYXJndW1lbnRPcmRlcltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgKz0gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIHZhciBpID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGFyZ3NbaV0gPSBub2RlYmFjazsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIFtDb2RlRm9yQ2FsbF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxuXFxcbiAgICAgICAgXCIucmVwbGFjZShcIltDb2RlRm9yQ2FsbF1cIiwgKHNob3VsZFByb3h5VGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwicmV0ID0gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XFxuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcInJldCA9IGNhbGxiYWNrLmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcXG5cIikpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHZhciBnZXRGdW5jdGlvbkNvZGUgPSB0eXBlb2YgY2FsbGJhY2sgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoXCJ0aGlzICE9IG51bGwgPyB0aGlzWydcIitjYWxsYmFjaytcIiddIDogZm5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImZuXCI7XG4gICAgdmFyIGJvZHkgPSBcIid1c2Ugc3RyaWN0JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICB2YXIgcmV0ID0gZnVuY3Rpb24gKFBhcmFtZXRlcnMpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgcHJvbWlzZS5fY2FwdHVyZVN0YWNrVHJhY2UoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXG5cXFxuICAgICAgICAgICAgdmFyIG5vZGViYWNrID0gbm9kZWJhY2tGb3JQcm9taXNlKHByb21pc2UsIFwiICsgbXVsdGlBcmdzICsgXCIpOyAgIFxcblxcXG4gICAgICAgICAgICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSB0cnlDYXRjaChbR2V0RnVuY3Rpb25Db2RlXSk7ICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBzd2l0Y2gobGVuKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgW0NvZGVGb3JTd2l0Y2hDYXNlXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBpZiAocmV0ID09PSBlcnJvck9iaikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2sobWF5YmVXcmFwQXNFcnJvcihyZXQuZSksIHRydWUsIHRydWUpO1xcblxcXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgICAgICBpZiAoIXByb21pc2UuX2lzRmF0ZVNlYWxlZCgpKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTsgICAgIFxcblxcXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIG5vdEVudW1lcmFibGVQcm9wKHJldCwgJ19faXNQcm9taXNpZmllZF9fJywgdHJ1ZSk7ICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgICAgIHJldHVybiByZXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcblxcXG4gICAgXCIucmVwbGFjZShcIltDb2RlRm9yU3dpdGNoQ2FzZV1cIiwgZ2VuZXJhdGVBcmd1bWVudFN3aXRjaENhc2UoKSlcbiAgICAgICAgLnJlcGxhY2UoXCJbR2V0RnVuY3Rpb25Db2RlXVwiLCBnZXRGdW5jdGlvbkNvZGUpO1xuICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoXCJQYXJhbWV0ZXJzXCIsIHBhcmFtZXRlckRlY2xhcmF0aW9uKG5ld1BhcmFtZXRlckNvdW50KSk7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcIlByb21pc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZm5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVjZWl2ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2l0aEFwcGVuZGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1heWJlV3JhcEFzRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibm9kZWJhY2tGb3JQcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRyeUNhdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImVycm9yT2JqXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5vdEVudW1lcmFibGVQcm9wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIklOVEVSTkFMXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5KShcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgZm4sXG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVyLFxuICAgICAgICAgICAgICAgICAgICB3aXRoQXBwZW5kZWQsXG4gICAgICAgICAgICAgICAgICAgIG1heWJlV3JhcEFzRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIG5vZGViYWNrRm9yUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgdXRpbC50cnlDYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5lcnJvck9iaixcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcCxcbiAgICAgICAgICAgICAgICAgICAgSU5URVJOQUwpO1xufTtcbn1cblxuZnVuY3Rpb24gbWFrZU5vZGVQcm9taXNpZmllZENsb3N1cmUoY2FsbGJhY2ssIHJlY2VpdmVyLCBfLCBmbiwgX18sIG11bHRpQXJncykge1xuICAgIHZhciBkZWZhdWx0VGhpcyA9IChmdW5jdGlvbigpIHtyZXR1cm4gdGhpczt9KSgpO1xuICAgIHZhciBtZXRob2QgPSBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjYWxsYmFjayA9IGZuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9taXNpZmllZCgpIHtcbiAgICAgICAgdmFyIF9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IFRISVMpIF9yZWNlaXZlciA9IHRoaXM7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgICAgICB2YXIgY2IgPSB0eXBlb2YgbWV0aG9kID09PSBcInN0cmluZ1wiICYmIHRoaXMgIT09IGRlZmF1bHRUaGlzXG4gICAgICAgICAgICA/IHRoaXNbbWV0aG9kXSA6IGNhbGxiYWNrO1xuICAgICAgICB2YXIgZm4gPSBub2RlYmFja0ZvclByb21pc2UocHJvbWlzZSwgbXVsdGlBcmdzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNiLmFwcGx5KF9yZWNlaXZlciwgd2l0aEFwcGVuZGVkKGFyZ3VtZW50cywgZm4pKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhtYXliZVdyYXBBc0Vycm9yKGUpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb21pc2UuX2lzRmF0ZVNlYWxlZCgpKSBwcm9taXNlLl9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHV0aWwubm90RW51bWVyYWJsZVByb3AocHJvbWlzaWZpZWQsIFwiX19pc1Byb21pc2lmaWVkX19cIiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHByb21pc2lmaWVkO1xufVxuXG52YXIgbWFrZU5vZGVQcm9taXNpZmllZCA9IGNhbkV2YWx1YXRlXG4gICAgPyBtYWtlTm9kZVByb21pc2lmaWVkRXZhbFxuICAgIDogbWFrZU5vZGVQcm9taXNpZmllZENsb3N1cmU7XG5cbmZ1bmN0aW9uIHByb21pc2lmeUFsbChvYmosIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllciwgbXVsdGlBcmdzKSB7XG4gICAgdmFyIHN1ZmZpeFJlZ2V4cCA9IG5ldyBSZWdFeHAoZXNjYXBlSWRlbnRSZWdleChzdWZmaXgpICsgXCIkXCIpO1xuICAgIHZhciBtZXRob2RzID1cbiAgICAgICAgcHJvbWlzaWZpYWJsZU1ldGhvZHMob2JqLCBzdWZmaXgsIHN1ZmZpeFJlZ2V4cCwgZmlsdGVyKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtZXRob2RzLmxlbmd0aDsgaSA8IGxlbjsgaSs9IDIpIHtcbiAgICAgICAgdmFyIGtleSA9IG1ldGhvZHNbaV07XG4gICAgICAgIHZhciBmbiA9IG1ldGhvZHNbaSsxXTtcbiAgICAgICAgdmFyIHByb21pc2lmaWVkS2V5ID0ga2V5ICsgc3VmZml4O1xuICAgICAgICBpZiAocHJvbWlzaWZpZXIgPT09IG1ha2VOb2RlUHJvbWlzaWZpZWQpIHtcbiAgICAgICAgICAgIG9ialtwcm9taXNpZmllZEtleV0gPVxuICAgICAgICAgICAgICAgIG1ha2VOb2RlUHJvbWlzaWZpZWQoa2V5LCBUSElTLCBrZXksIGZuLCBzdWZmaXgsIG11bHRpQXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzaWZpZWQgPSBwcm9taXNpZmllcihmbiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VOb2RlUHJvbWlzaWZpZWQoa2V5LCBUSElTLCBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4sIHN1ZmZpeCwgbXVsdGlBcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXRpbC5ub3RFbnVtZXJhYmxlUHJvcChwcm9taXNpZmllZCwgXCJfX2lzUHJvbWlzaWZpZWRfX1wiLCB0cnVlKTtcbiAgICAgICAgICAgIG9ialtwcm9taXNpZmllZEtleV0gPSBwcm9taXNpZmllZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1dGlsLnRvRmFzdFByb3BlcnRpZXMob2JqKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBwcm9taXNpZnkoY2FsbGJhY2ssIHJlY2VpdmVyLCBtdWx0aUFyZ3MpIHtcbiAgICByZXR1cm4gbWFrZU5vZGVQcm9taXNpZmllZChjYWxsYmFjaywgcmVjZWl2ZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2ssIG51bGwsIG11bHRpQXJncyk7XG59XG5cblByb21pc2UucHJvbWlzaWZ5ID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgIH1cbiAgICBpZiAoaXNQcm9taXNpZmllZChmbikpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH1cbiAgICBvcHRpb25zID0gT2JqZWN0KG9wdGlvbnMpO1xuICAgIHZhciByZWNlaXZlciA9IG9wdGlvbnMuY29udGV4dCA9PT0gdW5kZWZpbmVkID8gVEhJUyA6IG9wdGlvbnMuY29udGV4dDtcbiAgICB2YXIgbXVsdGlBcmdzID0gISFvcHRpb25zLm11bHRpQXJncztcbiAgICB2YXIgcmV0ID0gcHJvbWlzaWZ5KGZuLCByZWNlaXZlciwgbXVsdGlBcmdzKTtcbiAgICB1dGlsLmNvcHlEZXNjcmlwdG9ycyhmbiwgcmV0LCBwcm9wc0ZpbHRlcik7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cblByb21pc2UucHJvbWlzaWZ5QWxsID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidGhlIHRhcmdldCBvZiBwcm9taXNpZnlBbGwgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvblxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBPYmplY3Qob3B0aW9ucyk7XG4gICAgdmFyIG11bHRpQXJncyA9ICEhb3B0aW9ucy5tdWx0aUFyZ3M7XG4gICAgdmFyIHN1ZmZpeCA9IG9wdGlvbnMuc3VmZml4O1xuICAgIGlmICh0eXBlb2Ygc3VmZml4ICE9PSBcInN0cmluZ1wiKSBzdWZmaXggPSBkZWZhdWx0U3VmZml4O1xuICAgIHZhciBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICBpZiAodHlwZW9mIGZpbHRlciAhPT0gXCJmdW5jdGlvblwiKSBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyO1xuICAgIHZhciBwcm9taXNpZmllciA9IG9wdGlvbnMucHJvbWlzaWZpZXI7XG4gICAgaWYgKHR5cGVvZiBwcm9taXNpZmllciAhPT0gXCJmdW5jdGlvblwiKSBwcm9taXNpZmllciA9IG1ha2VOb2RlUHJvbWlzaWZpZWQ7XG5cbiAgICBpZiAoIXV0aWwuaXNJZGVudGlmaWVyKHN1ZmZpeCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzdWZmaXggbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gdXRpbC5pbmhlcml0ZWREYXRhS2V5cyh0YXJnZXQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0YXJnZXRba2V5c1tpXV07XG4gICAgICAgIGlmIChrZXlzW2ldICE9PSBcImNvbnN0cnVjdG9yXCIgJiZcbiAgICAgICAgICAgIHV0aWwuaXNDbGFzcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHByb21pc2lmeUFsbCh2YWx1ZS5wcm90b3R5cGUsIHN1ZmZpeCwgZmlsdGVyLCBwcm9taXNpZmllcixcbiAgICAgICAgICAgICAgICBtdWx0aUFyZ3MpO1xuICAgICAgICAgICAgcHJvbWlzaWZ5QWxsKHZhbHVlLCBzdWZmaXgsIGZpbHRlciwgcHJvbWlzaWZpZXIsIG11bHRpQXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzaWZ5QWxsKHRhcmdldCwgc3VmZml4LCBmaWx0ZXIsIHByb21pc2lmaWVyLCBtdWx0aUFyZ3MpO1xufTtcbn07XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/promisify.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/props.js":
/*!***************************************************!*\
  !*** ./node_modules/bluebird/js/release/props.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(\n    Promise, PromiseArray, tryConvertToPromise, apiRejection) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar isObject = util.isObject;\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/bluebird/js/release/es5.js\");\nvar Es6Map;\nif (typeof Map === \"function\") Es6Map = Map;\n\nvar mapToEntries = (function() {\n    var index = 0;\n    var size = 0;\n\n    function extractEntry(value, key) {\n        this[index] = value;\n        this[index + size] = key;\n        index++;\n    }\n\n    return function mapToEntries(map) {\n        size = map.size;\n        index = 0;\n        var ret = new Array(map.size * 2);\n        map.forEach(extractEntry, ret);\n        return ret;\n    };\n})();\n\nvar entriesToMap = function(entries) {\n    var ret = new Es6Map();\n    var length = entries.length / 2 | 0;\n    for (var i = 0; i < length; ++i) {\n        var key = entries[length + i];\n        var value = entries[i];\n        ret.set(key, value);\n    }\n    return ret;\n};\n\nfunction PropertiesPromiseArray(obj) {\n    var isMap = false;\n    var entries;\n    if (Es6Map !== undefined && obj instanceof Es6Map) {\n        entries = mapToEntries(obj);\n        isMap = true;\n    } else {\n        var keys = es5.keys(obj);\n        var len = keys.length;\n        entries = new Array(len * 2);\n        for (var i = 0; i < len; ++i) {\n            var key = keys[i];\n            entries[i] = obj[key];\n            entries[i + len] = key;\n        }\n    }\n    this.constructor$(entries);\n    this._isMap = isMap;\n    this._init$(undefined, isMap ? -6 : -3);\n}\nutil.inherits(PropertiesPromiseArray, PromiseArray);\n\nPropertiesPromiseArray.prototype._init = function () {};\n\nPropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        var val;\n        if (this._isMap) {\n            val = entriesToMap(this._values);\n        } else {\n            val = {};\n            var keyOffset = this.length();\n            for (var i = 0, len = this.length(); i < len; ++i) {\n                val[this._values[i + keyOffset]] = this._values[i];\n            }\n        }\n        this._resolve(val);\n        return true;\n    }\n    return false;\n};\n\nPropertiesPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nPropertiesPromiseArray.prototype.getActualLength = function (len) {\n    return len >> 1;\n};\n\nfunction props(promises) {\n    var ret;\n    var castValue = tryConvertToPromise(promises);\n\n    if (!isObject(castValue)) {\n        return apiRejection(\"cannot await properties of a non-object\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    } else if (castValue instanceof Promise) {\n        ret = castValue._then(\n            Promise.props, undefined, undefined, undefined, undefined);\n    } else {\n        ret = new PropertiesPromiseArray(castValue).promise();\n    }\n\n    if (castValue instanceof Promise) {\n        ret._propagateFrom(castValue, 2);\n    }\n    return ret;\n}\n\nPromise.prototype.props = function () {\n    return props(this);\n};\n\nPromise.props = function (promises) {\n    return props(promises);\n};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9wcm9wcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3Byb3BzLmpzPzRmYTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFxuICAgIFByb21pc2UsIFByb21pc2VBcnJheSwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0O1xudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcbnZhciBFczZNYXA7XG5pZiAodHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiKSBFczZNYXAgPSBNYXA7XG5cbnZhciBtYXBUb0VudHJpZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc2l6ZSA9IDA7XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RW50cnkodmFsdWUsIGtleSkge1xuICAgICAgICB0aGlzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB0aGlzW2luZGV4ICsgc2l6ZV0gPSBrZXk7XG4gICAgICAgIGluZGV4Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hcFRvRW50cmllcyhtYXApIHtcbiAgICAgICAgc2l6ZSA9IG1hcC5zaXplO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIHZhciByZXQgPSBuZXcgQXJyYXkobWFwLnNpemUgKiAyKTtcbiAgICAgICAgbWFwLmZvckVhY2goZXh0cmFjdEVudHJ5LCByZXQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59KSgpO1xuXG52YXIgZW50cmllc1RvTWFwID0gZnVuY3Rpb24oZW50cmllcykge1xuICAgIHZhciByZXQgPSBuZXcgRXM2TWFwKCk7XG4gICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoIC8gMiB8IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gZW50cmllc1tsZW5ndGggKyBpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gZW50cmllc1tpXTtcbiAgICAgICAgcmV0LnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIFByb3BlcnRpZXNQcm9taXNlQXJyYXkob2JqKSB7XG4gICAgdmFyIGlzTWFwID0gZmFsc2U7XG4gICAgdmFyIGVudHJpZXM7XG4gICAgaWYgKEVzNk1hcCAhPT0gdW5kZWZpbmVkICYmIG9iaiBpbnN0YW5jZW9mIEVzNk1hcCkge1xuICAgICAgICBlbnRyaWVzID0gbWFwVG9FbnRyaWVzKG9iaik7XG4gICAgICAgIGlzTWFwID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IGVzNS5rZXlzKG9iaik7XG4gICAgICAgIHZhciBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZW50cmllcyA9IG5ldyBBcnJheShsZW4gKiAyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBlbnRyaWVzW2ldID0gb2JqW2tleV07XG4gICAgICAgICAgICBlbnRyaWVzW2kgKyBsZW5dID0ga2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29uc3RydWN0b3IkKGVudHJpZXMpO1xuICAgIHRoaXMuX2lzTWFwID0gaXNNYXA7XG4gICAgdGhpcy5faW5pdCQodW5kZWZpbmVkLCBpc01hcCA/IC02IDogLTMpO1xufVxudXRpbC5pbmhlcml0cyhQcm9wZXJ0aWVzUHJvbWlzZUFycmF5LCBQcm9taXNlQXJyYXkpO1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5Qcm9wZXJ0aWVzUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZUZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgdmFyIHRvdGFsUmVzb2x2ZWQgPSArK3RoaXMuX3RvdGFsUmVzb2x2ZWQ7XG4gICAgaWYgKHRvdGFsUmVzb2x2ZWQgPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWw7XG4gICAgICAgIGlmICh0aGlzLl9pc01hcCkge1xuICAgICAgICAgICAgdmFsID0gZW50cmllc1RvTWFwKHRoaXMuX3ZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSB7fTtcbiAgICAgICAgICAgIHZhciBrZXlPZmZzZXQgPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoKCk7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhbFt0aGlzLl92YWx1ZXNbaSArIGtleU9mZnNldF1dID0gdGhpcy5fdmFsdWVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc29sdmUodmFsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblByb3BlcnRpZXNQcm9taXNlQXJyYXkucHJvdG90eXBlLnNob3VsZENvcHlWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuUHJvcGVydGllc1Byb21pc2VBcnJheS5wcm90b3R5cGUuZ2V0QWN0dWFsTGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgIHJldHVybiBsZW4gPj4gMTtcbn07XG5cbmZ1bmN0aW9uIHByb3BzKHByb21pc2VzKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgY2FzdFZhbHVlID0gdHJ5Q29udmVydFRvUHJvbWlzZShwcm9taXNlcyk7XG5cbiAgICBpZiAoIWlzT2JqZWN0KGNhc3RWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImNhbm5vdCBhd2FpdCBwcm9wZXJ0aWVzIG9mIGEgbm9uLW9iamVjdFxcdTAwMGFcXHUwMDBhICAgIFNlZSBodHRwOi8vZ29vLmdsL01xckZtWFxcdTAwMGFcIik7XG4gICAgfSBlbHNlIGlmIChjYXN0VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldCA9IGNhc3RWYWx1ZS5fdGhlbihcbiAgICAgICAgICAgIFByb21pc2UucHJvcHMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb3BlcnRpZXNQcm9taXNlQXJyYXkoY2FzdFZhbHVlKS5wcm9taXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKGNhc3RWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0Ll9wcm9wYWdhdGVGcm9tKGNhc3RWYWx1ZSwgMik7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblByb21pc2UucHJvdG90eXBlLnByb3BzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9wcyh0aGlzKTtcbn07XG5cblByb21pc2UucHJvcHMgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gcHJvcHMocHJvbWlzZXMpO1xufTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/props.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/queue.js":
/*!***************************************************!*\
  !*** ./node_modules/bluebird/js/release/queue.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\n    for (var j = 0; j < len; ++j) {\n        dst[j + dstIndex] = src[j + srcIndex];\n        src[j + srcIndex] = void 0;\n    }\n}\n\nfunction Queue(capacity) {\n    this._capacity = capacity;\n    this._length = 0;\n    this._front = 0;\n}\n\nQueue.prototype._willBeOverCapacity = function (size) {\n    return this._capacity < size;\n};\n\nQueue.prototype._pushOne = function (arg) {\n    var length = this.length();\n    this._checkCapacity(length + 1);\n    var i = (this._front + length) & (this._capacity - 1);\n    this[i] = arg;\n    this._length = length + 1;\n};\n\nQueue.prototype.push = function (fn, receiver, arg) {\n    var length = this.length() + 3;\n    if (this._willBeOverCapacity(length)) {\n        this._pushOne(fn);\n        this._pushOne(receiver);\n        this._pushOne(arg);\n        return;\n    }\n    var j = this._front + length - 3;\n    this._checkCapacity(length);\n    var wrapMask = this._capacity - 1;\n    this[(j + 0) & wrapMask] = fn;\n    this[(j + 1) & wrapMask] = receiver;\n    this[(j + 2) & wrapMask] = arg;\n    this._length = length;\n};\n\nQueue.prototype.shift = function () {\n    var front = this._front,\n        ret = this[front];\n\n    this[front] = undefined;\n    this._front = (front + 1) & (this._capacity - 1);\n    this._length--;\n    return ret;\n};\n\nQueue.prototype.length = function () {\n    return this._length;\n};\n\nQueue.prototype._checkCapacity = function (size) {\n    if (this._capacity < size) {\n        this._resizeTo(this._capacity << 1);\n    }\n};\n\nQueue.prototype._resizeTo = function (capacity) {\n    var oldCapacity = this._capacity;\n    this._capacity = capacity;\n    var front = this._front;\n    var length = this._length;\n    var moveItemsCount = (front + length) & (oldCapacity - 1);\n    arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n};\n\nmodule.exports = Queue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9xdWV1ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3F1ZXVlLmpzP2IzZTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBhcnJheU1vdmUoc3JjLCBzcmNJbmRleCwgZHN0LCBkc3RJbmRleCwgbGVuKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47ICsraikge1xuICAgICAgICBkc3RbaiArIGRzdEluZGV4XSA9IHNyY1tqICsgc3JjSW5kZXhdO1xuICAgICAgICBzcmNbaiArIHNyY0luZGV4XSA9IHZvaWQgMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFF1ZXVlKGNhcGFjaXR5KSB7XG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX2Zyb250ID0gMDtcbn1cblxuUXVldWUucHJvdG90eXBlLl93aWxsQmVPdmVyQ2FwYWNpdHkgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLl9jYXBhY2l0eSA8IHNpemU7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX3B1c2hPbmUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGggKyAxKTtcbiAgICB2YXIgaSA9ICh0aGlzLl9mcm9udCArIGxlbmd0aCkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzW2ldID0gYXJnO1xuICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aCArIDE7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChmbiwgcmVjZWl2ZXIsIGFyZykge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpICsgMztcbiAgICBpZiAodGhpcy5fd2lsbEJlT3ZlckNhcGFjaXR5KGxlbmd0aCkpIHtcbiAgICAgICAgdGhpcy5fcHVzaE9uZShmbik7XG4gICAgICAgIHRoaXMuX3B1c2hPbmUocmVjZWl2ZXIpO1xuICAgICAgICB0aGlzLl9wdXNoT25lKGFyZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGogPSB0aGlzLl9mcm9udCArIGxlbmd0aCAtIDM7XG4gICAgdGhpcy5fY2hlY2tDYXBhY2l0eShsZW5ndGgpO1xuICAgIHZhciB3cmFwTWFzayA9IHRoaXMuX2NhcGFjaXR5IC0gMTtcbiAgICB0aGlzWyhqICsgMCkgJiB3cmFwTWFza10gPSBmbjtcbiAgICB0aGlzWyhqICsgMSkgJiB3cmFwTWFza10gPSByZWNlaXZlcjtcbiAgICB0aGlzWyhqICsgMikgJiB3cmFwTWFza10gPSBhcmc7XG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250LFxuICAgICAgICByZXQgPSB0aGlzW2Zyb250XTtcblxuICAgIHRoaXNbZnJvbnRdID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Zyb250ID0gKGZyb250ICsgMSkgJiAodGhpcy5fY2FwYWNpdHkgLSAxKTtcbiAgICB0aGlzLl9sZW5ndGgtLTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUXVldWUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9jaGVja0NhcGFjaXR5ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICBpZiAodGhpcy5fY2FwYWNpdHkgPCBzaXplKSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVRvKHRoaXMuX2NhcGFjaXR5IDw8IDEpO1xuICAgIH1cbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fcmVzaXplVG8gPSBmdW5jdGlvbiAoY2FwYWNpdHkpIHtcbiAgICB2YXIgb2xkQ2FwYWNpdHkgPSB0aGlzLl9jYXBhY2l0eTtcbiAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgIHZhciBmcm9udCA9IHRoaXMuX2Zyb250O1xuICAgIHZhciBsZW5ndGggPSB0aGlzLl9sZW5ndGg7XG4gICAgdmFyIG1vdmVJdGVtc0NvdW50ID0gKGZyb250ICsgbGVuZ3RoKSAmIChvbGRDYXBhY2l0eSAtIDEpO1xuICAgIGFycmF5TW92ZSh0aGlzLCAwLCB0aGlzLCBvbGRDYXBhY2l0eSwgbW92ZUl0ZW1zQ291bnQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/queue.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/race.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/release/race.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(\n    Promise, INTERNAL, tryConvertToPromise, apiRejection) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\n\nvar raceLater = function (promise) {\n    return promise.then(function(array) {\n        return race(array, promise);\n    });\n};\n\nfunction race(promises, parent) {\n    var maybePromise = tryConvertToPromise(promises);\n\n    if (maybePromise instanceof Promise) {\n        return raceLater(maybePromise);\n    } else {\n        promises = util.asArray(promises);\n        if (promises === null)\n            return apiRejection(\"expecting an array or an iterable object but got \" + util.classString(promises));\n    }\n\n    var ret = new Promise(INTERNAL);\n    if (parent !== undefined) {\n        ret._propagateFrom(parent, 3);\n    }\n    var fulfill = ret._fulfill;\n    var reject = ret._reject;\n    for (var i = 0, len = promises.length; i < len; ++i) {\n        var val = promises[i];\n\n        if (val === undefined && !(i in promises)) {\n            continue;\n        }\n\n        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n    }\n    return ret;\n}\n\nPromise.race = function (promises) {\n    return race(promises, undefined);\n};\n\nPromise.prototype.race = function () {\n    return race(this, undefined);\n};\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9yYWNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvcmFjZS5qcz84Yjc2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihcbiAgICBQcm9taXNlLCBJTlRFUk5BTCwgdHJ5Q29udmVydFRvUHJvbWlzZSwgYXBpUmVqZWN0aW9uKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciByYWNlTGF0ZXIgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHJhY2UoYXJyYXksIHByb21pc2UpO1xuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gcmFjZShwcm9taXNlcywgcGFyZW50KSB7XG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UocHJvbWlzZXMpO1xuXG4gICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHJhY2VMYXRlcihtYXliZVByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VzID0gdXRpbC5hc0FycmF5KHByb21pc2VzKTtcbiAgICAgICAgaWYgKHByb21pc2VzID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGFwaVJlamVjdGlvbihcImV4cGVjdGluZyBhbiBhcnJheSBvciBhbiBpdGVyYWJsZSBvYmplY3QgYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcocHJvbWlzZXMpKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgIGlmIChwYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXQuX3Byb3BhZ2F0ZUZyb20ocGFyZW50LCAzKTtcbiAgICB9XG4gICAgdmFyIGZ1bGZpbGwgPSByZXQuX2Z1bGZpbGw7XG4gICAgdmFyIHJlamVjdCA9IHJldC5fcmVqZWN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9taXNlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB2YXIgdmFsID0gcHJvbWlzZXNbaV07XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkICYmICEoaSBpbiBwcm9taXNlcykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgUHJvbWlzZS5jYXN0KHZhbCkuX3RoZW4oZnVsZmlsbCwgcmVqZWN0LCB1bmRlZmluZWQsIHJldCwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cblByb21pc2UucmFjZSA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgIHJldHVybiByYWNlKHByb21pc2VzLCB1bmRlZmluZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmFjZSh0aGlzLCB1bmRlZmluZWQpO1xufTtcblxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/race.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/reduce.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/reduce.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL,\n                          debug) {\nvar getDomain = Promise._getDomain;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar tryCatch = util.tryCatch;\n\nfunction ReductionPromiseArray(promises, fn, initialValue, _each) {\n    this.constructor$(promises);\n    var domain = getDomain();\n    this._fn = domain === null ? fn : util.domainBind(domain, fn);\n    if (initialValue !== undefined) {\n        initialValue = Promise.resolve(initialValue);\n        initialValue._attachCancellationCallback(this);\n    }\n    this._initialValue = initialValue;\n    this._currentCancellable = null;\n    if(_each === INTERNAL) {\n        this._eachValues = Array(this._length);\n    } else if (_each === 0) {\n        this._eachValues = null;\n    } else {\n        this._eachValues = undefined;\n    }\n    this._promise._captureStackTrace();\n    this._init$(undefined, -5);\n}\nutil.inherits(ReductionPromiseArray, PromiseArray);\n\nReductionPromiseArray.prototype._gotAccum = function(accum) {\n    if (this._eachValues !== undefined && \n        this._eachValues !== null && \n        accum !== INTERNAL) {\n        this._eachValues.push(accum);\n    }\n};\n\nReductionPromiseArray.prototype._eachComplete = function(value) {\n    if (this._eachValues !== null) {\n        this._eachValues.push(value);\n    }\n    return this._eachValues;\n};\n\nReductionPromiseArray.prototype._init = function() {};\n\nReductionPromiseArray.prototype._resolveEmptyArray = function() {\n    this._resolve(this._eachValues !== undefined ? this._eachValues\n                                                 : this._initialValue);\n};\n\nReductionPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nReductionPromiseArray.prototype._resolve = function(value) {\n    this._promise._resolveCallback(value);\n    this._values = null;\n};\n\nReductionPromiseArray.prototype._resultCancelled = function(sender) {\n    if (sender === this._initialValue) return this._cancel();\n    if (this._isResolved()) return;\n    this._resultCancelled$();\n    if (this._currentCancellable instanceof Promise) {\n        this._currentCancellable.cancel();\n    }\n    if (this._initialValue instanceof Promise) {\n        this._initialValue.cancel();\n    }\n};\n\nReductionPromiseArray.prototype._iterate = function (values) {\n    this._values = values;\n    var value;\n    var i;\n    var length = values.length;\n    if (this._initialValue !== undefined) {\n        value = this._initialValue;\n        i = 0;\n    } else {\n        value = Promise.resolve(values[0]);\n        i = 1;\n    }\n\n    this._currentCancellable = value;\n\n    if (!value.isRejected()) {\n        for (; i < length; ++i) {\n            var ctx = {\n                accum: null,\n                value: values[i],\n                index: i,\n                length: length,\n                array: this\n            };\n            value = value._then(gotAccum, undefined, undefined, ctx, undefined);\n        }\n    }\n\n    if (this._eachValues !== undefined) {\n        value = value\n            ._then(this._eachComplete, undefined, undefined, this, undefined);\n    }\n    value._then(completed, completed, undefined, value, this);\n};\n\nPromise.prototype.reduce = function (fn, initialValue) {\n    return reduce(this, fn, initialValue, null);\n};\n\nPromise.reduce = function (promises, fn, initialValue, _each) {\n    return reduce(promises, fn, initialValue, _each);\n};\n\nfunction completed(valueOrReason, array) {\n    if (this.isFulfilled()) {\n        array._resolve(valueOrReason);\n    } else {\n        array._reject(valueOrReason);\n    }\n}\n\nfunction reduce(promises, fn, initialValue, _each) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"expecting a function but got \" + util.classString(fn));\n    }\n    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n    return array.promise();\n}\n\nfunction gotAccum(accum) {\n    this.accum = accum;\n    this.array._gotAccum(accum);\n    var value = tryConvertToPromise(this.value, this.array._promise);\n    if (value instanceof Promise) {\n        this.array._currentCancellable = value;\n        return value._then(gotValue, undefined, undefined, this, undefined);\n    } else {\n        return gotValue.call(this, value);\n    }\n}\n\nfunction gotValue(value) {\n    var array = this.array;\n    var promise = array._promise;\n    var fn = tryCatch(array._fn);\n    promise._pushContext();\n    var ret;\n    if (array._eachValues !== undefined) {\n        ret = fn.call(promise._boundValue(), value, this.index, this.length);\n    } else {\n        ret = fn.call(promise._boundValue(),\n                              this.accum, value, this.index, this.length);\n    }\n    if (ret instanceof Promise) {\n        array._currentCancellable = ret;\n    }\n    var promiseCreated = promise._popContext();\n    debug.checkForgottenReturns(\n        ret,\n        promiseCreated,\n        array._eachValues !== undefined ? \"Promise.each\" : \"Promise.reduce\",\n        promise\n    );\n    return ret;\n}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9yZWR1Y2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9yZWR1Y2UuanM/MTYxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZUFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlSZWplY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIElOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1Zykge1xudmFyIGdldERvbWFpbiA9IFByb21pc2UuX2dldERvbWFpbjtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciB0cnlDYXRjaCA9IHV0aWwudHJ5Q2F0Y2g7XG5cbmZ1bmN0aW9uIFJlZHVjdGlvblByb21pc2VBcnJheShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yJChwcm9taXNlcyk7XG4gICAgdmFyIGRvbWFpbiA9IGdldERvbWFpbigpO1xuICAgIHRoaXMuX2ZuID0gZG9tYWluID09PSBudWxsID8gZm4gOiB1dGlsLmRvbWFpbkJpbmQoZG9tYWluLCBmbik7XG4gICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IFByb21pc2UucmVzb2x2ZShpbml0aWFsVmFsdWUpO1xuICAgICAgICBpbml0aWFsVmFsdWUuX2F0dGFjaENhbmNlbGxhdGlvbkNhbGxiYWNrKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlID0gbnVsbDtcbiAgICBpZihfZWFjaCA9PT0gSU5URVJOQUwpIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcyA9IEFycmF5KHRoaXMuX2xlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChfZWFjaCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLl9wcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTUpO1xufVxudXRpbC5pbmhlcml0cyhSZWR1Y3Rpb25Qcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX2dvdEFjY3VtID0gZnVuY3Rpb24oYWNjdW0pIHtcbiAgICBpZiAodGhpcy5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkICYmIFxuICAgICAgICB0aGlzLl9lYWNoVmFsdWVzICE9PSBudWxsICYmIFxuICAgICAgICBhY2N1bSAhPT0gSU5URVJOQUwpIHtcbiAgICAgICAgdGhpcy5fZWFjaFZhbHVlcy5wdXNoKGFjY3VtKTtcbiAgICB9XG59O1xuXG5SZWR1Y3Rpb25Qcm9taXNlQXJyYXkucHJvdG90eXBlLl9lYWNoQ29tcGxldGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9lYWNoVmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2VhY2hWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lYWNoVmFsdWVzO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge307XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmVFbXB0eUFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQgPyB0aGlzLl9lYWNoVmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9pbml0aWFsVmFsdWUpO1xufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5zaG91bGRDb3B5VmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuX3Byb21pc2UuX3Jlc29sdmVDYWxsYmFjayh2YWx1ZSk7XG4gICAgdGhpcy5fdmFsdWVzID0gbnVsbDtcbn07XG5cblJlZHVjdGlvblByb21pc2VBcnJheS5wcm90b3R5cGUuX3Jlc3VsdENhbmNlbGxlZCA9IGZ1bmN0aW9uKHNlbmRlcikge1xuICAgIGlmIChzZW5kZXIgPT09IHRoaXMuX2luaXRpYWxWYWx1ZSkgcmV0dXJuIHRoaXMuX2NhbmNlbCgpO1xuICAgIGlmICh0aGlzLl9pc1Jlc29sdmVkKCkpIHJldHVybjtcbiAgICB0aGlzLl9yZXN1bHRDYW5jZWxsZWQkKCk7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRDYW5jZWxsYWJsZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlLmNhbmNlbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5faW5pdGlhbFZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0aGlzLl9pbml0aWFsVmFsdWUuY2FuY2VsKCk7XG4gICAgfVxufTtcblxuUmVkdWN0aW9uUHJvbWlzZUFycmF5LnByb3RvdHlwZS5faXRlcmF0ZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICB0aGlzLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuICAgIGlmICh0aGlzLl9pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2luaXRpYWxWYWx1ZTtcbiAgICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBQcm9taXNlLnJlc29sdmUodmFsdWVzWzBdKTtcbiAgICAgICAgaSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudENhbmNlbGxhYmxlID0gdmFsdWU7XG5cbiAgICBpZiAoIXZhbHVlLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0ge1xuICAgICAgICAgICAgICAgIGFjY3VtOiBudWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNbaV0sXG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgICAgICAgYXJyYXk6IHRoaXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLl90aGVuKGdvdEFjY3VtLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY3R4LCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VhY2hWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgICAuX3RoZW4odGhpcy5fZWFjaENvbXBsZXRlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcywgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdmFsdWUuX3RoZW4oY29tcGxldGVkLCBjb21wbGV0ZWQsIHVuZGVmaW5lZCwgdmFsdWUsIHRoaXMpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsVmFsdWUpIHtcbiAgICByZXR1cm4gcmVkdWNlKHRoaXMsIGZuLCBpbml0aWFsVmFsdWUsIG51bGwpO1xufTtcblxuUHJvbWlzZS5yZWR1Y2UgPSBmdW5jdGlvbiAocHJvbWlzZXMsIGZuLCBpbml0aWFsVmFsdWUsIF9lYWNoKSB7XG4gICAgcmV0dXJuIHJlZHVjZShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpO1xufTtcblxuZnVuY3Rpb24gY29tcGxldGVkKHZhbHVlT3JSZWFzb24sIGFycmF5KSB7XG4gICAgaWYgKHRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgICBhcnJheS5fcmVzb2x2ZSh2YWx1ZU9yUmVhc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheS5fcmVqZWN0KHZhbHVlT3JSZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlKHByb21pc2VzLCBmbiwgaW5pdGlhbFZhbHVlLCBfZWFjaCkge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gYXBpUmVqZWN0aW9uKFwiZXhwZWN0aW5nIGEgZnVuY3Rpb24gYnV0IGdvdCBcIiArIHV0aWwuY2xhc3NTdHJpbmcoZm4pKTtcbiAgICB9XG4gICAgdmFyIGFycmF5ID0gbmV3IFJlZHVjdGlvblByb21pc2VBcnJheShwcm9taXNlcywgZm4sIGluaXRpYWxWYWx1ZSwgX2VhY2gpO1xuICAgIHJldHVybiBhcnJheS5wcm9taXNlKCk7XG59XG5cbmZ1bmN0aW9uIGdvdEFjY3VtKGFjY3VtKSB7XG4gICAgdGhpcy5hY2N1bSA9IGFjY3VtO1xuICAgIHRoaXMuYXJyYXkuX2dvdEFjY3VtKGFjY3VtKTtcbiAgICB2YXIgdmFsdWUgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoaXMudmFsdWUsIHRoaXMuYXJyYXkuX3Byb21pc2UpO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5hcnJheS5fY3VycmVudENhbmNlbGxhYmxlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fdGhlbihnb3RWYWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdvdFZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ290VmFsdWUodmFsdWUpIHtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgIHZhciBwcm9taXNlID0gYXJyYXkuX3Byb21pc2U7XG4gICAgdmFyIGZuID0gdHJ5Q2F0Y2goYXJyYXkuX2ZuKTtcbiAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuICAgIHZhciByZXQ7XG4gICAgaWYgKGFycmF5Ll9lYWNoVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0ID0gZm4uY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksIHZhbHVlLCB0aGlzLmluZGV4LCB0aGlzLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gZm4uY2FsbChwcm9taXNlLl9ib3VuZFZhbHVlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY3VtLCB2YWx1ZSwgdGhpcy5pbmRleCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBhcnJheS5fY3VycmVudENhbmNlbGxhYmxlID0gcmV0O1xuICAgIH1cbiAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICByZXQsXG4gICAgICAgIHByb21pc2VDcmVhdGVkLFxuICAgICAgICBhcnJheS5fZWFjaFZhbHVlcyAhPT0gdW5kZWZpbmVkID8gXCJQcm9taXNlLmVhY2hcIiA6IFwiUHJvbWlzZS5yZWR1Y2VcIixcbiAgICAgICAgcHJvbWlzZVxuICAgICk7XG4gICAgcmV0dXJuIHJldDtcbn1cbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/reduce.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/schedule.js":
/*!******************************************************!*\
  !*** ./node_modules/bluebird/js/release/schedule.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar schedule;\nvar noAsyncScheduler = function() {\n    throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n};\nvar NativePromise = util.getNativePromise();\nif (util.isNode && typeof MutationObserver === \"undefined\") {\n    var GlobalSetImmediate = global.setImmediate;\n    var ProcessNextTick = process.nextTick;\n    schedule = util.isRecentNode\n                ? function(fn) { GlobalSetImmediate.call(global, fn); }\n                : function(fn) { ProcessNextTick.call(process, fn); };\n} else if (typeof NativePromise === \"function\" &&\n           typeof NativePromise.resolve === \"function\") {\n    var nativePromise = NativePromise.resolve();\n    schedule = function(fn) {\n        nativePromise.then(fn);\n    };\n} else if ((typeof MutationObserver !== \"undefined\") &&\n          !(typeof window !== \"undefined\" &&\n            window.navigator &&\n            (window.navigator.standalone || window.cordova))) {\n    schedule = (function() {\n        var div = document.createElement(\"div\");\n        var opts = {attributes: true};\n        var toggleScheduled = false;\n        var div2 = document.createElement(\"div\");\n        var o2 = new MutationObserver(function() {\n            div.classList.toggle(\"foo\");\n            toggleScheduled = false;\n        });\n        o2.observe(div2, opts);\n\n        var scheduleToggle = function() {\n            if (toggleScheduled) return;\n            toggleScheduled = true;\n            div2.classList.toggle(\"foo\");\n        };\n\n        return function schedule(fn) {\n            var o = new MutationObserver(function() {\n                o.disconnect();\n                fn();\n            });\n            o.observe(div, opts);\n            scheduleToggle();\n        };\n    })();\n} else if (typeof setImmediate !== \"undefined\") {\n    schedule = function (fn) {\n        setImmediate(fn);\n    };\n} else if (typeof setTimeout !== \"undefined\") {\n    schedule = function (fn) {\n        setTimeout(fn, 0);\n    };\n} else {\n    schedule = noAsyncScheduler;\n}\nmodule.exports = schedule;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zY2hlZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3NjaGVkdWxlLmpzP2Y1MTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgc2NoZWR1bGU7XG52YXIgbm9Bc3luY1NjaGVkdWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFzeW5jIHNjaGVkdWxlciBhdmFpbGFibGVcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xufTtcbnZhciBOYXRpdmVQcm9taXNlID0gdXRpbC5nZXROYXRpdmVQcm9taXNlKCk7XG5pZiAodXRpbC5pc05vZGUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgR2xvYmFsU2V0SW1tZWRpYXRlID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbiAgICB2YXIgUHJvY2Vzc05leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICBzY2hlZHVsZSA9IHV0aWwuaXNSZWNlbnROb2RlXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbihmbikgeyBHbG9iYWxTZXRJbW1lZGlhdGUuY2FsbChnbG9iYWwsIGZuKTsgfVxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24oZm4pIHsgUHJvY2Vzc05leHRUaWNrLmNhbGwocHJvY2VzcywgZm4pOyB9O1xufSBlbHNlIGlmICh0eXBlb2YgTmF0aXZlUHJvbWlzZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgIHR5cGVvZiBOYXRpdmVQcm9taXNlLnJlc29sdmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBuYXRpdmVQcm9taXNlID0gTmF0aXZlUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbihmbikge1xuICAgICAgICBuYXRpdmVQcm9taXNlLnRoZW4oZm4pO1xuICAgIH07XG59IGVsc2UgaWYgKCh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gXCJ1bmRlZmluZWRcIikgJiZcbiAgICAgICAgICAhKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IgJiZcbiAgICAgICAgICAgICh3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmUgfHwgd2luZG93LmNvcmRvdmEpKSkge1xuICAgIHNjaGVkdWxlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdmFyIG9wdHMgPSB7YXR0cmlidXRlczogdHJ1ZX07XG4gICAgICAgIHZhciB0b2dnbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRpdjIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgbzIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZm9vXCIpO1xuICAgICAgICAgICAgdG9nZ2xlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBvMi5vYnNlcnZlKGRpdjIsIG9wdHMpO1xuXG4gICAgICAgIHZhciBzY2hlZHVsZVRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRvZ2dsZVNjaGVkdWxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdG9nZ2xlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRpdjIuY2xhc3NMaXN0LnRvZ2dsZShcImZvb1wiKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2NoZWR1bGUoZm4pIHtcbiAgICAgICAgICAgIHZhciBvID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgby5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgby5vYnNlcnZlKGRpdiwgb3B0cyk7XG4gICAgICAgICAgICBzY2hlZHVsZVRvZ2dsZSgpO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBzY2hlZHVsZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIH07XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgc2NoZWR1bGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgc2NoZWR1bGUgPSBub0FzeW5jU2NoZWR1bGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBzY2hlZHVsZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/schedule.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/settle.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/settle.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\n    function(Promise, PromiseArray, debug) {\nvar PromiseInspection = Promise.PromiseInspection;\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\n\nfunction SettledPromiseArray(values) {\n    this.constructor$(values);\n}\nutil.inherits(SettledPromiseArray, PromiseArray);\n\nSettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\n    this._values[index] = inspection;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n        return true;\n    }\n    return false;\n};\n\nSettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 33554432;\n    ret._settledValueField = value;\n    return this._promiseResolved(index, ret);\n};\nSettledPromiseArray.prototype._promiseRejected = function (reason, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 16777216;\n    ret._settledValueField = reason;\n    return this._promiseResolved(index, ret);\n};\n\nPromise.settle = function (promises) {\n    debug.deprecated(\".settle()\", \".reflect()\");\n    return new SettledPromiseArray(promises).promise();\n};\n\nPromise.prototype.settle = function () {\n    return Promise.settle(this);\n};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zZXR0bGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zZXR0bGUuanM/MjZlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID1cbiAgICBmdW5jdGlvbihQcm9taXNlLCBQcm9taXNlQXJyYXksIGRlYnVnKSB7XG52YXIgUHJvbWlzZUluc3BlY3Rpb24gPSBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBTZXR0bGVkUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG59XG51dGlsLmluaGVyaXRzKFNldHRsZWRQcm9taXNlQXJyYXksIFByb21pc2VBcnJheSk7XG5cblNldHRsZWRQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlUmVzb2x2ZWQgPSBmdW5jdGlvbiAoaW5kZXgsIGluc3BlY3Rpb24pIHtcbiAgICB0aGlzLl92YWx1ZXNbaW5kZXhdID0gaW5zcGVjdGlvbjtcbiAgICB2YXIgdG90YWxSZXNvbHZlZCA9ICsrdGhpcy5fdG90YWxSZXNvbHZlZDtcbiAgICBpZiAodG90YWxSZXNvbHZlZCA+PSB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuU2V0dGxlZFByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBQcm9taXNlSW5zcGVjdGlvbigpO1xuICAgIHJldC5fYml0RmllbGQgPSAzMzU1NDQzMjtcbiAgICByZXQuX3NldHRsZWRWYWx1ZUZpZWxkID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbn07XG5TZXR0bGVkUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbiwgaW5kZXgpIHtcbiAgICB2YXIgcmV0ID0gbmV3IFByb21pc2VJbnNwZWN0aW9uKCk7XG4gICAgcmV0Ll9iaXRGaWVsZCA9IDE2Nzc3MjE2O1xuICAgIHJldC5fc2V0dGxlZFZhbHVlRmllbGQgPSByZWFzb247XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VSZXNvbHZlZChpbmRleCwgcmV0KTtcbn07XG5cblByb21pc2Uuc2V0dGxlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgZGVidWcuZGVwcmVjYXRlZChcIi5zZXR0bGUoKVwiLCBcIi5yZWZsZWN0KClcIik7XG4gICAgcmV0dXJuIG5ldyBTZXR0bGVkUHJvbWlzZUFycmF5KHByb21pc2VzKS5wcm9taXNlKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5zZXR0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFByb21pc2Uuc2V0dGxlKHRoaXMpO1xufTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/settle.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/some.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/release/some.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports =\nfunction(Promise, PromiseArray, apiRejection) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar RangeError = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\").RangeError;\nvar AggregateError = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\").AggregateError;\nvar isArray = util.isArray;\nvar CANCELLATION = {};\n\n\nfunction SomePromiseArray(values) {\n    this.constructor$(values);\n    this._howMany = 0;\n    this._unwrap = false;\n    this._initialized = false;\n}\nutil.inherits(SomePromiseArray, PromiseArray);\n\nSomePromiseArray.prototype._init = function () {\n    if (!this._initialized) {\n        return;\n    }\n    if (this._howMany === 0) {\n        this._resolve([]);\n        return;\n    }\n    this._init$(undefined, -5);\n    var isArrayResolved = isArray(this._values);\n    if (!this._isResolved() &&\n        isArrayResolved &&\n        this._howMany > this._canPossiblyFulfill()) {\n        this._reject(this._getRangeError(this.length()));\n    }\n};\n\nSomePromiseArray.prototype.init = function () {\n    this._initialized = true;\n    this._init();\n};\n\nSomePromiseArray.prototype.setUnwrap = function () {\n    this._unwrap = true;\n};\n\nSomePromiseArray.prototype.howMany = function () {\n    return this._howMany;\n};\n\nSomePromiseArray.prototype.setHowMany = function (count) {\n    this._howMany = count;\n};\n\nSomePromiseArray.prototype._promiseFulfilled = function (value) {\n    this._addFulfilled(value);\n    if (this._fulfilled() === this.howMany()) {\n        this._values.length = this.howMany();\n        if (this.howMany() === 1 && this._unwrap) {\n            this._resolve(this._values[0]);\n        } else {\n            this._resolve(this._values);\n        }\n        return true;\n    }\n    return false;\n\n};\nSomePromiseArray.prototype._promiseRejected = function (reason) {\n    this._addRejected(reason);\n    return this._checkOutcome();\n};\n\nSomePromiseArray.prototype._promiseCancelled = function () {\n    if (this._values instanceof Promise || this._values == null) {\n        return this._cancel();\n    }\n    this._addRejected(CANCELLATION);\n    return this._checkOutcome();\n};\n\nSomePromiseArray.prototype._checkOutcome = function() {\n    if (this.howMany() > this._canPossiblyFulfill()) {\n        var e = new AggregateError();\n        for (var i = this.length(); i < this._values.length; ++i) {\n            if (this._values[i] !== CANCELLATION) {\n                e.push(this._values[i]);\n            }\n        }\n        if (e.length > 0) {\n            this._reject(e);\n        } else {\n            this._cancel();\n        }\n        return true;\n    }\n    return false;\n};\n\nSomePromiseArray.prototype._fulfilled = function () {\n    return this._totalResolved;\n};\n\nSomePromiseArray.prototype._rejected = function () {\n    return this._values.length - this.length();\n};\n\nSomePromiseArray.prototype._addRejected = function (reason) {\n    this._values.push(reason);\n};\n\nSomePromiseArray.prototype._addFulfilled = function (value) {\n    this._values[this._totalResolved++] = value;\n};\n\nSomePromiseArray.prototype._canPossiblyFulfill = function () {\n    return this.length() - this._rejected();\n};\n\nSomePromiseArray.prototype._getRangeError = function (count) {\n    var message = \"Input array must contain at least \" +\n            this._howMany + \" items but contains only \" + count + \" items\";\n    return new RangeError(message);\n};\n\nSomePromiseArray.prototype._resolveEmptyArray = function () {\n    this._reject(this._getRangeError(0));\n};\n\nfunction some(promises, howMany) {\n    if ((howMany | 0) !== howMany || howMany < 0) {\n        return apiRejection(\"expecting a positive integer\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(howMany);\n    ret.init();\n    return promise;\n}\n\nPromise.some = function (promises, howMany) {\n    return some(promises, howMany);\n};\n\nPromise.prototype.some = function (howMany) {\n    return some(this, howMany);\n};\n\nPromise._SomePromiseArray = SomePromiseArray;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zb21lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2Uvc29tZS5qcz8zMDUwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24oUHJvbWlzZSwgUHJvbWlzZUFycmF5LCBhcGlSZWplY3Rpb24pIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBSYW5nZUVycm9yID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpLlJhbmdlRXJyb3I7XG52YXIgQWdncmVnYXRlRXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvcnNcIikuQWdncmVnYXRlRXJyb3I7XG52YXIgaXNBcnJheSA9IHV0aWwuaXNBcnJheTtcbnZhciBDQU5DRUxMQVRJT04gPSB7fTtcblxuXG5mdW5jdGlvbiBTb21lUHJvbWlzZUFycmF5KHZhbHVlcykge1xuICAgIHRoaXMuY29uc3RydWN0b3IkKHZhbHVlcyk7XG4gICAgdGhpcy5faG93TWFueSA9IDA7XG4gICAgdGhpcy5fdW53cmFwID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn1cbnV0aWwuaW5oZXJpdHMoU29tZVByb21pc2VBcnJheSwgUHJvbWlzZUFycmF5KTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9ob3dNYW55ID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUoW10pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2luaXQkKHVuZGVmaW5lZCwgLTUpO1xuICAgIHZhciBpc0FycmF5UmVzb2x2ZWQgPSBpc0FycmF5KHRoaXMuX3ZhbHVlcyk7XG4gICAgaWYgKCF0aGlzLl9pc1Jlc29sdmVkKCkgJiZcbiAgICAgICAgaXNBcnJheVJlc29sdmVkICYmXG4gICAgICAgIHRoaXMuX2hvd01hbnkgPiB0aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSkge1xuICAgICAgICB0aGlzLl9yZWplY3QodGhpcy5fZ2V0UmFuZ2VFcnJvcih0aGlzLmxlbmd0aCgpKSk7XG4gICAgfVxufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5faW5pdCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuc2V0VW53cmFwID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Vud3JhcCA9IHRydWU7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5ob3dNYW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9ob3dNYW55O1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuc2V0SG93TWFueSA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIHRoaXMuX2hvd01hbnkgPSBjb3VudDtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9wcm9taXNlRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fYWRkRnVsZmlsbGVkKHZhbHVlKTtcbiAgICBpZiAodGhpcy5fZnVsZmlsbGVkKCkgPT09IHRoaXMuaG93TWFueSgpKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSB0aGlzLmhvd01hbnkoKTtcbiAgICAgICAgaWYgKHRoaXMuaG93TWFueSgpID09PSAxICYmIHRoaXMuX3Vud3JhcCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzLl92YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG5cbn07XG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcHJvbWlzZVJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX2FkZFJlamVjdGVkKHJlYXNvbik7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrT3V0Y29tZSgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX3Byb21pc2VDYW5jZWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ZhbHVlcyBpbnN0YW5jZW9mIFByb21pc2UgfHwgdGhpcy5fdmFsdWVzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbCgpO1xuICAgIH1cbiAgICB0aGlzLl9hZGRSZWplY3RlZChDQU5DRUxMQVRJT04pO1xuICAgIHJldHVybiB0aGlzLl9jaGVja091dGNvbWUoKTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9jaGVja091dGNvbWUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ob3dNYW55KCkgPiB0aGlzLl9jYW5Qb3NzaWJseUZ1bGZpbGwoKSkge1xuICAgICAgICB2YXIgZSA9IG5ldyBBZ2dyZWdhdGVFcnJvcigpO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGgoKTsgaSA8IHRoaXMuX3ZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlc1tpXSAhPT0gQ0FOQ0VMTEFUSU9OKSB7XG4gICAgICAgICAgICAgICAgZS5wdXNoKHRoaXMuX3ZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0KGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9mdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsUmVzb2x2ZWQ7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGggLSB0aGlzLmxlbmd0aCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2FkZFJlamVjdGVkID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRoaXMuX3ZhbHVlcy5wdXNoKHJlYXNvbik7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fYWRkRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5fdmFsdWVzW3RoaXMuX3RvdGFsUmVzb2x2ZWQrK10gPSB2YWx1ZTtcbn07XG5cblNvbWVQcm9taXNlQXJyYXkucHJvdG90eXBlLl9jYW5Qb3NzaWJseUZ1bGZpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgLSB0aGlzLl9yZWplY3RlZCgpO1xufTtcblxuU29tZVByb21pc2VBcnJheS5wcm90b3R5cGUuX2dldFJhbmdlRXJyb3IgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICB2YXIgbWVzc2FnZSA9IFwiSW5wdXQgYXJyYXkgbXVzdCBjb250YWluIGF0IGxlYXN0IFwiICtcbiAgICAgICAgICAgIHRoaXMuX2hvd01hbnkgKyBcIiBpdGVtcyBidXQgY29udGFpbnMgb25seSBcIiArIGNvdW50ICsgXCIgaXRlbXNcIjtcbiAgICByZXR1cm4gbmV3IFJhbmdlRXJyb3IobWVzc2FnZSk7XG59O1xuXG5Tb21lUHJvbWlzZUFycmF5LnByb3RvdHlwZS5fcmVzb2x2ZUVtcHR5QXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVqZWN0KHRoaXMuX2dldFJhbmdlRXJyb3IoMCkpO1xufTtcblxuZnVuY3Rpb24gc29tZShwcm9taXNlcywgaG93TWFueSkge1xuICAgIGlmICgoaG93TWFueSB8IDApICE9PSBob3dNYW55IHx8IGhvd01hbnkgPCAwKSB7XG4gICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBwb3NpdGl2ZSBpbnRlZ2VyXFx1MDAwYVxcdTAwMGEgICAgU2VlIGh0dHA6Ly9nb28uZ2wvTXFyRm1YXFx1MDAwYVwiKTtcbiAgICB9XG4gICAgdmFyIHJldCA9IG5ldyBTb21lUHJvbWlzZUFycmF5KHByb21pc2VzKTtcbiAgICB2YXIgcHJvbWlzZSA9IHJldC5wcm9taXNlKCk7XG4gICAgcmV0LnNldEhvd01hbnkoaG93TWFueSk7XG4gICAgcmV0LmluaXQoKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5zb21lID0gZnVuY3Rpb24gKHByb21pc2VzLCBob3dNYW55KSB7XG4gICAgcmV0dXJuIHNvbWUocHJvbWlzZXMsIGhvd01hbnkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChob3dNYW55KSB7XG4gICAgcmV0dXJuIHNvbWUodGhpcywgaG93TWFueSk7XG59O1xuXG5Qcm9taXNlLl9Tb21lUHJvbWlzZUFycmF5ID0gU29tZVByb21pc2VBcnJheTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/some.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/synchronous_inspection.js":
/*!********************************************************************!*\
  !*** ./node_modules/bluebird/js/release/synchronous_inspection.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise) {\nfunction PromiseInspection(promise) {\n    if (promise !== undefined) {\n        promise = promise._target();\n        this._bitField = promise._bitField;\n        this._settledValueField = promise._isFateSealed()\n            ? promise._settledValue() : undefined;\n    }\n    else {\n        this._bitField = 0;\n        this._settledValueField = undefined;\n    }\n}\n\nPromiseInspection.prototype._settledValue = function() {\n    return this._settledValueField;\n};\n\nvar value = PromiseInspection.prototype.value = function () {\n    if (!this.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    return this._settledValue();\n};\n\nvar reason = PromiseInspection.prototype.error =\nPromiseInspection.prototype.reason = function () {\n    if (!this.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/MqrFmX\\u000a\");\n    }\n    return this._settledValue();\n};\n\nvar isFulfilled = PromiseInspection.prototype.isFulfilled = function() {\n    return (this._bitField & 33554432) !== 0;\n};\n\nvar isRejected = PromiseInspection.prototype.isRejected = function () {\n    return (this._bitField & 16777216) !== 0;\n};\n\nvar isPending = PromiseInspection.prototype.isPending = function () {\n    return (this._bitField & 50397184) === 0;\n};\n\nvar isResolved = PromiseInspection.prototype.isResolved = function () {\n    return (this._bitField & 50331648) !== 0;\n};\n\nPromiseInspection.prototype.isCancelled = function() {\n    return (this._bitField & 8454144) !== 0;\n};\n\nPromise.prototype.__isCancelled = function() {\n    return (this._bitField & 65536) === 65536;\n};\n\nPromise.prototype._isCancelled = function() {\n    return this._target().__isCancelled();\n};\n\nPromise.prototype.isCancelled = function() {\n    return (this._target()._bitField & 8454144) !== 0;\n};\n\nPromise.prototype.isPending = function() {\n    return isPending.call(this._target());\n};\n\nPromise.prototype.isRejected = function() {\n    return isRejected.call(this._target());\n};\n\nPromise.prototype.isFulfilled = function() {\n    return isFulfilled.call(this._target());\n};\n\nPromise.prototype.isResolved = function() {\n    return isResolved.call(this._target());\n};\n\nPromise.prototype.value = function() {\n    return value.call(this._target());\n};\n\nPromise.prototype.reason = function() {\n    var target = this._target();\n    target._unsetRejectionIsUnhandled();\n    return reason.call(target);\n};\n\nPromise.prototype._value = function() {\n    return this._settledValue();\n};\n\nPromise.prototype._reason = function() {\n    this._unsetRejectionIsUnhandled();\n    return this._settledValue();\n};\n\nPromise.PromiseInspection = PromiseInspection;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS9zeW5jaHJvbm91c19pbnNwZWN0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2Uvc3luY2hyb25vdXNfaW5zcGVjdGlvbi5qcz8zOGIzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihQcm9taXNlKSB7XG5mdW5jdGlvbiBQcm9taXNlSW5zcGVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKHByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5fdGFyZ2V0KCk7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gcHJvbWlzZS5fYml0RmllbGQ7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkID0gcHJvbWlzZS5faXNGYXRlU2VhbGVkKClcbiAgICAgICAgICAgID8gcHJvbWlzZS5fc2V0dGxlZFZhbHVlKCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9iaXRGaWVsZCA9IDA7XG4gICAgICAgIHRoaXMuX3NldHRsZWRWYWx1ZUZpZWxkID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLl9zZXR0bGVkVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlRmllbGQ7XG59O1xuXG52YXIgdmFsdWUgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbm5vdCBnZXQgZnVsZmlsbG1lbnQgdmFsdWUgb2YgYSBub24tZnVsZmlsbGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG52YXIgcmVhc29uID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmVycm9yID1cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5yZWFzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2Fubm90IGdldCByZWplY3Rpb24gcmVhc29uIG9mIGEgbm9uLXJlamVjdGVkIHByb21pc2VcXHUwMDBhXFx1MDAwYSAgICBTZWUgaHR0cDovL2dvby5nbC9NcXJGbVhcXHUwMDBhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2V0dGxlZFZhbHVlKCk7XG59O1xuXG52YXIgaXNGdWxmaWxsZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMzM1NTQ0MzIpICE9PSAwO1xufTtcblxudmFyIGlzUmVqZWN0ZWQgPSBQcm9taXNlSW5zcGVjdGlvbi5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgMTY3NzcyMTYpICE9PSAwO1xufTtcblxudmFyIGlzUGVuZGluZyA9IFByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUwMzk3MTg0KSA9PT0gMDtcbn07XG5cbnZhciBpc1Jlc29sdmVkID0gUHJvbWlzZUluc3BlY3Rpb24ucHJvdG90eXBlLmlzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLl9iaXRGaWVsZCAmIDUwMzMxNjQ4KSAhPT0gMDtcbn07XG5cblByb21pc2VJbnNwZWN0aW9uLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiA4NDU0MTQ0KSAhPT0gMDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9faXNDYW5jZWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuX2JpdEZpZWxkICYgNjU1MzYpID09PSA2NTUzNjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXQoKS5fX2lzQ2FuY2VsbGVkKCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0NhbmNlbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fdGFyZ2V0KCkuX2JpdEZpZWxkICYgODQ1NDE0NCkgIT09IDA7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc1JlamVjdGVkLmNhbGwodGhpcy5fdGFyZ2V0KCkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1Jlc29sdmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzUmVzb2x2ZWQuY2FsbCh0aGlzLl90YXJnZXQoKSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZS5jYWxsKHRoaXMuX3RhcmdldCgpKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnJlYXNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQoKTtcbiAgICB0YXJnZXQuX3Vuc2V0UmVqZWN0aW9uSXNVbmhhbmRsZWQoKTtcbiAgICByZXR1cm4gcmVhc29uLmNhbGwodGFyZ2V0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl92YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zZXR0bGVkVmFsdWUoKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLl9yZWFzb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91bnNldFJlamVjdGlvbklzVW5oYW5kbGVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRsZWRWYWx1ZSgpO1xufTtcblxuUHJvbWlzZS5Qcm9taXNlSW5zcGVjdGlvbiA9IFByb21pc2VJbnNwZWN0aW9uO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/synchronous_inspection.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/thenables.js":
/*!*******************************************************!*\
  !*** ./node_modules/bluebird/js/release/thenables.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar errorObj = util.errorObj;\nvar isObject = util.isObject;\n\nfunction tryConvertToPromise(obj, context) {\n    if (isObject(obj)) {\n        if (obj instanceof Promise) return obj;\n        var then = getThen(obj);\n        if (then === errorObj) {\n            if (context) context._pushContext();\n            var ret = Promise.reject(then.e);\n            if (context) context._popContext();\n            return ret;\n        } else if (typeof then === \"function\") {\n            if (isAnyBluebirdPromise(obj)) {\n                var ret = new Promise(INTERNAL);\n                obj._then(\n                    ret._fulfill,\n                    ret._reject,\n                    undefined,\n                    ret,\n                    null\n                );\n                return ret;\n            }\n            return doThenable(obj, then, context);\n        }\n    }\n    return obj;\n}\n\nfunction doGetThen(obj) {\n    return obj.then;\n}\n\nfunction getThen(obj) {\n    try {\n        return doGetThen(obj);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\n\nvar hasProp = {}.hasOwnProperty;\nfunction isAnyBluebirdPromise(obj) {\n    try {\n        return hasProp.call(obj, \"_promise0\");\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction doThenable(x, then, context) {\n    var promise = new Promise(INTERNAL);\n    var ret = promise;\n    if (context) context._pushContext();\n    promise._captureStackTrace();\n    if (context) context._popContext();\n    var synchronous = true;\n    var result = util.tryCatch(then).call(x, resolve, reject);\n    synchronous = false;\n\n    if (promise && result === errorObj) {\n        promise._rejectCallback(result.e, true, true);\n        promise = null;\n    }\n\n    function resolve(value) {\n        if (!promise) return;\n        promise._resolveCallback(value);\n        promise = null;\n    }\n\n    function reject(reason) {\n        if (!promise) return;\n        promise._rejectCallback(reason, synchronous, true);\n        promise = null;\n    }\n    return ret;\n}\n\nreturn tryConvertToPromise;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS90aGVuYWJsZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS90aGVuYWJsZXMuanM/ZTZkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwpIHtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBlcnJvck9iaiA9IHV0aWwuZXJyb3JPYmo7XG52YXIgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0O1xuXG5mdW5jdGlvbiB0cnlDb252ZXJ0VG9Qcm9taXNlKG9iaiwgY29udGV4dCkge1xuICAgIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gb2JqO1xuICAgICAgICB2YXIgdGhlbiA9IGdldFRoZW4ob2JqKTtcbiAgICAgICAgaWYgKHRoZW4gPT09IGVycm9yT2JqKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcHVzaENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciByZXQgPSBQcm9taXNlLnJlamVjdCh0aGVuLmUpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIGNvbnRleHQuX3BvcENvbnRleHQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKGlzQW55Qmx1ZWJpcmRQcm9taXNlKG9iaikpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICAgICAgICAgIG9iai5fdGhlbihcbiAgICAgICAgICAgICAgICAgICAgcmV0Ll9mdWxmaWxsLFxuICAgICAgICAgICAgICAgICAgICByZXQuX3JlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICByZXQsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZG9UaGVuYWJsZShvYmosIHRoZW4sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGRvR2V0VGhlbihvYmopIHtcbiAgICByZXR1cm4gb2JqLnRoZW47XG59XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvR2V0VGhlbihvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JPYmouZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICB9XG59XG5cbnZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBpc0FueUJsdWViaXJkUHJvbWlzZShvYmopIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gaGFzUHJvcC5jYWxsKG9iaiwgXCJfcHJvbWlzZTBcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkb1RoZW5hYmxlKHgsIHRoZW4sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgICB2YXIgcmV0ID0gcHJvbWlzZTtcbiAgICBpZiAoY29udGV4dCkgY29udGV4dC5fcHVzaENvbnRleHQoKTtcbiAgICBwcm9taXNlLl9jYXB0dXJlU3RhY2tUcmFjZSgpO1xuICAgIGlmIChjb250ZXh0KSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgdmFyIHN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICB2YXIgcmVzdWx0ID0gdXRpbC50cnlDYXRjaCh0aGVuKS5jYWxsKHgsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgc3luY2hyb25vdXMgPSBmYWxzZTtcblxuICAgIGlmIChwcm9taXNlICYmIHJlc3VsdCA9PT0gZXJyb3JPYmopIHtcbiAgICAgICAgcHJvbWlzZS5fcmVqZWN0Q2FsbGJhY2socmVzdWx0LmUsIHRydWUsIHRydWUpO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIGlmICghcHJvbWlzZSkgcmV0dXJuO1xuICAgICAgICBwcm9taXNlLl9yZXNvbHZlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgICAgIGlmICghcHJvbWlzZSkgcmV0dXJuO1xuICAgICAgICBwcm9taXNlLl9yZWplY3RDYWxsYmFjayhyZWFzb24sIHN5bmNocm9ub3VzLCB0cnVlKTtcbiAgICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5cbnJldHVybiB0cnlDb252ZXJ0VG9Qcm9taXNlO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/thenables.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/timers.js":
/*!****************************************************!*\
  !*** ./node_modules/bluebird/js/release/timers.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function(Promise, INTERNAL, debug) {\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\nvar TimeoutError = Promise.TimeoutError;\n\nfunction HandleWrapper(handle)  {\n    this.handle = handle;\n}\n\nHandleWrapper.prototype._resultCancelled = function() {\n    clearTimeout(this.handle);\n};\n\nvar afterValue = function(value) { return delay(+this).thenReturn(value); };\nvar delay = Promise.delay = function (ms, value) {\n    var ret;\n    var handle;\n    if (value !== undefined) {\n        ret = Promise.resolve(value)\n                ._then(afterValue, null, null, ms, undefined);\n        if (debug.cancellation() && value instanceof Promise) {\n            ret._setOnCancel(value);\n        }\n    } else {\n        ret = new Promise(INTERNAL);\n        handle = setTimeout(function() { ret._fulfill(); }, +ms);\n        if (debug.cancellation()) {\n            ret._setOnCancel(new HandleWrapper(handle));\n        }\n        ret._captureStackTrace();\n    }\n    ret._setAsyncGuaranteed();\n    return ret;\n};\n\nPromise.prototype.delay = function (ms) {\n    return delay(ms, this);\n};\n\nvar afterTimeout = function (promise, message, parent) {\n    var err;\n    if (typeof message !== \"string\") {\n        if (message instanceof Error) {\n            err = message;\n        } else {\n            err = new TimeoutError(\"operation timed out\");\n        }\n    } else {\n        err = new TimeoutError(message);\n    }\n    util.markAsOriginatingFromRejection(err);\n    promise._attachExtraTrace(err);\n    promise._reject(err);\n\n    if (parent != null) {\n        parent.cancel();\n    }\n};\n\nfunction successClear(value) {\n    clearTimeout(this.handle);\n    return value;\n}\n\nfunction failureClear(reason) {\n    clearTimeout(this.handle);\n    throw reason;\n}\n\nPromise.prototype.timeout = function (ms, message) {\n    ms = +ms;\n    var ret, parent;\n\n    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {\n        if (ret.isPending()) {\n            afterTimeout(ret, message, parent);\n        }\n    }, ms));\n\n    if (debug.cancellation()) {\n        parent = this.then();\n        ret = parent._then(successClear, failureClear,\n                            undefined, handleWrapper, undefined);\n        ret._setOnCancel(handleWrapper);\n    } else {\n        ret = this._then(successClear, failureClear,\n                            undefined, handleWrapper, undefined);\n    }\n\n    return ret;\n};\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS90aW1lcnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS90aW1lcnMuanM/ZDM2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUHJvbWlzZSwgSU5URVJOQUwsIGRlYnVnKSB7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgVGltZW91dEVycm9yID0gUHJvbWlzZS5UaW1lb3V0RXJyb3I7XG5cbmZ1bmN0aW9uIEhhbmRsZVdyYXBwZXIoaGFuZGxlKSAge1xuICAgIHRoaXMuaGFuZGxlID0gaGFuZGxlO1xufVxuXG5IYW5kbGVXcmFwcGVyLnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbn07XG5cbnZhciBhZnRlclZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIGRlbGF5KCt0aGlzKS50aGVuUmV0dXJuKHZhbHVlKTsgfTtcbnZhciBkZWxheSA9IFByb21pc2UuZGVsYXkgPSBmdW5jdGlvbiAobXMsIHZhbHVlKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgaGFuZGxlO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldCA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAuX3RoZW4oYWZ0ZXJWYWx1ZSwgbnVsbCwgbnVsbCwgbXMsIHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChkZWJ1Zy5jYW5jZWxsYXRpb24oKSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldC5fc2V0T25DYW5jZWwodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gbmV3IFByb21pc2UoSU5URVJOQUwpO1xuICAgICAgICBoYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyByZXQuX2Z1bGZpbGwoKTsgfSwgK21zKTtcbiAgICAgICAgaWYgKGRlYnVnLmNhbmNlbGxhdGlvbigpKSB7XG4gICAgICAgICAgICByZXQuX3NldE9uQ2FuY2VsKG5ldyBIYW5kbGVXcmFwcGVyKGhhbmRsZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldC5fY2FwdHVyZVN0YWNrVHJhY2UoKTtcbiAgICB9XG4gICAgcmV0Ll9zZXRBc3luY0d1YXJhbnRlZWQoKTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAobXMpIHtcbiAgICByZXR1cm4gZGVsYXkobXMsIHRoaXMpO1xufTtcblxudmFyIGFmdGVyVGltZW91dCA9IGZ1bmN0aW9uIChwcm9taXNlLCBtZXNzYWdlLCBwYXJlbnQpIHtcbiAgICB2YXIgZXJyO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBlcnIgPSBtZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gbmV3IFRpbWVvdXRFcnJvcihcIm9wZXJhdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBlcnIgPSBuZXcgVGltZW91dEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB1dGlsLm1hcmtBc09yaWdpbmF0aW5nRnJvbVJlamVjdGlvbihlcnIpO1xuICAgIHByb21pc2UuX2F0dGFjaEV4dHJhVHJhY2UoZXJyKTtcbiAgICBwcm9taXNlLl9yZWplY3QoZXJyKTtcblxuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQuY2FuY2VsKCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gc3VjY2Vzc0NsZWFyKHZhbHVlKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuaGFuZGxlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGZhaWx1cmVDbGVhcihyZWFzb24pIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgIHRocm93IHJlYXNvbjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcywgbWVzc2FnZSkge1xuICAgIG1zID0gK21zO1xuICAgIHZhciByZXQsIHBhcmVudDtcblxuICAgIHZhciBoYW5kbGVXcmFwcGVyID0gbmV3IEhhbmRsZVdyYXBwZXIoc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0VGltZW91dCgpIHtcbiAgICAgICAgaWYgKHJldC5pc1BlbmRpbmcoKSkge1xuICAgICAgICAgICAgYWZ0ZXJUaW1lb3V0KHJldCwgbWVzc2FnZSwgcGFyZW50KTtcbiAgICAgICAgfVxuICAgIH0sIG1zKSk7XG5cbiAgICBpZiAoZGVidWcuY2FuY2VsbGF0aW9uKCkpIHtcbiAgICAgICAgcGFyZW50ID0gdGhpcy50aGVuKCk7XG4gICAgICAgIHJldCA9IHBhcmVudC5fdGhlbihzdWNjZXNzQ2xlYXIsIGZhaWx1cmVDbGVhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIGhhbmRsZVdyYXBwZXIsIHVuZGVmaW5lZCk7XG4gICAgICAgIHJldC5fc2V0T25DYW5jZWwoaGFuZGxlV3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gdGhpcy5fdGhlbihzdWNjZXNzQ2xlYXIsIGZhaWx1cmVDbGVhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIGhhbmRsZVdyYXBwZXIsIHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/timers.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/using.js":
/*!***************************************************!*\
  !*** ./node_modules/bluebird/js/release/using.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function (Promise, apiRejection, tryConvertToPromise,\n    createContext, INTERNAL, debug) {\n    var util = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\");\n    var TypeError = __webpack_require__(/*! ./errors */ \"./node_modules/bluebird/js/release/errors.js\").TypeError;\n    var inherits = __webpack_require__(/*! ./util */ \"./node_modules/bluebird/js/release/util.js\").inherits;\n    var errorObj = util.errorObj;\n    var tryCatch = util.tryCatch;\n    var NULL = {};\n\n    function thrower(e) {\n        setTimeout(function(){throw e;}, 0);\n    }\n\n    function castPreservingDisposable(thenable) {\n        var maybePromise = tryConvertToPromise(thenable);\n        if (maybePromise !== thenable &&\n            typeof thenable._isDisposable === \"function\" &&\n            typeof thenable._getDisposer === \"function\" &&\n            thenable._isDisposable()) {\n            maybePromise._setDisposable(thenable._getDisposer());\n        }\n        return maybePromise;\n    }\n    function dispose(resources, inspection) {\n        var i = 0;\n        var len = resources.length;\n        var ret = new Promise(INTERNAL);\n        function iterator() {\n            if (i >= len) return ret._fulfill();\n            var maybePromise = castPreservingDisposable(resources[i++]);\n            if (maybePromise instanceof Promise &&\n                maybePromise._isDisposable()) {\n                try {\n                    maybePromise = tryConvertToPromise(\n                        maybePromise._getDisposer().tryDispose(inspection),\n                        resources.promise);\n                } catch (e) {\n                    return thrower(e);\n                }\n                if (maybePromise instanceof Promise) {\n                    return maybePromise._then(iterator, thrower,\n                                              null, null, null);\n                }\n            }\n            iterator();\n        }\n        iterator();\n        return ret;\n    }\n\n    function Disposer(data, promise, context) {\n        this._data = data;\n        this._promise = promise;\n        this._context = context;\n    }\n\n    Disposer.prototype.data = function () {\n        return this._data;\n    };\n\n    Disposer.prototype.promise = function () {\n        return this._promise;\n    };\n\n    Disposer.prototype.resource = function () {\n        if (this.promise().isFulfilled()) {\n            return this.promise().value();\n        }\n        return NULL;\n    };\n\n    Disposer.prototype.tryDispose = function(inspection) {\n        var resource = this.resource();\n        var context = this._context;\n        if (context !== undefined) context._pushContext();\n        var ret = resource !== NULL\n            ? this.doDispose(resource, inspection) : null;\n        if (context !== undefined) context._popContext();\n        this._promise._unsetDisposable();\n        this._data = null;\n        return ret;\n    };\n\n    Disposer.isDisposer = function (d) {\n        return (d != null &&\n                typeof d.resource === \"function\" &&\n                typeof d.tryDispose === \"function\");\n    };\n\n    function FunctionDisposer(fn, promise, context) {\n        this.constructor$(fn, promise, context);\n    }\n    inherits(FunctionDisposer, Disposer);\n\n    FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n        var fn = this.data();\n        return fn.call(resource, resource, inspection);\n    };\n\n    function maybeUnwrapDisposer(value) {\n        if (Disposer.isDisposer(value)) {\n            this.resources[this.index]._setDisposable(value);\n            return value.promise();\n        }\n        return value;\n    }\n\n    function ResourceList(length) {\n        this.length = length;\n        this.promise = null;\n        this[length-1] = null;\n    }\n\n    ResourceList.prototype._resultCancelled = function() {\n        var len = this.length;\n        for (var i = 0; i < len; ++i) {\n            var item = this[i];\n            if (item instanceof Promise) {\n                item.cancel();\n            }\n        }\n    };\n\n    Promise.using = function () {\n        var len = arguments.length;\n        if (len < 2) return apiRejection(\n                        \"you must pass at least 2 arguments to Promise.using\");\n        var fn = arguments[len - 1];\n        if (typeof fn !== \"function\") {\n            return apiRejection(\"expecting a function but got \" + util.classString(fn));\n        }\n        var input;\n        var spreadArgs = true;\n        if (len === 2 && Array.isArray(arguments[0])) {\n            input = arguments[0];\n            len = input.length;\n            spreadArgs = false;\n        } else {\n            input = arguments;\n            len--;\n        }\n        var resources = new ResourceList(len);\n        for (var i = 0; i < len; ++i) {\n            var resource = input[i];\n            if (Disposer.isDisposer(resource)) {\n                var disposer = resource;\n                resource = resource.promise();\n                resource._setDisposable(disposer);\n            } else {\n                var maybePromise = tryConvertToPromise(resource);\n                if (maybePromise instanceof Promise) {\n                    resource =\n                        maybePromise._then(maybeUnwrapDisposer, null, null, {\n                            resources: resources,\n                            index: i\n                    }, undefined);\n                }\n            }\n            resources[i] = resource;\n        }\n\n        var reflectedResources = new Array(resources.length);\n        for (var i = 0; i < reflectedResources.length; ++i) {\n            reflectedResources[i] = Promise.resolve(resources[i]).reflect();\n        }\n\n        var resultPromise = Promise.all(reflectedResources)\n            .then(function(inspections) {\n                for (var i = 0; i < inspections.length; ++i) {\n                    var inspection = inspections[i];\n                    if (inspection.isRejected()) {\n                        errorObj.e = inspection.error();\n                        return errorObj;\n                    } else if (!inspection.isFulfilled()) {\n                        resultPromise.cancel();\n                        return;\n                    }\n                    inspections[i] = inspection.value();\n                }\n                promise._pushContext();\n\n                fn = tryCatch(fn);\n                var ret = spreadArgs\n                    ? fn.apply(undefined, inspections) : fn(inspections);\n                var promiseCreated = promise._popContext();\n                debug.checkForgottenReturns(\n                    ret, promiseCreated, \"Promise.using\", promise);\n                return ret;\n            });\n\n        var promise = resultPromise.lastly(function() {\n            var inspection = new Promise.PromiseInspection(resultPromise);\n            return dispose(resources, inspection);\n        });\n        resources.promise = promise;\n        promise._setOnCancel(resources);\n        return promise;\n    };\n\n    Promise.prototype._setDisposable = function (disposer) {\n        this._bitField = this._bitField | 131072;\n        this._disposer = disposer;\n    };\n\n    Promise.prototype._isDisposable = function () {\n        return (this._bitField & 131072) > 0;\n    };\n\n    Promise.prototype._getDisposer = function () {\n        return this._disposer;\n    };\n\n    Promise.prototype._unsetDisposable = function () {\n        this._bitField = this._bitField & (~131072);\n        this._disposer = undefined;\n    };\n\n    Promise.prototype.disposer = function (fn) {\n        if (typeof fn === \"function\") {\n            return new FunctionDisposer(fn, this, createContext());\n        }\n        throw new TypeError();\n    };\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS91c2luZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibHVlYmlyZC9qcy9yZWxlYXNlL3VzaW5nLmpzPzk5ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChQcm9taXNlLCBhcGlSZWplY3Rpb24sIHRyeUNvbnZlcnRUb1Byb21pc2UsXG4gICAgY3JlYXRlQ29udGV4dCwgSU5URVJOQUwsIGRlYnVnKSB7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuICAgIHZhciBUeXBlRXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvcnNcIikuVHlwZUVycm9yO1xuICAgIHZhciBpbmhlcml0cyA9IHJlcXVpcmUoXCIuL3V0aWxcIikuaW5oZXJpdHM7XG4gICAgdmFyIGVycm9yT2JqID0gdXRpbC5lcnJvck9iajtcbiAgICB2YXIgdHJ5Q2F0Y2ggPSB1dGlsLnRyeUNhdGNoO1xuICAgIHZhciBOVUxMID0ge307XG5cbiAgICBmdW5jdGlvbiB0aHJvd2VyKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGU7fSwgMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FzdFByZXNlcnZpbmdEaXNwb3NhYmxlKHRoZW5hYmxlKSB7XG4gICAgICAgIHZhciBtYXliZVByb21pc2UgPSB0cnlDb252ZXJ0VG9Qcm9taXNlKHRoZW5hYmxlKTtcbiAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAhPT0gdGhlbmFibGUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGVuYWJsZS5faXNEaXNwb3NhYmxlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGVuYWJsZS5fZ2V0RGlzcG9zZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdGhlbmFibGUuX2lzRGlzcG9zYWJsZSgpKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuX3NldERpc3Bvc2FibGUodGhlbmFibGUuX2dldERpc3Bvc2VyKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXliZVByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3Bvc2UocmVzb3VyY2VzLCBpbnNwZWN0aW9uKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHJlc291cmNlcy5sZW5ndGg7XG4gICAgICAgIHZhciByZXQgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgICAgICAgaWYgKGkgPj0gbGVuKSByZXR1cm4gcmV0Ll9mdWxmaWxsKCk7XG4gICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gY2FzdFByZXNlcnZpbmdEaXNwb3NhYmxlKHJlc291cmNlc1tpKytdKTtcbiAgICAgICAgICAgIGlmIChtYXliZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlICYmXG4gICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl9pc0Rpc3Bvc2FibGUoKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG1heWJlUHJvbWlzZSA9IHRyeUNvbnZlcnRUb1Byb21pc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZVByb21pc2UuX2dldERpc3Bvc2VyKCkudHJ5RGlzcG9zZShpbnNwZWN0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlcy5wcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd2VyKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF5YmVQcm9taXNlLl90aGVuKGl0ZXJhdG9yLCB0aHJvd2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZXJhdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlcmF0b3IoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEaXNwb3NlcihkYXRhLCBwcm9taXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLl9wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuXG4gICAgRGlzcG9zZXIucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gICAgfTtcblxuICAgIERpc3Bvc2VyLnByb3RvdHlwZS5yZXNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvbWlzZSgpLmlzRnVsZmlsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UoKS52YWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOVUxMO1xuICAgIH07XG5cbiAgICBEaXNwb3Nlci5wcm90b3R5cGUudHJ5RGlzcG9zZSA9IGZ1bmN0aW9uKGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIHJlc291cmNlID0gdGhpcy5yZXNvdXJjZSgpO1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIGNvbnRleHQuX3B1c2hDb250ZXh0KCk7XG4gICAgICAgIHZhciByZXQgPSByZXNvdXJjZSAhPT0gTlVMTFxuICAgICAgICAgICAgPyB0aGlzLmRvRGlzcG9zZShyZXNvdXJjZSwgaW5zcGVjdGlvbikgOiBudWxsO1xuICAgICAgICBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSBjb250ZXh0Ll9wb3BDb250ZXh0KCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UuX3Vuc2V0RGlzcG9zYWJsZSgpO1xuICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgRGlzcG9zZXIuaXNEaXNwb3NlciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAoZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGQucmVzb3VyY2UgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkLnRyeURpc3Bvc2UgPT09IFwiZnVuY3Rpb25cIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRGlzcG9zZXIoZm4sIHByb21pc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciQoZm4sIHByb21pc2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpbmhlcml0cyhGdW5jdGlvbkRpc3Bvc2VyLCBEaXNwb3Nlcik7XG5cbiAgICBGdW5jdGlvbkRpc3Bvc2VyLnByb3RvdHlwZS5kb0Rpc3Bvc2UgPSBmdW5jdGlvbiAocmVzb3VyY2UsIGluc3BlY3Rpb24pIHtcbiAgICAgICAgdmFyIGZuID0gdGhpcy5kYXRhKCk7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHJlc291cmNlLCByZXNvdXJjZSwgaW5zcGVjdGlvbik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1heWJlVW53cmFwRGlzcG9zZXIodmFsdWUpIHtcbiAgICAgICAgaWYgKERpc3Bvc2VyLmlzRGlzcG9zZXIodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlc1t0aGlzLmluZGV4XS5fc2V0RGlzcG9zYWJsZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSZXNvdXJjZUxpc3QobGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzW2xlbmd0aC0xXSA9IG51bGw7XG4gICAgfVxuXG4gICAgUmVzb3VyY2VMaXN0LnByb3RvdHlwZS5fcmVzdWx0Q2FuY2VsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBQcm9taXNlLnVzaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA8IDIpIHJldHVybiBhcGlSZWplY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBcInlvdSBtdXN0IHBhc3MgYXQgbGVhc3QgMiBhcmd1bWVudHMgdG8gUHJvbWlzZS51c2luZ1wiKTtcbiAgICAgICAgdmFyIGZuID0gYXJndW1lbnRzW2xlbiAtIDFdO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGlSZWplY3Rpb24oXCJleHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiICsgdXRpbC5jbGFzc1N0cmluZyhmbikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dDtcbiAgICAgICAgdmFyIHNwcmVhZEFyZ3MgPSB0cnVlO1xuICAgICAgICBpZiAobGVuID09PSAyICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgaW5wdXQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBzcHJlYWRBcmdzID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dCA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNvdXJjZXMgPSBuZXcgUmVzb3VyY2VMaXN0KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IGlucHV0W2ldO1xuICAgICAgICAgICAgaWYgKERpc3Bvc2VyLmlzRGlzcG9zZXIocmVzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3Bvc2VyID0gcmVzb3VyY2U7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UgPSByZXNvdXJjZS5wcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UuX3NldERpc3Bvc2FibGUoZGlzcG9zZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gdHJ5Q29udmVydFRvUHJvbWlzZShyZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVQcm9taXNlLl90aGVuKG1heWJlVW53cmFwRGlzcG9zZXIsIG51bGwsIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXM6IHJlc291cmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICAgICAgICB9LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc291cmNlc1tpXSA9IHJlc291cmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZmxlY3RlZFJlc291cmNlcyA9IG5ldyBBcnJheShyZXNvdXJjZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZsZWN0ZWRSZXNvdXJjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlZmxlY3RlZFJlc291cmNlc1tpXSA9IFByb21pc2UucmVzb2x2ZShyZXNvdXJjZXNbaV0pLnJlZmxlY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHRQcm9taXNlID0gUHJvbWlzZS5hbGwocmVmbGVjdGVkUmVzb3VyY2VzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24oaW5zcGVjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3BlY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnNwZWN0aW9uID0gaW5zcGVjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNwZWN0aW9uLmlzUmVqZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JPYmouZSA9IGluc3BlY3Rpb24uZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck9iajtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaW5zcGVjdGlvbi5pc0Z1bGZpbGxlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQcm9taXNlLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc3BlY3Rpb25zW2ldID0gaW5zcGVjdGlvbi52YWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9taXNlLl9wdXNoQ29udGV4dCgpO1xuXG4gICAgICAgICAgICAgICAgZm4gPSB0cnlDYXRjaChmbik7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHNwcmVhZEFyZ3NcbiAgICAgICAgICAgICAgICAgICAgPyBmbi5hcHBseSh1bmRlZmluZWQsIGluc3BlY3Rpb25zKSA6IGZuKGluc3BlY3Rpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZUNyZWF0ZWQgPSBwcm9taXNlLl9wb3BDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgZGVidWcuY2hlY2tGb3Jnb3R0ZW5SZXR1cm5zKFxuICAgICAgICAgICAgICAgICAgICByZXQsIHByb21pc2VDcmVhdGVkLCBcIlByb21pc2UudXNpbmdcIiwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBwcm9taXNlID0gcmVzdWx0UHJvbWlzZS5sYXN0bHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaW5zcGVjdGlvbiA9IG5ldyBQcm9taXNlLlByb21pc2VJbnNwZWN0aW9uKHJlc3VsdFByb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3Bvc2UocmVzb3VyY2VzLCBpbnNwZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc291cmNlcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgcHJvbWlzZS5fc2V0T25DYW5jZWwocmVzb3VyY2VzKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl9zZXREaXNwb3NhYmxlID0gZnVuY3Rpb24gKGRpc3Bvc2VyKSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgfCAxMzEwNzI7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VyID0gZGlzcG9zZXI7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl9pc0Rpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fYml0RmllbGQgJiAxMzEwNzIpID4gMDtcbiAgICB9O1xuXG4gICAgUHJvbWlzZS5wcm90b3R5cGUuX2dldERpc3Bvc2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcG9zZXI7XG4gICAgfTtcblxuICAgIFByb21pc2UucHJvdG90eXBlLl91bnNldERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2JpdEZpZWxkID0gdGhpcy5fYml0RmllbGQgJiAofjEzMTA3Mik7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBQcm9taXNlLnByb3RvdHlwZS5kaXNwb3NlciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25EaXNwb3NlcihmbiwgdGhpcywgY3JlYXRlQ29udGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfTtcblxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/using.js\n");

/***/ }),

/***/ "./node_modules/bluebird/js/release/util.js":
/*!**************************************************!*\
  !*** ./node_modules/bluebird/js/release/util.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar es5 = __webpack_require__(/*! ./es5 */ \"./node_modules/bluebird/js/release/es5.js\");\nvar canEvaluate = typeof navigator == \"undefined\";\n\nvar errorObj = {e: {}};\nvar tryCatchTarget;\nvar globalObject = typeof self !== \"undefined\" ? self :\n    typeof window !== \"undefined\" ? window :\n    typeof global !== \"undefined\" ? global :\n    this !== undefined ? this : null;\n\nfunction tryCatcher() {\n    try {\n        var target = tryCatchTarget;\n        tryCatchTarget = null;\n        return target.apply(this, arguments);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\n\nvar inherits = function(Child, Parent) {\n    var hasProp = {}.hasOwnProperty;\n\n    function T() {\n        this.constructor = Child;\n        this.constructor$ = Parent;\n        for (var propertyName in Parent.prototype) {\n            if (hasProp.call(Parent.prototype, propertyName) &&\n                propertyName.charAt(propertyName.length-1) !== \"$\"\n           ) {\n                this[propertyName + \"$\"] = Parent.prototype[propertyName];\n            }\n        }\n    }\n    T.prototype = Parent.prototype;\n    Child.prototype = new T();\n    return Child.prototype;\n};\n\n\nfunction isPrimitive(val) {\n    return val == null || val === true || val === false ||\n        typeof val === \"string\" || typeof val === \"number\";\n\n}\n\nfunction isObject(value) {\n    return typeof value === \"function\" ||\n           typeof value === \"object\" && value !== null;\n}\n\nfunction maybeWrapAsError(maybeError) {\n    if (!isPrimitive(maybeError)) return maybeError;\n\n    return new Error(safeToString(maybeError));\n}\n\nfunction withAppended(target, appendee) {\n    var len = target.length;\n    var ret = new Array(len + 1);\n    var i;\n    for (i = 0; i < len; ++i) {\n        ret[i] = target[i];\n    }\n    ret[i] = appendee;\n    return ret;\n}\n\nfunction getDataPropertyOrDefault(obj, key, defaultValue) {\n    if (es5.isES5) {\n        var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n        if (desc != null) {\n            return desc.get == null && desc.set == null\n                    ? desc.value\n                    : defaultValue;\n        }\n    } else {\n        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\n    }\n}\n\nfunction notEnumerableProp(obj, name, value) {\n    if (isPrimitive(obj)) return obj;\n    var descriptor = {\n        value: value,\n        configurable: true,\n        enumerable: false,\n        writable: true\n    };\n    es5.defineProperty(obj, name, descriptor);\n    return obj;\n}\n\nfunction thrower(r) {\n    throw r;\n}\n\nvar inheritedDataKeys = (function() {\n    var excludedPrototypes = [\n        Array.prototype,\n        Object.prototype,\n        Function.prototype\n    ];\n\n    var isExcludedProto = function(val) {\n        for (var i = 0; i < excludedPrototypes.length; ++i) {\n            if (excludedPrototypes[i] === val) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    if (es5.isES5) {\n        var getKeys = Object.getOwnPropertyNames;\n        return function(obj) {\n            var ret = [];\n            var visitedKeys = Object.create(null);\n            while (obj != null && !isExcludedProto(obj)) {\n                var keys;\n                try {\n                    keys = getKeys(obj);\n                } catch (e) {\n                    return ret;\n                }\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (visitedKeys[key]) continue;\n                    visitedKeys[key] = true;\n                    var desc = Object.getOwnPropertyDescriptor(obj, key);\n                    if (desc != null && desc.get == null && desc.set == null) {\n                        ret.push(key);\n                    }\n                }\n                obj = es5.getPrototypeOf(obj);\n            }\n            return ret;\n        };\n    } else {\n        var hasProp = {}.hasOwnProperty;\n        return function(obj) {\n            if (isExcludedProto(obj)) return [];\n            var ret = [];\n\n            /*jshint forin:false */\n            enumeration: for (var key in obj) {\n                if (hasProp.call(obj, key)) {\n                    ret.push(key);\n                } else {\n                    for (var i = 0; i < excludedPrototypes.length; ++i) {\n                        if (hasProp.call(excludedPrototypes[i], key)) {\n                            continue enumeration;\n                        }\n                    }\n                    ret.push(key);\n                }\n            }\n            return ret;\n        };\n    }\n\n})();\n\nvar thisAssignmentPattern = /this\\s*\\.\\s*\\S+\\s*=/;\nfunction isClass(fn) {\n    try {\n        if (typeof fn === \"function\") {\n            var keys = es5.names(fn.prototype);\n\n            var hasMethods = es5.isES5 && keys.length > 1;\n            var hasMethodsOtherThanConstructor = keys.length > 0 &&\n                !(keys.length === 1 && keys[0] === \"constructor\");\n            var hasThisAssignmentAndStaticMethods =\n                thisAssignmentPattern.test(fn + \"\") && es5.names(fn).length > 0;\n\n            if (hasMethods || hasMethodsOtherThanConstructor ||\n                hasThisAssignmentAndStaticMethods) {\n                return true;\n            }\n        }\n        return false;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction toFastProperties(obj) {\n    /*jshint -W027,-W055,-W031*/\n    function FakeConstructor() {}\n    FakeConstructor.prototype = obj;\n    var l = 8;\n    while (l--) new FakeConstructor();\n    return obj;\n    eval(obj);\n}\n\nvar rident = /^[a-z$_][a-z$_0-9]*$/i;\nfunction isIdentifier(str) {\n    return rident.test(str);\n}\n\nfunction filledRange(count, prefix, suffix) {\n    var ret = new Array(count);\n    for(var i = 0; i < count; ++i) {\n        ret[i] = prefix + i + suffix;\n    }\n    return ret;\n}\n\nfunction safeToString(obj) {\n    try {\n        return obj + \"\";\n    } catch (e) {\n        return \"[no string representation]\";\n    }\n}\n\nfunction isError(obj) {\n    return obj instanceof Error ||\n        (obj !== null &&\n           typeof obj === \"object\" &&\n           typeof obj.message === \"string\" &&\n           typeof obj.name === \"string\");\n}\n\nfunction markAsOriginatingFromRejection(e) {\n    try {\n        notEnumerableProp(e, \"isOperational\", true);\n    }\n    catch(ignore) {}\n}\n\nfunction originatesFromRejection(e) {\n    if (e == null) return false;\n    return ((e instanceof Error[\"__BluebirdErrorTypes__\"].OperationalError) ||\n        e[\"isOperational\"] === true);\n}\n\nfunction canAttachTrace(obj) {\n    return isError(obj) && es5.propertyIsWritable(obj, \"stack\");\n}\n\nvar ensureErrorObject = (function() {\n    if (!(\"stack\" in new Error())) {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            try {throw new Error(safeToString(value));}\n            catch(err) {return err;}\n        };\n    } else {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            return new Error(safeToString(value));\n        };\n    }\n})();\n\nfunction classString(obj) {\n    return {}.toString.call(obj);\n}\n\nfunction copyDescriptors(from, to, filter) {\n    var keys = es5.names(from);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        if (filter(key)) {\n            try {\n                es5.defineProperty(to, key, es5.getDescriptor(from, key));\n            } catch (ignore) {}\n        }\n    }\n}\n\nvar asArray = function(v) {\n    if (es5.isArray(v)) {\n        return v;\n    }\n    return null;\n};\n\nif (typeof Symbol !== \"undefined\" && Symbol.iterator) {\n    var ArrayFrom = typeof Array.from === \"function\" ? function(v) {\n        return Array.from(v);\n    } : function(v) {\n        var ret = [];\n        var it = v[Symbol.iterator]();\n        var itResult;\n        while (!((itResult = it.next()).done)) {\n            ret.push(itResult.value);\n        }\n        return ret;\n    };\n\n    asArray = function(v) {\n        if (es5.isArray(v)) {\n            return v;\n        } else if (v != null && typeof v[Symbol.iterator] === \"function\") {\n            return ArrayFrom(v);\n        }\n        return null;\n    };\n}\n\nvar isNode = typeof process !== \"undefined\" &&\n        classString(process).toLowerCase() === \"[object process]\";\n\nvar hasEnvVariables = typeof process !== \"undefined\" &&\n    typeof process.env !== \"undefined\";\n\nfunction env(key) {\n    return hasEnvVariables ? process.env[key] : undefined;\n}\n\nfunction getNativePromise() {\n    if (typeof Promise === \"function\") {\n        try {\n            var promise = new Promise(function(){});\n            if ({}.toString.call(promise) === \"[object Promise]\") {\n                return Promise;\n            }\n        } catch (e) {}\n    }\n}\n\nfunction domainBind(self, cb) {\n    return self.bind(cb);\n}\n\nvar ret = {\n    isClass: isClass,\n    isIdentifier: isIdentifier,\n    inheritedDataKeys: inheritedDataKeys,\n    getDataPropertyOrDefault: getDataPropertyOrDefault,\n    thrower: thrower,\n    isArray: es5.isArray,\n    asArray: asArray,\n    notEnumerableProp: notEnumerableProp,\n    isPrimitive: isPrimitive,\n    isObject: isObject,\n    isError: isError,\n    canEvaluate: canEvaluate,\n    errorObj: errorObj,\n    tryCatch: tryCatch,\n    inherits: inherits,\n    withAppended: withAppended,\n    maybeWrapAsError: maybeWrapAsError,\n    toFastProperties: toFastProperties,\n    filledRange: filledRange,\n    toString: safeToString,\n    canAttachTrace: canAttachTrace,\n    ensureErrorObject: ensureErrorObject,\n    originatesFromRejection: originatesFromRejection,\n    markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n    classString: classString,\n    copyDescriptors: copyDescriptors,\n    hasDevTools: typeof chrome !== \"undefined\" && chrome &&\n                 typeof chrome.loadTimes === \"function\",\n    isNode: isNode,\n    hasEnvVariables: hasEnvVariables,\n    env: env,\n    global: globalObject,\n    getNativePromise: getNativePromise,\n    domainBind: domainBind\n};\nret.isRecentNode = ret.isNode && (function() {\n    var version = process.versions.node.split(\".\").map(Number);\n    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);\n})();\n\nif (ret.isNode) ret.toFastProperties(process);\n\ntry {throw new Error(); } catch (e) {ret.lastLineError = e;}\nmodule.exports = ret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmx1ZWJpcmQvanMvcmVsZWFzZS91dGlsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JsdWViaXJkL2pzL3JlbGVhc2UvdXRpbC5qcz8xNjNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIGVzNSA9IHJlcXVpcmUoXCIuL2VzNVwiKTtcbnZhciBjYW5FdmFsdWF0ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJ1bmRlZmluZWRcIjtcblxudmFyIGVycm9yT2JqID0ge2U6IHt9fTtcbnZhciB0cnlDYXRjaFRhcmdldDtcbnZhciBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOlxuICAgIHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOlxuICAgIHRoaXMgIT09IHVuZGVmaW5lZCA/IHRoaXMgOiBudWxsO1xuXG5mdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0cnlDYXRjaFRhcmdldDtcbiAgICAgICAgdHJ5Q2F0Y2hUYXJnZXQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iai5lID0gZTtcbiAgICAgICAgcmV0dXJuIGVycm9yT2JqO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbn1cblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24oQ2hpbGQsIFBhcmVudCkge1xuICAgIHZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgICBmdW5jdGlvbiBUKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQ2hpbGQ7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IkID0gUGFyZW50O1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gUGFyZW50LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgaWYgKGhhc1Byb3AuY2FsbChQYXJlbnQucHJvdG90eXBlLCBwcm9wZXJ0eU5hbWUpICYmXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lLmNoYXJBdChwcm9wZXJ0eU5hbWUubGVuZ3RoLTEpICE9PSBcIiRcIlxuICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZSArIFwiJFwiXSA9IFBhcmVudC5wcm90b3R5cGVbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBULnByb3RvdHlwZSA9IFBhcmVudC5wcm90b3R5cGU7XG4gICAgQ2hpbGQucHJvdG90eXBlID0gbmV3IFQoKTtcbiAgICByZXR1cm4gQ2hpbGQucHJvdG90eXBlO1xufTtcblxuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UgfHxcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiO1xuXG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gbWF5YmVXcmFwQXNFcnJvcihtYXliZUVycm9yKSB7XG4gICAgaWYgKCFpc1ByaW1pdGl2ZShtYXliZUVycm9yKSkgcmV0dXJuIG1heWJlRXJyb3I7XG5cbiAgICByZXR1cm4gbmV3IEVycm9yKHNhZmVUb1N0cmluZyhtYXliZUVycm9yKSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhBcHBlbmRlZCh0YXJnZXQsIGFwcGVuZGVlKSB7XG4gICAgdmFyIGxlbiA9IHRhcmdldC5sZW5ndGg7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gdGFyZ2V0W2ldO1xuICAgIH1cbiAgICByZXRbaV0gPSBhcHBlbmRlZTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBnZXREYXRhUHJvcGVydHlPckRlZmF1bHQob2JqLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmIChlczUuaXNFUzUpIHtcbiAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcblxuICAgICAgICBpZiAoZGVzYyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYy5nZXQgPT0gbnVsbCAmJiBkZXNjLnNldCA9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gZGVzYy52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSA/IG9ialtrZXldIDogdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbm90RW51bWVyYWJsZVByb3Aob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChpc1ByaW1pdGl2ZShvYmopKSByZXR1cm4gb2JqO1xuICAgIHZhciBkZXNjcmlwdG9yID0ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfTtcbiAgICBlczUuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiB0aHJvd2VyKHIpIHtcbiAgICB0aHJvdyByO1xufVxuXG52YXIgaW5oZXJpdGVkRGF0YUtleXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4Y2x1ZGVkUHJvdG90eXBlcyA9IFtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGVcbiAgICBdO1xuXG4gICAgdmFyIGlzRXhjbHVkZWRQcm90byA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4Y2x1ZGVkUHJvdG90eXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkUHJvdG90eXBlc1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBpZiAoZXM1LmlzRVM1KSB7XG4gICAgICAgIHZhciBnZXRLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgIHZhciB2aXNpdGVkS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICB3aGlsZSAob2JqICE9IG51bGwgJiYgIWlzRXhjbHVkZWRQcm90byhvYmopKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleXM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IGdldEtleXMob2JqKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRLZXlzW2tleV0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdGVkS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgIT0gbnVsbCAmJiBkZXNjLmdldCA9PSBudWxsICYmIGRlc2Muc2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqID0gZXM1LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmIChpc0V4Y2x1ZGVkUHJvdG8ob2JqKSkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICAgICAgICAvKmpzaGludCBmb3JpbjpmYWxzZSAqL1xuICAgICAgICAgICAgZW51bWVyYXRpb246IGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhjbHVkZWRQcm90b3R5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUHJvcC5jYWxsKGV4Y2x1ZGVkUHJvdG90eXBlc1tpXSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGVudW1lcmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKCk7XG5cbnZhciB0aGlzQXNzaWdubWVudFBhdHRlcm4gPSAvdGhpc1xccypcXC5cXHMqXFxTK1xccyo9LztcbmZ1bmN0aW9uIGlzQ2xhc3MoZm4pIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gZXM1Lm5hbWVzKGZuLnByb3RvdHlwZSk7XG5cbiAgICAgICAgICAgIHZhciBoYXNNZXRob2RzID0gZXM1LmlzRVM1ICYmIGtleXMubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIHZhciBoYXNNZXRob2RzT3RoZXJUaGFuQ29uc3RydWN0b3IgPSBrZXlzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAhKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09IFwiY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICB2YXIgaGFzVGhpc0Fzc2lnbm1lbnRBbmRTdGF0aWNNZXRob2RzID1cbiAgICAgICAgICAgICAgICB0aGlzQXNzaWdubWVudFBhdHRlcm4udGVzdChmbiArIFwiXCIpICYmIGVzNS5uYW1lcyhmbikubGVuZ3RoID4gMDtcblxuICAgICAgICAgICAgaWYgKGhhc01ldGhvZHMgfHwgaGFzTWV0aG9kc090aGVyVGhhbkNvbnN0cnVjdG9yIHx8XG4gICAgICAgICAgICAgICAgaGFzVGhpc0Fzc2lnbm1lbnRBbmRTdGF0aWNNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9GYXN0UHJvcGVydGllcyhvYmopIHtcbiAgICAvKmpzaGludCAtVzAyNywtVzA1NSwtVzAzMSovXG4gICAgZnVuY3Rpb24gRmFrZUNvbnN0cnVjdG9yKCkge31cbiAgICBGYWtlQ29uc3RydWN0b3IucHJvdG90eXBlID0gb2JqO1xuICAgIHZhciBsID0gODtcbiAgICB3aGlsZSAobC0tKSBuZXcgRmFrZUNvbnN0cnVjdG9yKCk7XG4gICAgcmV0dXJuIG9iajtcbiAgICBldmFsKG9iaik7XG59XG5cbnZhciByaWRlbnQgPSAvXlthLXokX11bYS16JF8wLTldKiQvaTtcbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihzdHIpIHtcbiAgICByZXR1cm4gcmlkZW50LnRlc3Qoc3RyKTtcbn1cblxuZnVuY3Rpb24gZmlsbGVkUmFuZ2UoY291bnQsIHByZWZpeCwgc3VmZml4KSB7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgcmV0W2ldID0gcHJlZml4ICsgaSArIHN1ZmZpeDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gc2FmZVRvU3RyaW5nKG9iaikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvYmogKyBcIlwiO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFwiW25vIHN0cmluZyByZXByZXNlbnRhdGlvbl1cIjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEVycm9yIHx8XG4gICAgICAgIChvYmogIT09IG51bGwgJiZcbiAgICAgICAgICAgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICB0eXBlb2Ygb2JqLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgdHlwZW9mIG9iai5uYW1lID09PSBcInN0cmluZ1wiKTtcbn1cblxuZnVuY3Rpb24gbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uKGUpIHtcbiAgICB0cnkge1xuICAgICAgICBub3RFbnVtZXJhYmxlUHJvcChlLCBcImlzT3BlcmF0aW9uYWxcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGNhdGNoKGlnbm9yZSkge31cbn1cblxuZnVuY3Rpb24gb3JpZ2luYXRlc0Zyb21SZWplY3Rpb24oZSkge1xuICAgIGlmIChlID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKChlIGluc3RhbmNlb2YgRXJyb3JbXCJfX0JsdWViaXJkRXJyb3JUeXBlc19fXCJdLk9wZXJhdGlvbmFsRXJyb3IpIHx8XG4gICAgICAgIGVbXCJpc09wZXJhdGlvbmFsXCJdID09PSB0cnVlKTtcbn1cblxuZnVuY3Rpb24gY2FuQXR0YWNoVHJhY2Uob2JqKSB7XG4gICAgcmV0dXJuIGlzRXJyb3Iob2JqKSAmJiBlczUucHJvcGVydHlJc1dyaXRhYmxlKG9iaiwgXCJzdGFja1wiKTtcbn1cblxudmFyIGVuc3VyZUVycm9yT2JqZWN0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGlmICghKFwic3RhY2tcIiBpbiBuZXcgRXJyb3IoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY2FuQXR0YWNoVHJhY2UodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB0cnkge3Rocm93IG5ldyBFcnJvcihzYWZlVG9TdHJpbmcodmFsdWUpKTt9XG4gICAgICAgICAgICBjYXRjaChlcnIpIHtyZXR1cm4gZXJyO31cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5BdHRhY2hUcmFjZSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3Ioc2FmZVRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcblxuZnVuY3Rpb24gY2xhc3NTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cblxuZnVuY3Rpb24gY29weURlc2NyaXB0b3JzKGZyb20sIHRvLCBmaWx0ZXIpIHtcbiAgICB2YXIga2V5cyA9IGVzNS5uYW1lcyhmcm9tKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChmaWx0ZXIoa2V5KSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlczUuZGVmaW5lUHJvcGVydHkodG8sIGtleSwgZXM1LmdldERlc2NyaXB0b3IoZnJvbSwga2V5KSk7XG4gICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBhc0FycmF5ID0gZnVuY3Rpb24odikge1xuICAgIGlmIChlczUuaXNBcnJheSh2KSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICB2YXIgQXJyYXlGcm9tID0gdHlwZW9mIEFycmF5LmZyb20gPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odik7XG4gICAgfSA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICB2YXIgaXQgPSB2W1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgdmFyIGl0UmVzdWx0O1xuICAgICAgICB3aGlsZSAoISgoaXRSZXN1bHQgPSBpdC5uZXh0KCkpLmRvbmUpKSB7XG4gICAgICAgICAgICByZXQucHVzaChpdFJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgYXNBcnJheSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKGVzNS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfSBlbHNlIGlmICh2ICE9IG51bGwgJiYgdHlwZW9mIHZbU3ltYm9sLml0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXlGcm9tKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG5cbnZhciBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICBjbGFzc1N0cmluZyhwcm9jZXNzKS50b0xvd2VyQ2FzZSgpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIjtcblxudmFyIGhhc0VudlZhcmlhYmxlcyA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MuZW52ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5mdW5jdGlvbiBlbnYoa2V5KSB7XG4gICAgcmV0dXJuIGhhc0VudlZhcmlhYmxlcyA/IHByb2Nlc3MuZW52W2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldE5hdGl2ZVByb21pc2UoKSB7XG4gICAgaWYgKHR5cGVvZiBQcm9taXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24oKXt9KTtcbiAgICAgICAgICAgIGlmICh7fS50b1N0cmluZy5jYWxsKHByb21pc2UpID09PSBcIltvYmplY3QgUHJvbWlzZV1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZG9tYWluQmluZChzZWxmLCBjYikge1xuICAgIHJldHVybiBzZWxmLmJpbmQoY2IpO1xufVxuXG52YXIgcmV0ID0ge1xuICAgIGlzQ2xhc3M6IGlzQ2xhc3MsXG4gICAgaXNJZGVudGlmaWVyOiBpc0lkZW50aWZpZXIsXG4gICAgaW5oZXJpdGVkRGF0YUtleXM6IGluaGVyaXRlZERhdGFLZXlzLFxuICAgIGdldERhdGFQcm9wZXJ0eU9yRGVmYXVsdDogZ2V0RGF0YVByb3BlcnR5T3JEZWZhdWx0LFxuICAgIHRocm93ZXI6IHRocm93ZXIsXG4gICAgaXNBcnJheTogZXM1LmlzQXJyYXksXG4gICAgYXNBcnJheTogYXNBcnJheSxcbiAgICBub3RFbnVtZXJhYmxlUHJvcDogbm90RW51bWVyYWJsZVByb3AsXG4gICAgaXNQcmltaXRpdmU6IGlzUHJpbWl0aXZlLFxuICAgIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgICBpc0Vycm9yOiBpc0Vycm9yLFxuICAgIGNhbkV2YWx1YXRlOiBjYW5FdmFsdWF0ZSxcbiAgICBlcnJvck9iajogZXJyb3JPYmosXG4gICAgdHJ5Q2F0Y2g6IHRyeUNhdGNoLFxuICAgIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgICB3aXRoQXBwZW5kZWQ6IHdpdGhBcHBlbmRlZCxcbiAgICBtYXliZVdyYXBBc0Vycm9yOiBtYXliZVdyYXBBc0Vycm9yLFxuICAgIHRvRmFzdFByb3BlcnRpZXM6IHRvRmFzdFByb3BlcnRpZXMsXG4gICAgZmlsbGVkUmFuZ2U6IGZpbGxlZFJhbmdlLFxuICAgIHRvU3RyaW5nOiBzYWZlVG9TdHJpbmcsXG4gICAgY2FuQXR0YWNoVHJhY2U6IGNhbkF0dGFjaFRyYWNlLFxuICAgIGVuc3VyZUVycm9yT2JqZWN0OiBlbnN1cmVFcnJvck9iamVjdCxcbiAgICBvcmlnaW5hdGVzRnJvbVJlamVjdGlvbjogb3JpZ2luYXRlc0Zyb21SZWplY3Rpb24sXG4gICAgbWFya0FzT3JpZ2luYXRpbmdGcm9tUmVqZWN0aW9uOiBtYXJrQXNPcmlnaW5hdGluZ0Zyb21SZWplY3Rpb24sXG4gICAgY2xhc3NTdHJpbmc6IGNsYXNzU3RyaW5nLFxuICAgIGNvcHlEZXNjcmlwdG9yczogY29weURlc2NyaXB0b3JzLFxuICAgIGhhc0RldlRvb2xzOiB0eXBlb2YgY2hyb21lICE9PSBcInVuZGVmaW5lZFwiICYmIGNocm9tZSAmJlxuICAgICAgICAgICAgICAgICB0eXBlb2YgY2hyb21lLmxvYWRUaW1lcyA9PT0gXCJmdW5jdGlvblwiLFxuICAgIGlzTm9kZTogaXNOb2RlLFxuICAgIGhhc0VudlZhcmlhYmxlczogaGFzRW52VmFyaWFibGVzLFxuICAgIGVudjogZW52LFxuICAgIGdsb2JhbDogZ2xvYmFsT2JqZWN0LFxuICAgIGdldE5hdGl2ZVByb21pc2U6IGdldE5hdGl2ZVByb21pc2UsXG4gICAgZG9tYWluQmluZDogZG9tYWluQmluZFxufTtcbnJldC5pc1JlY2VudE5vZGUgPSByZXQuaXNOb2RlICYmIChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdChcIi5cIikubWFwKE51bWJlcik7XG4gICAgcmV0dXJuICh2ZXJzaW9uWzBdID09PSAwICYmIHZlcnNpb25bMV0gPiAxMCkgfHwgKHZlcnNpb25bMF0gPiAwKTtcbn0pKCk7XG5cbmlmIChyZXQuaXNOb2RlKSByZXQudG9GYXN0UHJvcGVydGllcyhwcm9jZXNzKTtcblxudHJ5IHt0aHJvdyBuZXcgRXJyb3IoKTsgfSBjYXRjaCAoZSkge3JldC5sYXN0TGluZUVycm9yID0gZTt9XG5tb2R1bGUuZXhwb3J0cyA9IHJldDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bluebird/js/release/util.js\n");

/***/ }),

/***/ "./node_modules/buffer-more-ints/buffer-more-ints.js":
/*!***********************************************************!*\
  !*** ./node_modules/buffer-more-ints/buffer-more-ints.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar assert = __webpack_require__(/*! assert */ \"assert\");\n\n// JavaScript is numerically challenged\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nvar SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\n// The maximum contiguous integer that can be held in a IEEE754 double\nvar MAX_INT = 0x1fffffffffffff;\n\nfunction isContiguousInt(val) {\n    return val <= MAX_INT && val >= -MAX_INT;\n}\n\nfunction assertContiguousInt(val) {\n    assert(isContiguousInt(val), \"number cannot be represented as a contiguous integer\");\n}\n\nmodule.exports.isContiguousInt = isContiguousInt;\nmodule.exports.assertContiguousInt = assertContiguousInt;\n\n// Fill in the regular procedures\n['UInt', 'Int'].forEach(function (sign) {\n  var suffix = sign + '8';\n  module.exports['read' + suffix] =\n    Buffer.prototype['read' + suffix].call;\n  module.exports['write' + suffix] =\n    Buffer.prototype['write' + suffix].call;\n  \n  ['16', '32'].forEach(function (size) {\n    ['LE', 'BE'].forEach(function (endian) {\n      var suffix = sign + size + endian;\n      var read = Buffer.prototype['read' + suffix];\n      module.exports['read' + suffix] =\n        function (buf, offset, noAssert) {\n          return read.call(buf, offset, noAssert);\n        };\n      var write = Buffer.prototype['write' + suffix];\n      module.exports['write' + suffix] =\n        function (buf, val, offset, noAssert) {\n          return write.call(buf, val, offset, noAssert);\n        };\n    });\n  });\n});\n\n// Check that a value is an integer within the given range\nfunction check_int(val, min, max) {\n    assert.ok(typeof(val) == 'number' && val >= min && val <= max && Math.floor(val) === val, \"not a number in the required range\");\n}\n\nfunction readUInt24BE(buf, offset, noAssert) {\n  return buf.readUInt8(offset, noAssert) << 16 | buf.readUInt16BE(offset + 1, noAssert);\n}\nmodule.exports.readUInt24BE = readUInt24BE;\n\nfunction writeUInt24BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffff);\n        assert.ok(offset + 3 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeUInt8(val >>> 16, offset, noAssert);\n    buf.writeUInt16BE(val & 0xffff, offset + 1, noAssert);\n}\nmodule.exports.writeUInt24BE = writeUInt24BE;\n\nfunction readUInt40BE(buf, offset, noAssert) {\n    return (buf.readUInt8(offset, noAssert) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1, noAssert);\n}\nmodule.exports.readUInt40BE = readUInt40BE;\n\nfunction writeUInt40BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffff);\n        assert.ok(offset + 5 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n    buf.writeInt32BE(val & -1, offset + 1, noAssert);\n}\nmodule.exports.writeUInt40BE = writeUInt40BE;\n\nfunction readUInt48BE(buf, offset, noAssert) {\n    return buf.readUInt16BE(offset, noAssert) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2, noAssert);\n}\nmodule.exports.readUInt48BE = readUInt48BE;\n\nfunction writeUInt48BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffffff);\n        assert.ok(offset + 6 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeUInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n    buf.writeInt32BE(val & -1, offset + 2, noAssert);\n}\nmodule.exports.writeUInt48BE = writeUInt48BE;\n\nfunction readUInt56BE(buf, offset, noAssert) {\n    return ((buf.readUInt8(offset, noAssert) || 0) << 16 | buf.readUInt16BE(offset + 1, noAssert)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3, noAssert);\n}\nmodule.exports.readUInt56BE = readUInt56BE;\n\nfunction writeUInt56BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffffffff);\n        assert.ok(offset + 7 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x100000000000000) {\n        var hi = Math.floor(val * SHIFT_RIGHT_32);\n        buf.writeUInt8(hi >>> 16, offset, noAssert);\n        buf.writeUInt16BE(hi & 0xffff, offset + 1, noAssert);\n        buf.writeInt32BE(val & -1, offset + 3, noAssert);\n    } else {\n        // Special case because 2^56-1 gets rounded up to 2^56\n        buf[offset] = 0xff;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n    }\n}\nmodule.exports.writeUInt56BE = writeUInt56BE;\n\nfunction readUInt64BE(buf, offset, noAssert) {\n    return buf.readUInt32BE(offset, noAssert) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4, noAssert);\n}\nmodule.exports.readUInt64BE = readUInt64BE;\n\nfunction writeUInt64BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffffffffff);\n        assert.ok(offset + 8 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x10000000000000000) {\n        buf.writeUInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n        buf.writeInt32BE(val & -1, offset + 4, noAssert);\n    } else {\n        // Special case because 2^64-1 gets rounded up to 2^64\n        buf[offset] = 0xff;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n        buf[offset+7] = 0xff;\n    }\n}\nmodule.exports.writeUInt64BE = writeUInt64BE;\n\nfunction readUInt24LE(buf, offset, noAssert) {\n    return buf.readUInt8(offset + 2, noAssert) << 16 | buf.readUInt16LE(offset, noAssert);\n}\nmodule.exports.readUInt24LE = readUInt24LE;\n\nfunction writeUInt24LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffff);\n        assert.ok(offset + 3 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeUInt16LE(val & 0xffff, offset, noAssert);\n    buf.writeUInt8(val >>> 16, offset + 2, noAssert);\n}\nmodule.exports.writeUInt24LE = writeUInt24LE;\n\nfunction readUInt40LE(buf, offset, noAssert) {\n    return (buf.readUInt8(offset + 4, noAssert) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readUInt40LE = readUInt40LE;\n\nfunction writeUInt40LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffff);\n        assert.ok(offset + 5 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt32LE(val & -1, offset, noAssert);\n    buf.writeUInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n}\nmodule.exports.writeUInt40LE = writeUInt40LE;\n\nfunction readUInt48LE(buf, offset, noAssert) {\n    return buf.readUInt16LE(offset + 4, noAssert) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readUInt48LE = readUInt48LE;\n\nfunction writeUInt48LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffffff);\n        assert.ok(offset + 6 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt32LE(val & -1, offset, noAssert);\n    buf.writeUInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n}\nmodule.exports.writeUInt48LE = writeUInt48LE;\n\nfunction readUInt56LE(buf, offset, noAssert) {\n    return ((buf.readUInt8(offset + 6, noAssert) || 0) << 16 | buf.readUInt16LE(offset + 4, noAssert)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readUInt56LE = readUInt56LE;\n\nfunction writeUInt56LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffffffff);\n        assert.ok(offset + 7 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x100000000000000) {\n        buf.writeInt32LE(val & -1, offset, noAssert);\n        var hi = Math.floor(val * SHIFT_RIGHT_32);\n        buf.writeUInt16LE(hi & 0xffff, offset + 4, noAssert);\n        buf.writeUInt8(hi >>> 16, offset + 6, noAssert);\n    } else {\n        // Special case because 2^56-1 gets rounded up to 2^56\n        buf[offset] = 0xff;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n    }\n}\nmodule.exports.writeUInt56LE = writeUInt56LE;\n\nfunction readUInt64LE(buf, offset, noAssert) {\n    return buf.readUInt32LE(offset + 4, noAssert) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readUInt64LE = readUInt64LE;\n\nfunction writeUInt64LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, 0, 0xffffffffffffffff);\n        assert.ok(offset + 8 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x10000000000000000) {\n        buf.writeInt32LE(val & -1, offset, noAssert);\n        buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n    } else {\n        // Special case because 2^64-1 gets rounded up to 2^64\n        buf[offset] = 0xff;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n        buf[offset+7] = 0xff;\n    }\n}\nmodule.exports.writeUInt64LE = writeUInt64LE;\n\n\nfunction readInt24BE(buf, offset, noAssert) {\n    return (buf.readInt8(offset, noAssert) << 16) + buf.readUInt16BE(offset + 1, noAssert);\n}\nmodule.exports.readInt24BE = readInt24BE;\n\nfunction writeInt24BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x800000, 0x7fffff);\n        assert.ok(offset + 3 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt8(val >> 16, offset, noAssert);\n    buf.writeUInt16BE(val & 0xffff, offset + 1, noAssert);\n}\nmodule.exports.writeInt24BE = writeInt24BE;\n\nfunction readInt40BE(buf, offset, noAssert) {\n    return (buf.readInt8(offset, noAssert) || 0) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 1, noAssert);\n}\nmodule.exports.readInt40BE = readInt40BE;\n\nfunction writeInt40BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x8000000000, 0x7fffffffff);\n        assert.ok(offset + 5 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n    buf.writeInt32BE(val & -1, offset + 1, noAssert);\n}\nmodule.exports.writeInt40BE = writeInt40BE;\n\nfunction readInt48BE(buf, offset, noAssert) {\n    return buf.readInt16BE(offset, noAssert) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 2, noAssert);\n}\nmodule.exports.readInt48BE = readInt48BE;\n\nfunction writeInt48BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x800000000000, 0x7fffffffffff);\n        assert.ok(offset + 6 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt16BE(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n    buf.writeInt32BE(val & -1, offset + 2, noAssert);\n}\nmodule.exports.writeInt48BE = writeInt48BE;\n\nfunction readInt56BE(buf, offset, noAssert) {\n    return (((buf.readInt8(offset, noAssert) || 0) << 16) + buf.readUInt16BE(offset + 1, noAssert)) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 3, noAssert);\n}\nmodule.exports.readInt56BE = readInt56BE;\n\nfunction writeInt56BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x800000000000000, 0x7fffffffffffff);\n        assert.ok(offset + 7 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x80000000000000) {\n        var hi = Math.floor(val * SHIFT_RIGHT_32);\n        buf.writeInt8(hi >> 16, offset, noAssert);\n        buf.writeUInt16BE(hi & 0xffff, offset + 1, noAssert);\n        buf.writeInt32BE(val & -1, offset + 3, noAssert);\n    } else {\n        // Special case because 2^55-1 gets rounded up to 2^55\n        buf[offset] = 0x7f;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n    }\n}\nmodule.exports.writeInt56BE = writeInt56BE;\n\nfunction readInt64BE(buf, offset, noAssert) {\n    return buf.readInt32BE(offset, noAssert) * SHIFT_LEFT_32 + buf.readUInt32BE(offset + 4, noAssert);\n}\nmodule.exports.readInt64BE = readInt64BE;\n\nfunction writeInt64BE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x800000000000000000, 0x7fffffffffffffff);\n        assert.ok(offset + 8 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x8000000000000000) {\n        buf.writeInt32BE(Math.floor(val * SHIFT_RIGHT_32), offset, noAssert);\n        buf.writeInt32BE(val & -1, offset + 4, noAssert);\n    } else {\n        // Special case because 2^63-1 gets rounded up to 2^63\n        buf[offset] = 0x7f;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n        buf[offset+7] = 0xff;\n    }\n}\nmodule.exports.writeInt64BE = writeInt64BE;\n\nfunction readInt24LE(buf, offset, noAssert) {\n    return (buf.readInt8(offset + 2, noAssert) << 16) + buf.readUInt16LE(offset, noAssert);\n}\nmodule.exports.readInt24LE = readInt24LE;\n\nfunction writeInt24LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x800000, 0x7fffff);\n        assert.ok(offset + 3 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeUInt16LE(val & 0xffff, offset, noAssert);\n    buf.writeInt8(val >> 16, offset + 2, noAssert);\n}\nmodule.exports.writeInt24LE = writeInt24LE;\n\nfunction readInt40LE(buf, offset, noAssert) {\n    return (buf.readInt8(offset + 4, noAssert) || 0) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readInt40LE = readInt40LE;\n\nfunction writeInt40LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x8000000000, 0x7fffffffff);\n        assert.ok(offset + 5 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt32LE(val & -1, offset, noAssert);\n    buf.writeInt8(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n}\nmodule.exports.writeInt40LE = writeInt40LE;\n\nfunction readInt48LE(buf, offset, noAssert) {\n    return buf.readInt16LE(offset + 4, noAssert) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readInt48LE = readInt48LE;\n\nfunction writeInt48LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x800000000000, 0x7fffffffffff);\n        assert.ok(offset + 6 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    buf.writeInt32LE(val & -1, offset, noAssert);\n    buf.writeInt16LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n}\nmodule.exports.writeInt48LE = writeInt48LE;\n\nfunction readInt56LE(buf, offset, noAssert) {\n    return (((buf.readInt8(offset + 6, noAssert) || 0) << 16) + buf.readUInt16LE(offset + 4, noAssert)) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readInt56LE = readInt56LE;\n\nfunction writeInt56LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x80000000000000, 0x7fffffffffffff);\n        assert.ok(offset + 7 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x80000000000000) {\n        buf.writeInt32LE(val & -1, offset, noAssert);\n        var hi = Math.floor(val * SHIFT_RIGHT_32);\n        buf.writeUInt16LE(hi & 0xffff, offset + 4, noAssert);\n        buf.writeInt8(hi >> 16, offset + 6, noAssert);\n    } else {\n        // Special case because 2^55-1 gets rounded up to 2^55\n        buf[offset] = 0xff;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0x7f;\n    }\n}\nmodule.exports.writeInt56LE = writeInt56LE;\n\nfunction readInt64LE(buf, offset, noAssert) {\n    return buf.readInt32LE(offset + 4, noAssert) * SHIFT_LEFT_32 + buf.readUInt32LE(offset, noAssert);\n}\nmodule.exports.readInt64LE = readInt64LE;\n\nfunction writeInt64LE(buf, val, offset, noAssert) {\n    if (!noAssert) {\n        check_int(val, -0x8000000000000000, 0x7fffffffffffffff);\n        assert.ok(offset + 8 <= buf.length, \"attempt to write beyond end of buffer\");\n    }\n\n    if (val < 0x8000000000000000) {\n        buf.writeInt32LE(val & -1, offset, noAssert);\n        buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), offset + 4, noAssert);\n    } else {\n        // Special case because 2^55-1 gets rounded up to 2^55\n        buf[offset] = 0xff;\n        buf[offset+1] = 0xff;\n        buf[offset+2] = 0xff;\n        buf[offset+3] = 0xff;\n        buf[offset+4] = 0xff;\n        buf[offset+5] = 0xff;\n        buf[offset+6] = 0xff;\n        buf[offset+7] = 0x7f;\n    }\n}\nmodule.exports.writeInt64LE = writeInt64LE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVmZmVyLW1vcmUtaW50cy9idWZmZXItbW9yZS1pbnRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci1tb3JlLWludHMvYnVmZmVyLW1vcmUtaW50cy5qcz82OWRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5cbi8vIEphdmFTY3JpcHQgaXMgbnVtZXJpY2FsbHkgY2hhbGxlbmdlZFxudmFyIFNISUZUX0xFRlRfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNik7XG52YXIgU0hJRlRfUklHSFRfMzIgPSAxIC8gU0hJRlRfTEVGVF8zMjtcblxuLy8gVGhlIG1heGltdW0gY29udGlndW91cyBpbnRlZ2VyIHRoYXQgY2FuIGJlIGhlbGQgaW4gYSBJRUVFNzU0IGRvdWJsZVxudmFyIE1BWF9JTlQgPSAweDFmZmZmZmZmZmZmZmZmO1xuXG5mdW5jdGlvbiBpc0NvbnRpZ3VvdXNJbnQodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA8PSBNQVhfSU5UICYmIHZhbCA+PSAtTUFYX0lOVDtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0Q29udGlndW91c0ludCh2YWwpIHtcbiAgICBhc3NlcnQoaXNDb250aWd1b3VzSW50KHZhbCksIFwibnVtYmVyIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhcyBhIGNvbnRpZ3VvdXMgaW50ZWdlclwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMuaXNDb250aWd1b3VzSW50ID0gaXNDb250aWd1b3VzSW50O1xubW9kdWxlLmV4cG9ydHMuYXNzZXJ0Q29udGlndW91c0ludCA9IGFzc2VydENvbnRpZ3VvdXNJbnQ7XG5cbi8vIEZpbGwgaW4gdGhlIHJlZ3VsYXIgcHJvY2VkdXJlc1xuWydVSW50JywgJ0ludCddLmZvckVhY2goZnVuY3Rpb24gKHNpZ24pIHtcbiAgdmFyIHN1ZmZpeCA9IHNpZ24gKyAnOCc7XG4gIG1vZHVsZS5leHBvcnRzWydyZWFkJyArIHN1ZmZpeF0gPVxuICAgIEJ1ZmZlci5wcm90b3R5cGVbJ3JlYWQnICsgc3VmZml4XS5jYWxsO1xuICBtb2R1bGUuZXhwb3J0c1snd3JpdGUnICsgc3VmZml4XSA9XG4gICAgQnVmZmVyLnByb3RvdHlwZVsnd3JpdGUnICsgc3VmZml4XS5jYWxsO1xuICBcbiAgWycxNicsICczMiddLmZvckVhY2goZnVuY3Rpb24gKHNpemUpIHtcbiAgICBbJ0xFJywgJ0JFJ10uZm9yRWFjaChmdW5jdGlvbiAoZW5kaWFuKSB7XG4gICAgICB2YXIgc3VmZml4ID0gc2lnbiArIHNpemUgKyBlbmRpYW47XG4gICAgICB2YXIgcmVhZCA9IEJ1ZmZlci5wcm90b3R5cGVbJ3JlYWQnICsgc3VmZml4XTtcbiAgICAgIG1vZHVsZS5leHBvcnRzWydyZWFkJyArIHN1ZmZpeF0gPVxuICAgICAgICBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWQuY2FsbChidWYsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICAgICAgICB9O1xuICAgICAgdmFyIHdyaXRlID0gQnVmZmVyLnByb3RvdHlwZVsnd3JpdGUnICsgc3VmZml4XTtcbiAgICAgIG1vZHVsZS5leHBvcnRzWyd3cml0ZScgKyBzdWZmaXhdID1cbiAgICAgICAgZnVuY3Rpb24gKGJ1ZiwgdmFsLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlLmNhbGwoYnVmLCB2YWwsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vLyBDaGVjayB0aGF0IGEgdmFsdWUgaXMgYW4gaW50ZWdlciB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlXG5mdW5jdGlvbiBjaGVja19pbnQodmFsLCBtaW4sIG1heCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YodmFsKSA9PSAnbnVtYmVyJyAmJiB2YWwgPj0gbWluICYmIHZhbCA8PSBtYXggJiYgTWF0aC5mbG9vcih2YWwpID09PSB2YWwsIFwibm90IGEgbnVtYmVyIGluIHRoZSByZXF1aXJlZCByYW5nZVwiKTtcbn1cblxuZnVuY3Rpb24gcmVhZFVJbnQyNEJFKGJ1Ziwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gYnVmLnJlYWRVSW50OChvZmZzZXQsIG5vQXNzZXJ0KSA8PCAxNiB8IGJ1Zi5yZWFkVUludDE2QkUob2Zmc2V0ICsgMSwgbm9Bc3NlcnQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZFVJbnQyNEJFID0gcmVhZFVJbnQyNEJFO1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQyNEJFKGJ1ZiwgdmFsLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjaGVja19pbnQodmFsLCAwLCAweGZmZmZmZik7XG4gICAgICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDw9IGJ1Zi5sZW5ndGgsIFwiYXR0ZW1wdCB0byB3cml0ZSBiZXlvbmQgZW5kIG9mIGJ1ZmZlclwiKTtcbiAgICB9XG5cbiAgICBidWYud3JpdGVVSW50OCh2YWwgPj4+IDE2LCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgICBidWYud3JpdGVVSW50MTZCRSh2YWwgJiAweGZmZmYsIG9mZnNldCArIDEsIG5vQXNzZXJ0KTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlVUludDI0QkUgPSB3cml0ZVVJbnQyNEJFO1xuXG5mdW5jdGlvbiByZWFkVUludDQwQkUoYnVmLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIChidWYucmVhZFVJbnQ4KG9mZnNldCwgbm9Bc3NlcnQpIHx8IDApICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgMSwgbm9Bc3NlcnQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZFVJbnQ0MEJFID0gcmVhZFVJbnQ0MEJFO1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQ0MEJFKGJ1ZiwgdmFsLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjaGVja19pbnQodmFsLCAwLCAweGZmZmZmZmZmZmYpO1xuICAgICAgICBhc3NlcnQub2sob2Zmc2V0ICsgNSA8PSBidWYubGVuZ3RoLCBcImF0dGVtcHQgdG8gd3JpdGUgYmV5b25kIGVuZCBvZiBidWZmZXJcIik7XG4gICAgfVxuXG4gICAgYnVmLndyaXRlVUludDgoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIG9mZnNldCwgbm9Bc3NlcnQpO1xuICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDEsIG5vQXNzZXJ0KTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlVUludDQwQkUgPSB3cml0ZVVJbnQ0MEJFO1xuXG5mdW5jdGlvbiByZWFkVUludDQ4QkUoYnVmLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUob2Zmc2V0LCBub0Fzc2VydCkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyAyLCBub0Fzc2VydCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkVUludDQ4QkUgPSByZWFkVUludDQ4QkU7XG5cbmZ1bmN0aW9uIHdyaXRlVUludDQ4QkUoYnVmLCB2YWwsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgIGNoZWNrX2ludCh2YWwsIDAsIDB4ZmZmZmZmZmZmZmZmKTtcbiAgICAgICAgYXNzZXJ0Lm9rKG9mZnNldCArIDYgPD0gYnVmLmxlbmd0aCwgXCJhdHRlbXB0IHRvIHdyaXRlIGJleW9uZCBlbmQgb2YgYnVmZmVyXCIpO1xuICAgIH1cblxuICAgIGJ1Zi53cml0ZVVJbnQxNkJFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgICBidWYud3JpdGVJbnQzMkJFKHZhbCAmIC0xLCBvZmZzZXQgKyAyLCBub0Fzc2VydCk7XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZVVJbnQ0OEJFID0gd3JpdGVVSW50NDhCRTtcblxuZnVuY3Rpb24gcmVhZFVJbnQ1NkJFKGJ1Ziwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHJldHVybiAoKGJ1Zi5yZWFkVUludDgob2Zmc2V0LCBub0Fzc2VydCkgfHwgMCkgPDwgMTYgfCBidWYucmVhZFVJbnQxNkJFKG9mZnNldCArIDEsIG5vQXNzZXJ0KSkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyAzLCBub0Fzc2VydCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkVUludDU2QkUgPSByZWFkVUludDU2QkU7XG5cbmZ1bmN0aW9uIHdyaXRlVUludDU2QkUoYnVmLCB2YWwsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgIGNoZWNrX2ludCh2YWwsIDAsIDB4ZmZmZmZmZmZmZmZmZmYpO1xuICAgICAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8PSBidWYubGVuZ3RoLCBcImF0dGVtcHQgdG8gd3JpdGUgYmV5b25kIGVuZCBvZiBidWZmZXJcIik7XG4gICAgfVxuXG4gICAgaWYgKHZhbCA8IDB4MTAwMDAwMDAwMDAwMDAwKSB7XG4gICAgICAgIHZhciBoaSA9IE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpO1xuICAgICAgICBidWYud3JpdGVVSW50OChoaSA+Pj4gMTYsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICAgICAgICBidWYud3JpdGVVSW50MTZCRShoaSAmIDB4ZmZmZiwgb2Zmc2V0ICsgMSwgbm9Bc3NlcnQpO1xuICAgICAgICBidWYud3JpdGVJbnQzMkJFKHZhbCAmIC0xLCBvZmZzZXQgKyAzLCBub0Fzc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGJlY2F1c2UgMl41Ni0xIGdldHMgcm91bmRlZCB1cCB0byAyXjU2XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsxXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzNdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzZdID0gMHhmZjtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZVVJbnQ1NkJFID0gd3JpdGVVSW50NTZCRTtcblxuZnVuY3Rpb24gcmVhZFVJbnQ2NEJFKGJ1Ziwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHJldHVybiBidWYucmVhZFVJbnQzMkJFKG9mZnNldCwgbm9Bc3NlcnQpICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgNCwgbm9Bc3NlcnQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZFVJbnQ2NEJFID0gcmVhZFVJbnQ2NEJFO1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQ2NEJFKGJ1ZiwgdmFsLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjaGVja19pbnQodmFsLCAwLCAweGZmZmZmZmZmZmZmZmZmZmYpO1xuICAgICAgICBhc3NlcnQub2sob2Zmc2V0ICsgOCA8PSBidWYubGVuZ3RoLCBcImF0dGVtcHQgdG8gd3JpdGUgYmV5b25kIGVuZCBvZiBidWZmZXJcIik7XG4gICAgfVxuXG4gICAgaWYgKHZhbCA8IDB4MTAwMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgYnVmLndyaXRlVUludDMyQkUoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIG9mZnNldCwgbm9Bc3NlcnQpO1xuICAgICAgICBidWYud3JpdGVJbnQzMkJFKHZhbCAmIC0xLCBvZmZzZXQgKyA0LCBub0Fzc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGJlY2F1c2UgMl42NC0xIGdldHMgcm91bmRlZCB1cCB0byAyXjY0XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsxXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzNdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzZdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs3XSA9IDB4ZmY7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMud3JpdGVVSW50NjRCRSA9IHdyaXRlVUludDY0QkU7XG5cbmZ1bmN0aW9uIHJlYWRVSW50MjRMRShidWYsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICByZXR1cm4gYnVmLnJlYWRVSW50OChvZmZzZXQgKyAyLCBub0Fzc2VydCkgPDwgMTYgfCBidWYucmVhZFVJbnQxNkxFKG9mZnNldCwgbm9Bc3NlcnQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZFVJbnQyNExFID0gcmVhZFVJbnQyNExFO1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQyNExFKGJ1ZiwgdmFsLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjaGVja19pbnQodmFsLCAwLCAweGZmZmZmZik7XG4gICAgICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDw9IGJ1Zi5sZW5ndGgsIFwiYXR0ZW1wdCB0byB3cml0ZSBiZXlvbmQgZW5kIG9mIGJ1ZmZlclwiKTtcbiAgICB9XG5cbiAgICBidWYud3JpdGVVSW50MTZMRSh2YWwgJiAweGZmZmYsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICAgIGJ1Zi53cml0ZVVJbnQ4KHZhbCA+Pj4gMTYsIG9mZnNldCArIDIsIG5vQXNzZXJ0KTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlVUludDI0TEUgPSB3cml0ZVVJbnQyNExFO1xuXG5mdW5jdGlvbiByZWFkVUludDQwTEUoYnVmLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIChidWYucmVhZFVJbnQ4KG9mZnNldCArIDQsIG5vQXNzZXJ0KSB8fCAwKSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkxFKG9mZnNldCwgbm9Bc3NlcnQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZFVJbnQ0MExFID0gcmVhZFVJbnQ0MExFO1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQ0MExFKGJ1ZiwgdmFsLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjaGVja19pbnQodmFsLCAwLCAweGZmZmZmZmZmZmYpO1xuICAgICAgICBhc3NlcnQub2sob2Zmc2V0ICsgNSA8PSBidWYubGVuZ3RoLCBcImF0dGVtcHQgdG8gd3JpdGUgYmV5b25kIGVuZCBvZiBidWZmZXJcIik7XG4gICAgfVxuXG4gICAgYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgb2Zmc2V0LCBub0Fzc2VydCk7XG4gICAgYnVmLndyaXRlVUludDgoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIG9mZnNldCArIDQsIG5vQXNzZXJ0KTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlVUludDQwTEUgPSB3cml0ZVVJbnQ0MExFO1xuXG5mdW5jdGlvbiByZWFkVUludDQ4TEUoYnVmLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2TEUob2Zmc2V0ICsgNCwgbm9Bc3NlcnQpICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyTEUob2Zmc2V0LCBub0Fzc2VydCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkVUludDQ4TEUgPSByZWFkVUludDQ4TEU7XG5cbmZ1bmN0aW9uIHdyaXRlVUludDQ4TEUoYnVmLCB2YWwsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgIGNoZWNrX2ludCh2YWwsIDAsIDB4ZmZmZmZmZmZmZmZmKTtcbiAgICAgICAgYXNzZXJ0Lm9rKG9mZnNldCArIDYgPD0gYnVmLmxlbmd0aCwgXCJhdHRlbXB0IHRvIHdyaXRlIGJleW9uZCBlbmQgb2YgYnVmZmVyXCIpO1xuICAgIH1cblxuICAgIGJ1Zi53cml0ZUludDMyTEUodmFsICYgLTEsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICAgIGJ1Zi53cml0ZVVJbnQxNkxFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQgKyA0LCBub0Fzc2VydCk7XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZVVJbnQ0OExFID0gd3JpdGVVSW50NDhMRTtcblxuZnVuY3Rpb24gcmVhZFVJbnQ1NkxFKGJ1Ziwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHJldHVybiAoKGJ1Zi5yZWFkVUludDgob2Zmc2V0ICsgNiwgbm9Bc3NlcnQpIHx8IDApIDw8IDE2IHwgYnVmLnJlYWRVSW50MTZMRShvZmZzZXQgKyA0LCBub0Fzc2VydCkpICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyTEUob2Zmc2V0LCBub0Fzc2VydCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkVUludDU2TEUgPSByZWFkVUludDU2TEU7XG5cbmZ1bmN0aW9uIHdyaXRlVUludDU2TEUoYnVmLCB2YWwsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgIGNoZWNrX2ludCh2YWwsIDAsIDB4ZmZmZmZmZmZmZmZmZmYpO1xuICAgICAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8PSBidWYubGVuZ3RoLCBcImF0dGVtcHQgdG8gd3JpdGUgYmV5b25kIGVuZCBvZiBidWZmZXJcIik7XG4gICAgfVxuXG4gICAgaWYgKHZhbCA8IDB4MTAwMDAwMDAwMDAwMDAwKSB7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyTEUodmFsICYgLTEsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICAgICAgICB2YXIgaGkgPSBNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKTtcbiAgICAgICAgYnVmLndyaXRlVUludDE2TEUoaGkgJiAweGZmZmYsIG9mZnNldCArIDQsIG5vQXNzZXJ0KTtcbiAgICAgICAgYnVmLndyaXRlVUludDgoaGkgPj4+IDE2LCBvZmZzZXQgKyA2LCBub0Fzc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGJlY2F1c2UgMl41Ni0xIGdldHMgcm91bmRlZCB1cCB0byAyXjU2XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsxXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzNdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzZdID0gMHhmZjtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZVVJbnQ1NkxFID0gd3JpdGVVSW50NTZMRTtcblxuZnVuY3Rpb24gcmVhZFVJbnQ2NExFKGJ1Ziwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHJldHVybiBidWYucmVhZFVJbnQzMkxFKG9mZnNldCArIDQsIG5vQXNzZXJ0KSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkxFKG9mZnNldCwgbm9Bc3NlcnQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZFVJbnQ2NExFID0gcmVhZFVJbnQ2NExFO1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQ2NExFKGJ1ZiwgdmFsLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjaGVja19pbnQodmFsLCAwLCAweGZmZmZmZmZmZmZmZmZmZmYpO1xuICAgICAgICBhc3NlcnQub2sob2Zmc2V0ICsgOCA8PSBidWYubGVuZ3RoLCBcImF0dGVtcHQgdG8gd3JpdGUgYmV5b25kIGVuZCBvZiBidWZmZXJcIik7XG4gICAgfVxuXG4gICAgaWYgKHZhbCA8IDB4MTAwMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgb2Zmc2V0LCBub0Fzc2VydCk7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQzMkxFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQgKyA0LCBub0Fzc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGJlY2F1c2UgMl42NC0xIGdldHMgcm91bmRlZCB1cCB0byAyXjY0XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsxXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzNdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzZdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs3XSA9IDB4ZmY7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMud3JpdGVVSW50NjRMRSA9IHdyaXRlVUludDY0TEU7XG5cblxuZnVuY3Rpb24gcmVhZEludDI0QkUoYnVmLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIChidWYucmVhZEludDgob2Zmc2V0LCBub0Fzc2VydCkgPDwgMTYpICsgYnVmLnJlYWRVSW50MTZCRShvZmZzZXQgKyAxLCBub0Fzc2VydCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkSW50MjRCRSA9IHJlYWRJbnQyNEJFO1xuXG5mdW5jdGlvbiB3cml0ZUludDI0QkUoYnVmLCB2YWwsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgIGNoZWNrX2ludCh2YWwsIC0weDgwMDAwMCwgMHg3ZmZmZmYpO1xuICAgICAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8PSBidWYubGVuZ3RoLCBcImF0dGVtcHQgdG8gd3JpdGUgYmV5b25kIGVuZCBvZiBidWZmZXJcIik7XG4gICAgfVxuXG4gICAgYnVmLndyaXRlSW50OCh2YWwgPj4gMTYsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICAgIGJ1Zi53cml0ZVVJbnQxNkJFKHZhbCAmIDB4ZmZmZiwgb2Zmc2V0ICsgMSwgbm9Bc3NlcnQpO1xufVxubW9kdWxlLmV4cG9ydHMud3JpdGVJbnQyNEJFID0gd3JpdGVJbnQyNEJFO1xuXG5mdW5jdGlvbiByZWFkSW50NDBCRShidWYsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICByZXR1cm4gKGJ1Zi5yZWFkSW50OChvZmZzZXQsIG5vQXNzZXJ0KSB8fCAwKSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDEsIG5vQXNzZXJ0KTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRJbnQ0MEJFID0gcmVhZEludDQwQkU7XG5cbmZ1bmN0aW9uIHdyaXRlSW50NDBCRShidWYsIHZhbCwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgICAgY2hlY2tfaW50KHZhbCwgLTB4ODAwMDAwMDAwMCwgMHg3ZmZmZmZmZmZmKTtcbiAgICAgICAgYXNzZXJ0Lm9rKG9mZnNldCArIDUgPD0gYnVmLmxlbmd0aCwgXCJhdHRlbXB0IHRvIHdyaXRlIGJleW9uZCBlbmQgb2YgYnVmZmVyXCIpO1xuICAgIH1cblxuICAgIGJ1Zi53cml0ZUludDgoTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMiksIG9mZnNldCwgbm9Bc3NlcnQpO1xuICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDEsIG5vQXNzZXJ0KTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlSW50NDBCRSA9IHdyaXRlSW50NDBCRTtcblxuZnVuY3Rpb24gcmVhZEludDQ4QkUoYnVmLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIGJ1Zi5yZWFkSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSAqIFNISUZUX0xFRlRfMzIgKyBidWYucmVhZFVJbnQzMkJFKG9mZnNldCArIDIsIG5vQXNzZXJ0KTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRJbnQ0OEJFID0gcmVhZEludDQ4QkU7XG5cbmZ1bmN0aW9uIHdyaXRlSW50NDhCRShidWYsIHZhbCwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgICAgY2hlY2tfaW50KHZhbCwgLTB4ODAwMDAwMDAwMDAwLCAweDdmZmZmZmZmZmZmZik7XG4gICAgICAgIGFzc2VydC5vayhvZmZzZXQgKyA2IDw9IGJ1Zi5sZW5ndGgsIFwiYXR0ZW1wdCB0byB3cml0ZSBiZXlvbmQgZW5kIG9mIGJ1ZmZlclwiKTtcbiAgICB9XG5cbiAgICBidWYud3JpdGVJbnQxNkJFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgICBidWYud3JpdGVJbnQzMkJFKHZhbCAmIC0xLCBvZmZzZXQgKyAyLCBub0Fzc2VydCk7XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZUludDQ4QkUgPSB3cml0ZUludDQ4QkU7XG5cbmZ1bmN0aW9uIHJlYWRJbnQ1NkJFKGJ1Ziwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHJldHVybiAoKChidWYucmVhZEludDgob2Zmc2V0LCBub0Fzc2VydCkgfHwgMCkgPDwgMTYpICsgYnVmLnJlYWRVSW50MTZCRShvZmZzZXQgKyAxLCBub0Fzc2VydCkpICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0ICsgMywgbm9Bc3NlcnQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZEludDU2QkUgPSByZWFkSW50NTZCRTtcblxuZnVuY3Rpb24gd3JpdGVJbnQ1NkJFKGJ1ZiwgdmFsLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjaGVja19pbnQodmFsLCAtMHg4MDAwMDAwMDAwMDAwMDAsIDB4N2ZmZmZmZmZmZmZmZmYpO1xuICAgICAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8PSBidWYubGVuZ3RoLCBcImF0dGVtcHQgdG8gd3JpdGUgYmV5b25kIGVuZCBvZiBidWZmZXJcIik7XG4gICAgfVxuXG4gICAgaWYgKHZhbCA8IDB4ODAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgdmFyIGhpID0gTWF0aC5mbG9vcih2YWwgKiBTSElGVF9SSUdIVF8zMik7XG4gICAgICAgIGJ1Zi53cml0ZUludDgoaGkgPj4gMTYsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICAgICAgICBidWYud3JpdGVVSW50MTZCRShoaSAmIDB4ZmZmZiwgb2Zmc2V0ICsgMSwgbm9Bc3NlcnQpO1xuICAgICAgICBidWYud3JpdGVJbnQzMkJFKHZhbCAmIC0xLCBvZmZzZXQgKyAzLCBub0Fzc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGJlY2F1c2UgMl41NS0xIGdldHMgcm91bmRlZCB1cCB0byAyXjU1XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHg3ZjtcbiAgICAgICAgYnVmW29mZnNldCsxXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzNdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzZdID0gMHhmZjtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZUludDU2QkUgPSB3cml0ZUludDU2QkU7XG5cbmZ1bmN0aW9uIHJlYWRJbnQ2NEJFKGJ1Ziwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHJldHVybiBidWYucmVhZEludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJCRShvZmZzZXQgKyA0LCBub0Fzc2VydCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkSW50NjRCRSA9IHJlYWRJbnQ2NEJFO1xuXG5mdW5jdGlvbiB3cml0ZUludDY0QkUoYnVmLCB2YWwsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgIGNoZWNrX2ludCh2YWwsIC0weDgwMDAwMDAwMDAwMDAwMDAwMCwgMHg3ZmZmZmZmZmZmZmZmZmZmKTtcbiAgICAgICAgYXNzZXJ0Lm9rKG9mZnNldCArIDggPD0gYnVmLmxlbmd0aCwgXCJhdHRlbXB0IHRvIHdyaXRlIGJleW9uZCBlbmQgb2YgYnVmZmVyXCIpO1xuICAgIH1cblxuICAgIGlmICh2YWwgPCAweDgwMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgYnVmLndyaXRlSW50MzJCRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgb2Zmc2V0LCBub0Fzc2VydCk7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyQkUodmFsICYgLTEsIG9mZnNldCArIDQsIG5vQXNzZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgYmVjYXVzZSAyXjYzLTEgZ2V0cyByb3VuZGVkIHVwIHRvIDJeNjNcbiAgICAgICAgYnVmW29mZnNldF0gPSAweDdmO1xuICAgICAgICBidWZbb2Zmc2V0KzFdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsyXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrM10gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs1XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzddID0gMHhmZjtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZUludDY0QkUgPSB3cml0ZUludDY0QkU7XG5cbmZ1bmN0aW9uIHJlYWRJbnQyNExFKGJ1Ziwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHJldHVybiAoYnVmLnJlYWRJbnQ4KG9mZnNldCArIDIsIG5vQXNzZXJ0KSA8PCAxNikgKyBidWYucmVhZFVJbnQxNkxFKG9mZnNldCwgbm9Bc3NlcnQpO1xufVxubW9kdWxlLmV4cG9ydHMucmVhZEludDI0TEUgPSByZWFkSW50MjRMRTtcblxuZnVuY3Rpb24gd3JpdGVJbnQyNExFKGJ1ZiwgdmFsLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgICBjaGVja19pbnQodmFsLCAtMHg4MDAwMDAsIDB4N2ZmZmZmKTtcbiAgICAgICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPD0gYnVmLmxlbmd0aCwgXCJhdHRlbXB0IHRvIHdyaXRlIGJleW9uZCBlbmQgb2YgYnVmZmVyXCIpO1xuICAgIH1cblxuICAgIGJ1Zi53cml0ZVVJbnQxNkxFKHZhbCAmIDB4ZmZmZiwgb2Zmc2V0LCBub0Fzc2VydCk7XG4gICAgYnVmLndyaXRlSW50OCh2YWwgPj4gMTYsIG9mZnNldCArIDIsIG5vQXNzZXJ0KTtcbn1cbm1vZHVsZS5leHBvcnRzLndyaXRlSW50MjRMRSA9IHdyaXRlSW50MjRMRTtcblxuZnVuY3Rpb24gcmVhZEludDQwTEUoYnVmLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIChidWYucmVhZEludDgob2Zmc2V0ICsgNCwgbm9Bc3NlcnQpIHx8IDApICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyTEUob2Zmc2V0LCBub0Fzc2VydCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkSW50NDBMRSA9IHJlYWRJbnQ0MExFO1xuXG5mdW5jdGlvbiB3cml0ZUludDQwTEUoYnVmLCB2YWwsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgIGNoZWNrX2ludCh2YWwsIC0weDgwMDAwMDAwMDAsIDB4N2ZmZmZmZmZmZik7XG4gICAgICAgIGFzc2VydC5vayhvZmZzZXQgKyA1IDw9IGJ1Zi5sZW5ndGgsIFwiYXR0ZW1wdCB0byB3cml0ZSBiZXlvbmQgZW5kIG9mIGJ1ZmZlclwiKTtcbiAgICB9XG5cbiAgICBidWYud3JpdGVJbnQzMkxFKHZhbCAmIC0xLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgICBidWYud3JpdGVJbnQ4KE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQgKyA0LCBub0Fzc2VydCk7XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZUludDQwTEUgPSB3cml0ZUludDQwTEU7XG5cbmZ1bmN0aW9uIHJlYWRJbnQ0OExFKGJ1Ziwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHJldHVybiBidWYucmVhZEludDE2TEUob2Zmc2V0ICsgNCwgbm9Bc3NlcnQpICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyTEUob2Zmc2V0LCBub0Fzc2VydCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkSW50NDhMRSA9IHJlYWRJbnQ0OExFO1xuXG5mdW5jdGlvbiB3cml0ZUludDQ4TEUoYnVmLCB2YWwsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgIGNoZWNrX2ludCh2YWwsIC0weDgwMDAwMDAwMDAwMCwgMHg3ZmZmZmZmZmZmZmYpO1xuICAgICAgICBhc3NlcnQub2sob2Zmc2V0ICsgNiA8PSBidWYubGVuZ3RoLCBcImF0dGVtcHQgdG8gd3JpdGUgYmV5b25kIGVuZCBvZiBidWZmZXJcIik7XG4gICAgfVxuXG4gICAgYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgb2Zmc2V0LCBub0Fzc2VydCk7XG4gICAgYnVmLndyaXRlSW50MTZMRShNYXRoLmZsb29yKHZhbCAqIFNISUZUX1JJR0hUXzMyKSwgb2Zmc2V0ICsgNCwgbm9Bc3NlcnQpO1xufVxubW9kdWxlLmV4cG9ydHMud3JpdGVJbnQ0OExFID0gd3JpdGVJbnQ0OExFO1xuXG5mdW5jdGlvbiByZWFkSW50NTZMRShidWYsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICByZXR1cm4gKCgoYnVmLnJlYWRJbnQ4KG9mZnNldCArIDYsIG5vQXNzZXJ0KSB8fCAwKSA8PCAxNikgKyBidWYucmVhZFVJbnQxNkxFKG9mZnNldCArIDQsIG5vQXNzZXJ0KSkgKiBTSElGVF9MRUZUXzMyICsgYnVmLnJlYWRVSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlYWRJbnQ1NkxFID0gcmVhZEludDU2TEU7XG5cbmZ1bmN0aW9uIHdyaXRlSW50NTZMRShidWYsIHZhbCwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgICAgY2hlY2tfaW50KHZhbCwgLTB4ODAwMDAwMDAwMDAwMDAsIDB4N2ZmZmZmZmZmZmZmZmYpO1xuICAgICAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8PSBidWYubGVuZ3RoLCBcImF0dGVtcHQgdG8gd3JpdGUgYmV5b25kIGVuZCBvZiBidWZmZXJcIik7XG4gICAgfVxuXG4gICAgaWYgKHZhbCA8IDB4ODAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgYnVmLndyaXRlSW50MzJMRSh2YWwgJiAtMSwgb2Zmc2V0LCBub0Fzc2VydCk7XG4gICAgICAgIHZhciBoaSA9IE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpO1xuICAgICAgICBidWYud3JpdGVVSW50MTZMRShoaSAmIDB4ZmZmZiwgb2Zmc2V0ICsgNCwgbm9Bc3NlcnQpO1xuICAgICAgICBidWYud3JpdGVJbnQ4KGhpID4+IDE2LCBvZmZzZXQgKyA2LCBub0Fzc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGJlY2F1c2UgMl41NS0xIGdldHMgcm91bmRlZCB1cCB0byAyXjU1XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsxXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzNdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzZdID0gMHg3ZjtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cy53cml0ZUludDU2TEUgPSB3cml0ZUludDU2TEU7XG5cbmZ1bmN0aW9uIHJlYWRJbnQ2NExFKGJ1Ziwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHJldHVybiBidWYucmVhZEludDMyTEUob2Zmc2V0ICsgNCwgbm9Bc3NlcnQpICogU0hJRlRfTEVGVF8zMiArIGJ1Zi5yZWFkVUludDMyTEUob2Zmc2V0LCBub0Fzc2VydCk7XG59XG5tb2R1bGUuZXhwb3J0cy5yZWFkSW50NjRMRSA9IHJlYWRJbnQ2NExFO1xuXG5mdW5jdGlvbiB3cml0ZUludDY0TEUoYnVmLCB2YWwsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICAgIGNoZWNrX2ludCh2YWwsIC0weDgwMDAwMDAwMDAwMDAwMDAsIDB4N2ZmZmZmZmZmZmZmZmZmZik7XG4gICAgICAgIGFzc2VydC5vayhvZmZzZXQgKyA4IDw9IGJ1Zi5sZW5ndGgsIFwiYXR0ZW1wdCB0byB3cml0ZSBiZXlvbmQgZW5kIG9mIGJ1ZmZlclwiKTtcbiAgICB9XG5cbiAgICBpZiAodmFsIDwgMHg4MDAwMDAwMDAwMDAwMDAwKSB7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyTEUodmFsICYgLTEsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICAgICAgICBidWYud3JpdGVJbnQzMkxFKE1hdGguZmxvb3IodmFsICogU0hJRlRfUklHSFRfMzIpLCBvZmZzZXQgKyA0LCBub0Fzc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGJlY2F1c2UgMl41NS0xIGdldHMgcm91bmRlZCB1cCB0byAyXjU1XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCsxXSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrMl0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzNdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs0XSA9IDB4ZmY7XG4gICAgICAgIGJ1ZltvZmZzZXQrNV0gPSAweGZmO1xuICAgICAgICBidWZbb2Zmc2V0KzZdID0gMHhmZjtcbiAgICAgICAgYnVmW29mZnNldCs3XSA9IDB4N2Y7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMud3JpdGVJbnQ2NExFID0gd3JpdGVJbnQ2NExFO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/buffer-more-ints/buffer-more-ints.js\n");

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcz8zYTdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/core-util-is/lib/util.js\n");

/***/ }),

/***/ "./node_modules/inherits/inherits.js":
/*!*******************************************!*\
  !*** ./node_modules/inherits/inherits.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("try {\n  var util = __webpack_require__(/*! util */ \"util\");\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  module.exports = __webpack_require__(/*! ./inherits_browser.js */ \"./node_modules/inherits/inherits_browser.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHMuanM/ZDBhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ0cnkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbiAgaWYgKHR5cGVvZiB1dGlsLmluaGVyaXRzICE9PSAnZnVuY3Rpb24nKSB0aHJvdyAnJztcbiAgbW9kdWxlLmV4cG9ydHMgPSB1dGlsLmluaGVyaXRzO1xufSBjYXRjaCAoZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaW5oZXJpdHNfYnJvd3Nlci5qcycpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/inherits/inherits.js\n");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzPzNmYjUiXSwic291cmNlc0NvbnRlbnQiOlsiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/inherits/inherits_browser.js\n");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzP2UzZGIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/isarray/index.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/duplex.js":
/*!************************************************!*\
  !*** ./node_modules/readable-stream/duplex.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzPzNmZWQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIilcbiJdLCJtYXBwaW5ncyI6IkFBQUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/duplex.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzP2IxOWEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSksIGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn0pO1xuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSlcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcbiAgICByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_duplex.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcz83ODBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpXG4gICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_passthrough.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = __webpack_require__(/*! events */ \"events\").EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nvar StringDecoder;\n\n\n/*<replacement>*/\nvar debug = __webpack_require__(/*! util */ \"util\");\nif (debug && debug.debuglog) {\n  debug = debug.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/index.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (util.isString(chunk) && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (util.isNullOrUndefined(chunk)) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/index.js\").StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || util.isNull(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (!util.isNumber(n) || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (util.isNull(ret)) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (!util.isNull(ret))\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      process.nextTick(function() {\n        emitReadable_(stream);\n      });\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      debug('false write response, pause',\n            src._readableState.awaitDrain);\n      src._readableState.awaitDrain++;\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        var self = this;\n        process.nextTick(function() {\n          debug('readable nexttick read 0');\n          self.read(0);\n        });\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    if (!state.reading) {\n      debug('resume read 0');\n      this.read(0);\n    }\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(function() {\n      resume_(stream, state);\n    });\n  }\n}\n\nfunction resume_(stream, state) {\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcz9hZDcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuaWYgKCFFRS5saXN0ZW5lckNvdW50KSBFRS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ3V0aWwnKTtcbmlmIChkZWJ1ZyAmJiBkZWJ1Zy5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSBvcHRpb25zLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KVxuICAgIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKVxuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAodXRpbC5pc1N0cmluZyhjaHVuaykgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoY2h1bmspKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIGlmICghc3RhdGUuZW5kZWQpXG4gICAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKVxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpXG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChhZGRUb0Zyb250KVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKVxuICAgICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIChzdGF0ZS5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbihlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKGlzTmFOKG4pIHx8IHV0aWwuaXNOdWxsKG4pKSB7XG4gICAgLy8gb25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICBpZiAobiA8PSAwKVxuICAgIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAoIXV0aWwuaXNOdW1iZXIobikgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApXG4gICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICBlbHNlXG4gICAgcmV0ID0gbnVsbDtcblxuICBpZiAodXRpbC5pc051bGwocmV0KSkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICBpZiAoIXV0aWwuaXNOdWxsKHJldCkpXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIXV0aWwuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc1N0cmluZyhjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICAgIGVsc2VcbiAgICAgIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmXG4gICAgICAgICAgICAgIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiBjbGVhbnVwO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZClcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtcbiAgZWxzZVxuICAgIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiZcbiAgICAgICAgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSlcbiAgICAgIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQpIHtcbiAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLFxuICAgICAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKVxuICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuXG4gIGlmICghZGVzdC5fZXZlbnRzIHx8ICFkZXN0Ll9ldmVudHMuZXJyb3IpXG4gICAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZWxzZSBpZiAoaXNBcnJheShkZXN0Ll9ldmVudHMuZXJyb3IpKVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvci51bnNoaWZ0KG9uZXJyb3IpO1xuICBlbHNlXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yID0gW29uZXJyb3IsIGRlc3QuX2V2ZW50cy5lcnJvcl07XG5cblxuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbilcbiAgICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdClcbiAgICAgIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpXG4gICAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIC8vIElmIGxpc3RlbmluZyB0byBkYXRhLCBhbmQgaXQgaGFzIG5vdCBleHBsaWNpdGx5IGJlZW4gcGF1c2VkLFxuICAvLyB0aGVuIGNhbGwgcmVzdW1lIHRvIHN0YXJ0IHRoZSBmbG93IG9mIGRhdGEgb24gdGhlIG5leHQgdGljay5cbiAgaWYgKGV2ID09PSAnZGF0YScgJiYgZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIHRoaXMucmVzdW1lKCk7XG4gIH1cblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpcy5yZWFkYWJsZSkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gICAgICAgICAgc2VsZi5yZWFkKDApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICAgIHRoaXMucmVhZCgwKTtcbiAgICB9XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgcmVzdW1lXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZylcbiAgICBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ucmVhZCgpO1xuICAgIH0gd2hpbGUgKG51bGwgIT09IGNodW5rICYmIHN0YXRlLmZsb3dpbmcpO1xuICB9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aClcbiAgICAgICAgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKVxuICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICBpZiAoIWNodW5rIHx8ICFzdGF0ZS5vYmplY3RNb2RlICYmICFjaHVuay5sZW5ndGgpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHN0cmVhbVtpXSkgJiYgdXRpbC5pc1VuZGVmaW5lZCh0aGlzW2ldKSkge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uKG1ldGhvZCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICB9fShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cblxuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChsZW5ndGggPT09IDApXG4gICAgcmV0ID0gbnVsbDtcbiAgZWxzZSBpZiAob2JqZWN0TW9kZSlcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIGVsc2UgaWYgKCFuIHx8IG4gPj0gbGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBhcnJheS5cbiAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgIHJldCA9IGxpc3Quam9pbignJyk7XG4gICAgZWxzZVxuICAgICAgcmV0ID0gQnVmZmVyLmNvbmNhdChsaXN0LCBsZW5ndGgpO1xuICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIGp1c3Qgc29tZSBvZiBpdC5cbiAgICBpZiAobiA8IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBqdXN0IHRha2UgYSBwYXJ0IG9mIHRoZSBmaXJzdCBsaXN0IGl0ZW0uXG4gICAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgcmV0ID0gYnVmLnNsaWNlKDAsIG4pO1xuICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShuKTtcbiAgICB9IGVsc2UgaWYgKG4gPT09IGxpc3RbMF0ubGVuZ3RoKSB7XG4gICAgICAvLyBmaXJzdCBsaXN0IGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb21wbGV4IGNhc2UuXG4gICAgICAvLyB3ZSBoYXZlIGVub3VnaCB0byBjb3ZlciBpdCwgYnV0IGl0IHNwYW5zIHBhc3QgdGhlIGZpcnN0IGJ1ZmZlci5cbiAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICByZXQgPSAnJztcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0ID0gbmV3IEJ1ZmZlcihuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgICAgdmFyIGNweSA9IE1hdGgubWluKG4gLSBjLCBidWYubGVuZ3RoKTtcblxuICAgICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgICByZXQgKz0gYnVmLnNsaWNlKDAsIGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBidWYuY29weShyZXQsIGMsIDAsIGNweSk7XG5cbiAgICAgICAgaWYgKGNweSA8IGJ1Zi5sZW5ndGgpXG4gICAgICAgICAgbGlzdFswXSA9IGJ1Zi5zbGljZShjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuXG4gICAgICAgIGMgKz0gY3B5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIHRocm93IG5ldyBFcnJvcignZW5kUmVhZGFibGUgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_readable.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (!util.isNullOrUndefined(data))\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('prefinish', function() {\n    if (util.isFunction(this._flush))\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzPzI3YmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGRhdGEpKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHV0aWwuaXNGdW5jdGlvbih0aGlzLl9mbHVzaCkpXG4gICAgICB0aGlzLl9mbHVzaChmdW5jdGlvbihlcikge1xuICAgICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHxcbiAgICAgICAgcnMubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgIHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspXG4gICAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAoIXV0aWwuaXNOdWxsKHRzLndyaXRlY2h1bmspICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_transform.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\");\n/*</replacement>*/\n\nvar Stream = __webpack_require__(/*! stream */ \"stream\");\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (!util.isFunction(cb))\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.buffer.length)\n      clearBuffer(this, state);\n  }\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      util.isString(chunk)) {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      state.pendingcb--;\n      cb(er);\n    });\n  else {\n    state.pendingcb--;\n    cb(er);\n  }\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.buffer.length) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  if (stream._writev && state.buffer.length > 1) {\n    // Fast case, write everything using _writev()\n    var cbs = [];\n    for (var c = 0; c < state.buffer.length; c++)\n      cbs.push(state.buffer[c].callback);\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n    state.buffer = [];\n  } else {\n    // Slow case, write chunks one-by-one\n    for (var c = 0; c < state.buffer.length; c++) {\n      var entry = state.buffer[c];\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        c++;\n        break;\n      }\n    }\n\n    if (c < state.buffer.length)\n      state.buffer = state.buffer.slice(c);\n    else\n      state.buffer.length = 0;\n  }\n\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (util.isFunction(chunk)) {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (!util.isNullOrUndefined(chunk))\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else\n      prefinish(stream, state);\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcz9kYzE0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSBvcHRpb25zLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KVxuICAgIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZS4gTm90IHJlYWRhYmxlLicpKTtcbn07XG5cblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIHN0YXRlLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgY2IoZXIpO1xuICB9KTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICBpZiAoIXV0aWwuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc1N0cmluZyhjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICB2YXIgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgZWxzZSBpZiAoIWVuY29kaW5nKVxuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGNiKSlcbiAgICBjYiA9IGZ1bmN0aW9uKCkge307XG5cbiAgaWYgKHN0YXRlLmVuZGVkKVxuICAgIHdyaXRlQWZ0ZXJFbmQodGhpcywgc3RhdGUsIGNiKTtcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXG4gICAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdXRpbC5pc1N0cmluZyhjaHVuaykpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgaWYgKHV0aWwuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpXG4gICAgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpXG4gICAgc3RhdGUuYnVmZmVyLnB1c2gobmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpKTtcbiAgZWxzZVxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpXG4gICAgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO1xuICBlbHNlXG4gICAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgaWYgKHN5bmMpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcik7XG4gIH1cblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcilcbiAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtcbiAgZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJlxuICAgICAgICAhc3RhdGUuY29ya2VkICYmXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXG4gICAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aCA+IDEpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGNicyA9IFtdO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKVxuICAgICAgY2JzLnB1c2goc3RhdGUuYnVmZmVyW2NdLmNhbGxiYWNrKTtcblxuICAgIC8vIGNvdW50IHRoZSBvbmUgd2UgYXJlIGFkZGluZywgYXMgd2VsbC5cbiAgICAvLyBUT0RPKGlzYWFjcykgY2xlYW4gdGhpcyB1cFxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5idWZmZXIsICcnLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgICBjYnNbaV0oZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsZWFyIGJ1ZmZlclxuICAgIHN0YXRlLmJ1ZmZlciA9IFtdO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgICAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyW2NdO1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYysrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gICAgZWxzZVxuICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCA9IDA7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xuXG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihjaHVuaykpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodXRpbC5pc0Z1bmN0aW9uKGVuY29kaW5nKSkge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSlcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmVuZGluZyAmJlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAgICFzdGF0ZS53cml0aW5nKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZVxuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/lib/_stream_writable.js\n");

/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/readable-stream/lib/_stream_passthrough.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcz9jMmFlIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcIilcbiJdLCJtYXBwaW5ncyI6IkFBQUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/readable-stream/passthrough.js\n");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanM/ODcwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/safe-buffer/index.js\n");

/***/ }),

/***/ "./node_modules/string_decoder/index.js":
/*!**********************************************!*\
  !*** ./node_modules/string_decoder/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanM/MWMwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/string_decoder/index.js\n");

/***/ }),

/***/ "./node_modules/uniqid/index.js":
/*!**************************************!*\
  !*** ./node_modules/uniqid/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {/* \n(The MIT License)\nCopyright (c) 2014 Halsz dm <mail@adamhalasz.com>\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n//  Unique Hexatridecimal ID Generator\n// ================================================\n\n//  Dependencies\n// ================================================\nvar pid = process && process.pid ? process.pid.toString(36) : '' ;\nvar mac =  false ? undefined : null ;\nvar address = mac ? parseInt(mac.replace(/\\:|\\D+/gi, '')).toString(36) : '' ;\n\n//  Exports\n// ================================================\nmodule.exports         = function(prefix){ return (prefix || '') + address + pid + now().toString(36); }\nmodule.exports.process = function(prefix){ return (prefix || '')           + pid + now().toString(36); }\nmodule.exports.time    = function(prefix){ return (prefix || '')                 + now().toString(36); }\n\n//  Helpers\n// ================================================\nfunction now(){\n    var time = Date.now();\n    var last = now.last || time;\n    return now.last = time > last ? time : last + 1;\n}\n\nfunction macHandler(error){\n    if(module.parent && module.parent.uniqid_debug){\n        if(error) console.error('Info: No mac address - uniqid() falls back to uniqid.process().', error)\n        if(pid == '') console.error('Info: No process.pid - uniqid.process() falls back to uniqid.time().')\n    }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../.nvm/versions/node/v10.0.0/lib/node_modules/webpack/buildin/module.js */ \"../../.nvm/versions/node/v10.0.0/lib/node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdW5pcWlkL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuaXFpZC9pbmRleC5qcz9jYzk4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIFxuKFRoZSBNSVQgTGljZW5zZSlcbkNvcHlyaWdodCAoYykgMjAxNCBIYWzDoXN6IMOBZMOhbSA8bWFpbEBhZGFtaGFsYXN6LmNvbT5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuLy8gIFVuaXF1ZSBIZXhhdHJpZGVjaW1hbCBJRCBHZW5lcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyAgRGVwZW5kZW5jaWVzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbnZhciBwaWQgPSBwcm9jZXNzICYmIHByb2Nlc3MucGlkID8gcHJvY2Vzcy5waWQudG9TdHJpbmcoMzYpIDogJycgO1xudmFyIG1hYyA9IHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fICE9PSAnZnVuY3Rpb24nID8gcmVxdWlyZSgnbWFjYWRkcmVzcycpLm9uZShtYWNIYW5kbGVyKSA6IG51bGwgO1xudmFyIGFkZHJlc3MgPSBtYWMgPyBwYXJzZUludChtYWMucmVwbGFjZSgvXFw6fFxcRCsvZ2ksICcnKSkudG9TdHJpbmcoMzYpIDogJycgO1xuXG4vLyAgRXhwb3J0c1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5tb2R1bGUuZXhwb3J0cyAgICAgICAgID0gZnVuY3Rpb24ocHJlZml4KXsgcmV0dXJuIChwcmVmaXggfHwgJycpICsgYWRkcmVzcyArIHBpZCArIG5vdygpLnRvU3RyaW5nKDM2KTsgfVxubW9kdWxlLmV4cG9ydHMucHJvY2VzcyA9IGZ1bmN0aW9uKHByZWZpeCl7IHJldHVybiAocHJlZml4IHx8ICcnKSAgICAgICAgICAgKyBwaWQgKyBub3coKS50b1N0cmluZygzNik7IH1cbm1vZHVsZS5leHBvcnRzLnRpbWUgICAgPSBmdW5jdGlvbihwcmVmaXgpeyByZXR1cm4gKHByZWZpeCB8fCAnJykgICAgICAgICAgICAgICAgICsgbm93KCkudG9TdHJpbmcoMzYpOyB9XG5cbi8vICBIZWxwZXJzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIG5vdygpe1xuICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgbGFzdCA9IG5vdy5sYXN0IHx8IHRpbWU7XG4gICAgcmV0dXJuIG5vdy5sYXN0ID0gdGltZSA+IGxhc3QgPyB0aW1lIDogbGFzdCArIDE7XG59XG5cbmZ1bmN0aW9uIG1hY0hhbmRsZXIoZXJyb3Ipe1xuICAgIGlmKG1vZHVsZS5wYXJlbnQgJiYgbW9kdWxlLnBhcmVudC51bmlxaWRfZGVidWcpe1xuICAgICAgICBpZihlcnJvcikgY29uc29sZS5lcnJvcignSW5mbzogTm8gbWFjIGFkZHJlc3MgLSB1bmlxaWQoKSBmYWxscyBiYWNrIHRvIHVuaXFpZC5wcm9jZXNzKCkuJywgZXJyb3IpXG4gICAgICAgIGlmKHBpZCA9PSAnJykgY29uc29sZS5lcnJvcignSW5mbzogTm8gcHJvY2Vzcy5waWQgLSB1bmlxaWQucHJvY2VzcygpIGZhbGxzIGJhY2sgdG8gdW5pcWlkLnRpbWUoKS4nKVxuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uniqid/index.js\n");

/***/ }),

/***/ "./src/common/commandFactory.js":
/*!**************************************!*\
  !*** ./src/common/commandFactory.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createCommand;\n\nvar command = _interopRequireWildcard(__webpack_require__(/*! ./commands */ \"./src/common/commands.js\"));\n\nvar _uniqid = _interopRequireDefault(__webpack_require__(/*! uniqid */ \"./node_modules/uniqid/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction createCommand(commandType, props) {\n  if (!Object.values(command).includes(commandType)) {\n    throw new Error(\"Unknown command \".concat(commandType));\n  }\n\n  return _objectSpread({}, props, {\n    type: commandType\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL2NvbW1hbmRGYWN0b3J5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9jb21tb24vY29tbWFuZEZhY3RvcnkuanM/NGUwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuaW1wb3J0ICogYXMgY29tbWFuZCBmcm9tIFwiLi9jb21tYW5kc1wiO1xuaW1wb3J0IHR5cGUge0NvbW1hbmR9IGZyb20gJy4vdHlwZXMnXG5pbXBvcnQgdW5pcWlkIGZyb20gJ3VuaXFpZCdcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlQ29tbWFuZCAoY29tbWFuZFR5cGU6IHN0cmluZywgcHJvcHM6IE9iamVjdCkge1xuXG4gICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbW1hbmQpLmluY2x1ZGVzKGNvbW1hbmRUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29tbWFuZCAke2NvbW1hbmRUeXBlfWApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICB0eXBlOiBjb21tYW5kVHlwZVxuICAgIH1cbn0iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQUlBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/common/commandFactory.js\n");

/***/ }),

/***/ "./src/common/commands.js":
/*!********************************!*\
  !*** ./src/common/commands.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UPDATE_STATISTICS = exports.ORDER_NOT_DELIVERED = exports.ORDER_DELIVERED = exports.DELIVER_ORDER = exports.PAYMENT_DECLINED = exports.PAYMENT_CONFIRMED = exports.REQUEST_PAYMENT = exports.ITEM_OUT_OF_STOCK = exports.ITEM_RESERVED = exports.RESERVE_ITEM = exports.ORDER_CREATED = exports.CREATE_ORDER = exports.PURCHASE_ATTEMPT = void 0;\nvar PURCHASE_ATTEMPT = 'PURCHASE_ATTEMPT_COMMAND';\nexports.PURCHASE_ATTEMPT = PURCHASE_ATTEMPT;\nvar CREATE_ORDER = 'CREATE_ORDER_COMMAND';\nexports.CREATE_ORDER = CREATE_ORDER;\nvar ORDER_CREATED = 'ORDER_CREATED_COMMAND';\nexports.ORDER_CREATED = ORDER_CREATED;\nvar RESERVE_ITEM = 'RESERVE_ITEM_COMMAND';\nexports.RESERVE_ITEM = RESERVE_ITEM;\nvar ITEM_RESERVED = 'ITEM_RESERVED_COMMAND';\nexports.ITEM_RESERVED = ITEM_RESERVED;\nvar ITEM_OUT_OF_STOCK = 'ITEM_OUT_OF_STOCK_COMMAND';\nexports.ITEM_OUT_OF_STOCK = ITEM_OUT_OF_STOCK;\nvar REQUEST_PAYMENT = 'REQUEST_PAYMENT_COMMAND';\nexports.REQUEST_PAYMENT = REQUEST_PAYMENT;\nvar PAYMENT_CONFIRMED = 'PAYMENT_CONFIRMED_COMMAND';\nexports.PAYMENT_CONFIRMED = PAYMENT_CONFIRMED;\nvar PAYMENT_DECLINED = 'PAYMENT_DECLINED_COMMAND';\nexports.PAYMENT_DECLINED = PAYMENT_DECLINED;\nvar DELIVER_ORDER = 'DELIVER_ORDER_COMMAND';\nexports.DELIVER_ORDER = DELIVER_ORDER;\nvar ORDER_DELIVERED = 'ORDER_DELIVERED_COMMAND';\nexports.ORDER_DELIVERED = ORDER_DELIVERED;\nvar ORDER_NOT_DELIVERED = 'ORDER_NOT_DELIVERED_COMMAND';\nexports.ORDER_NOT_DELIVERED = ORDER_NOT_DELIVERED;\nvar UPDATE_STATISTICS = 'UPDATE_STATISTICS_COMMAND';\nexports.UPDATE_STATISTICS = UPDATE_STATISTICS;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL2NvbW1hbmRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9jb21tb24vY29tbWFuZHMuanM/OTk2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgUFVSQ0hBU0VfQVRURU1QVCA9ICdQVVJDSEFTRV9BVFRFTVBUX0NPTU1BTkQnO1xuXG5leHBvcnQgY29uc3QgQ1JFQVRFX09SREVSID0gJ0NSRUFURV9PUkRFUl9DT01NQU5EJztcbmV4cG9ydCBjb25zdCBPUkRFUl9DUkVBVEVEID0gJ09SREVSX0NSRUFURURfQ09NTUFORCc7XG5cbmV4cG9ydCBjb25zdCBSRVNFUlZFX0lURU0gPSAnUkVTRVJWRV9JVEVNX0NPTU1BTkQnO1xuZXhwb3J0IGNvbnN0IElURU1fUkVTRVJWRUQgPSAnSVRFTV9SRVNFUlZFRF9DT01NQU5EJztcbmV4cG9ydCBjb25zdCBJVEVNX09VVF9PRl9TVE9DSyA9ICdJVEVNX09VVF9PRl9TVE9DS19DT01NQU5EJztcblxuZXhwb3J0IGNvbnN0IFJFUVVFU1RfUEFZTUVOVCA9ICdSRVFVRVNUX1BBWU1FTlRfQ09NTUFORCc7XG5leHBvcnQgY29uc3QgUEFZTUVOVF9DT05GSVJNRUQgPSAnUEFZTUVOVF9DT05GSVJNRURfQ09NTUFORCc7XG5leHBvcnQgY29uc3QgUEFZTUVOVF9ERUNMSU5FRCA9ICdQQVlNRU5UX0RFQ0xJTkVEX0NPTU1BTkQnO1xuXG5leHBvcnQgY29uc3QgREVMSVZFUl9PUkRFUiA9ICdERUxJVkVSX09SREVSX0NPTU1BTkQnO1xuZXhwb3J0IGNvbnN0IE9SREVSX0RFTElWRVJFRCA9ICdPUkRFUl9ERUxJVkVSRURfQ09NTUFORCc7XG5leHBvcnQgY29uc3QgT1JERVJfTk9UX0RFTElWRVJFRCA9ICdPUkRFUl9OT1RfREVMSVZFUkVEX0NPTU1BTkQnO1xuXG5leHBvcnQgY29uc3QgVVBEQVRFX1NUQVRJU1RJQ1MgPSAnVVBEQVRFX1NUQVRJU1RJQ1NfQ09NTUFORCciXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUVBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUVBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/common/commands.js\n");

/***/ }),

/***/ "./src/common/config.js":
/*!******************************!*\
  !*** ./src/common/config.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.config = void 0;\nvar config = {\n  queueConnection: {\n    host: 'amqp://localhost' // TODO move to separate host\n\n  },\n  port: {\n    frontend: 3000\n  }\n};\nexports.config = config;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL2NvbmZpZy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvY29tbW9uL2NvbmZpZy5qcz81ZjU5Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbmZpZyA9IHtcbiAgICBxdWV1ZUNvbm5lY3Rpb246IHtcbiAgICAgICAgaG9zdDogJ2FtcXA6Ly9sb2NhbGhvc3QnIC8vIFRPRE8gbW92ZSB0byBzZXBhcmF0ZSBob3N0XG4gICAgfSxcblxuICAgIHBvcnQ6IHtcbiAgICAgICAgZnJvbnRlbmQ6IDMwMDBcbiAgICB9XG59O1xuXG5leHBvcnQge2NvbmZpZ307Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBTEE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/common/config.js\n");

/***/ }),

/***/ "./src/common/queue.js":
/*!*****************************!*\
  !*** ./src/common/queue.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.consumeCommand = exports.queueCommand = void 0;\n\nvar amqp = _interopRequireWildcard(__webpack_require__(/*! amqplib */ \"./node_modules/amqplib/channel_api.js\"));\n\nvar _config = __webpack_require__(/*! ./config */ \"./src/common/config.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nvar queueCommand = function queueCommand(command) {\n  var queueName = command.type;\n  amqp.connect(_config.config.queueConnection.host).then(function (conn) {\n    return conn.createChannel().then(function (ch) {\n      var msg = JSON.stringify(command);\n      var ok = ch.assertQueue(queueName, {\n        durable: true\n      });\n      return ok.then(function (_qok) {\n        ch.sendToQueue(queueName, Buffer.from(msg));\n        return ch.close();\n      });\n    }).finally(function () {\n      conn.close();\n    });\n  }).catch(console.warn);\n};\n\nexports.queueCommand = queueCommand;\n\nvar consumeCommand = function consumeCommand(queueName, callback) {\n  var connection = amqp.connect(_config.config.queueConnection.host);\n  var channel = connection.then(function (conn) {\n    return conn.createChannel();\n  });\n  channel.then(function (ch) {\n    ch.assertQueue(queueName);\n    ch.consume(queueName, function (msg) {\n      callback(JSON.parse(msg.content.toString()));\n      ch.ackAll();\n    }\n    /*, {noAck: true}*/\n    );\n  });\n};\n\nexports.consumeCommand = consumeCommand;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL3F1ZXVlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3NyYy9jb21tb24vcXVldWUuanM/YjllYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgKiBhcyBhbXFwIGZyb20gJ2FtcXBsaWInXG5pbXBvcnQge2NvbmZpZ30gZnJvbSAnLi9jb25maWcnXG5pbXBvcnQgdHlwZSB7Q29tbWFuZH0gZnJvbSAnLi90eXBlcydcblxuY29uc3QgcXVldWVDb21tYW5kID0gZnVuY3Rpb24oY29tbWFuZDogQ29tbWFuZCk6IHZvaWQge1xuICAgIGNvbnN0IHF1ZXVlTmFtZSA9IGNvbW1hbmQudHlwZTtcbiAgICBhbXFwLmNvbm5lY3QoY29uZmlnLnF1ZXVlQ29ubmVjdGlvbi5ob3N0KS50aGVuKGZ1bmN0aW9uKGNvbm4pIHtcbiAgICAgICAgcmV0dXJuIGNvbm4uY3JlYXRlQ2hhbm5lbCgpLnRoZW4oZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IEpTT04uc3RyaW5naWZ5KGNvbW1hbmQpO1xuICAgICAgICAgICAgY29uc3Qgb2sgPSBjaC5hc3NlcnRRdWV1ZShxdWV1ZU5hbWUsIHtkdXJhYmxlOiB0cnVlfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBvay50aGVuKGZ1bmN0aW9uKF9xb2spIHtcbiAgICAgICAgICAgICAgICBjaC5zZW5kVG9RdWV1ZShxdWV1ZU5hbWUsIEJ1ZmZlci5mcm9tKG1zZykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaC5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7IGNvbm4uY2xvc2UoKTsgfSk7XG4gICAgfSkuY2F0Y2goY29uc29sZS53YXJuKTtcbn1cblxuY29uc3QgY29uc3VtZUNvbW1hbmQgPSBmdW5jdGlvbihxdWV1ZU5hbWU6IHN0cmluZywgY2FsbGJhY2s6IChjbWQ6IENvbW1hbmQpID0+IHZvaWQpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gYW1xcC5jb25uZWN0KGNvbmZpZy5xdWV1ZUNvbm5lY3Rpb24uaG9zdCk7XG4gICAgY29uc3QgY2hhbm5lbCA9IGNvbm5lY3Rpb24udGhlbihjb25uID0+IGNvbm4uY3JlYXRlQ2hhbm5lbCgpKTtcbiAgICBjaGFubmVsXG4gICAgLnRoZW4oY2ggPT4ge1xuICAgICAgICBjaC5hc3NlcnRRdWV1ZShxdWV1ZU5hbWUpO1xuICAgICAgICBjaC5jb25zdW1lKHF1ZXVlTmFtZSwgbXNnID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKEpTT04ucGFyc2UobXNnLmNvbnRlbnQudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgY2guYWNrQWxsKCk7XG4gICAgICAgIH0vKiwge25vQWNrOiB0cnVlfSovKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHtxdWV1ZUNvbW1hbmQsIGNvbnN1bWVDb21tYW5kfSJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFDQTs7Ozs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSEE7QUFJQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/common/queue.js\n");

/***/ }),

/***/ "./src/stock/index.js":
/*!****************************!*\
  !*** ./src/stock/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar command = _interopRequireWildcard(__webpack_require__(/*! ../common/commands */ \"./src/common/commands.js\"));\n\nvar stock = _interopRequireWildcard(__webpack_require__(/*! ./stock */ \"./src/stock/stock.js\"));\n\nvar _queue = __webpack_require__(/*! ../common/queue */ \"./src/common/queue.js\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\n(0, _queue.consumeCommand)(command.RESERVE_ITEM, stock.reserve);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RvY2svaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3N0b2NrL2luZGV4LmpzPzU3OGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY29tbWFuZCBmcm9tICcuLi9jb21tb24vY29tbWFuZHMnO1xuaW1wb3J0ICogYXMgc3RvY2sgZnJvbSAnLi9zdG9jayc7XG5pbXBvcnQgeyBjb25zdW1lQ29tbWFuZCB9IGZyb20gXCIuLi9jb21tb24vcXVldWVcIjtcblxuY29uc3VtZUNvbW1hbmQoY29tbWFuZC5SRVNFUlZFX0lURU0sIHN0b2NrLnJlc2VydmUpOyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/stock/index.js\n");

/***/ }),

/***/ "./src/stock/stock.js":
/*!****************************!*\
  !*** ./src/stock/stock.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reserve = reserve;\n\nvar _commandFactory = _interopRequireDefault(__webpack_require__(/*! ../common/commandFactory */ \"./src/common/commandFactory.js\"));\n\nvar queue = _interopRequireWildcard(__webpack_require__(/*! ../common/queue */ \"./src/common/queue.js\"));\n\nvar command = _interopRequireWildcard(__webpack_require__(/*! ../common/commands */ \"./src/common/commands.js\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction reserve(reserveItemCommand) {\n  console.log(\"Reserving item \".concat(JSON.stringify(reserveItemCommand))); // TODO reserve item\n\n  var itemReservedCommand = (0, _commandFactory.default)(command.ITEM_RESERVED, reserveItemCommand);\n  queue.queueCommand(itemReservedCommand);\n}\n\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3RvY2svc3RvY2suanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL3N0b2NrL3N0b2NrLmpzPzRiZjEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHR5cGUge1Jlc2VydmVJdGVtQ29tbWFuZCwgSXRlbVJlc2VydmVkQ29tbWFuZH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcbmltcG9ydCBjcmVhdGVDb21tYW5kIGZyb20gJy4uL2NvbW1vbi9jb21tYW5kRmFjdG9yeSc7XG5pbXBvcnQgKiBhcyBxdWV1ZSBmcm9tICcuLi9jb21tb24vcXVldWUnO1xuaW1wb3J0ICogYXMgY29tbWFuZCBmcm9tICcuLi9jb21tb24vY29tbWFuZHMnXG5cbmV4cG9ydCBmdW5jdGlvbiByZXNlcnZlKHJlc2VydmVJdGVtQ29tbWFuZDogUmVzZXJ2ZUl0ZW1Db21tYW5kKTogdm9pZCB7XG4gICAgY29uc29sZS5sb2coYFJlc2VydmluZyBpdGVtICR7SlNPTi5zdHJpbmdpZnkocmVzZXJ2ZUl0ZW1Db21tYW5kKX1gKTtcblxuICAgIC8vIFRPRE8gcmVzZXJ2ZSBpdGVtXG5cbiAgICBjb25zdCBpdGVtUmVzZXJ2ZWRDb21tYW5kOiBJdGVtUmVzZXJ2ZWRDb21tYW5kID0gY3JlYXRlQ29tbWFuZChjb21tYW5kLklURU1fUkVTRVJWRUQsIHJlc2VydmVJdGVtQ29tbWFuZCk7IFxuICAgIHF1ZXVlLnF1ZXVlQ29tbWFuZChpdGVtUmVzZXJ2ZWRDb21tYW5kKTtcbn07Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBREEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/stock/stock.js\n");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"assert\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZXJ0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYXNzZXJ0XCI/ODE3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJhc3NlcnRcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///assert\n");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"buffer\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVmZmVyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYnVmZmVyXCI/YmZmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJidWZmZXJcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///buffer\n");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZlbnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZXZlbnRzXCI/N2E3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///events\n");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"net\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmV0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibmV0XCI/MjFlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXRcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///net\n");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"querystring\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVlcnlzdHJpbmcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJxdWVyeXN0cmluZ1wiPzMwYzYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///querystring\n");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stream\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyZWFtLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwic3RyZWFtXCI/NzU3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJlYW1cIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///stream\n");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"tls\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGxzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwidGxzXCI/OTRjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0bHNcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///tls\n");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXJsLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwidXJsXCI/NjFlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///url\n");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcInV0aWxcIj9iZTBiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///util\n");

/***/ })

/******/ });